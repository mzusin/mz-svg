{
  "version": 3,
  "sources": ["../src/main/core.ts", "../src/main/shapes/primitive-shapes.ts", "../node_modules/mz-math/src/main/format.ts", "../node_modules/mz-math/src/main/angle.ts", "../node_modules/mz-math/src/main/linear-algebra/vector.ts", "../node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../node_modules/mz-math/src/main/random.ts", "../node_modules/mz-math/src/main/other.ts", "../node_modules/mz-math/src/main/convert.ts", "../node_modules/mz-math/src/main/derivative.ts", "../node_modules/mz-math/src/main/equations/linear-equations.ts", "../node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../node_modules/mz-math/src/main/path-movement.ts", "../node_modules/mz-math/src/main/color.ts", "../node_modules/mz-math/src/main/id.ts", "../node_modules/mz-math/src/main/shapes.ts", "../src/main/path/scanner.ts", "../src/main/path/parser.ts", "../src/main/path/minify.ts", "../src/main/path/convert.ts", "../src/main/path/index.ts", "../src/main/shapes/stars.ts", "../src/main/shapes/flowers.ts", "../src/main/shapes/shape-paths.ts", "../src/main/io-browser.ts", "../src/main/containers.ts", "../src/main/helpers.ts", "../src/main/path/bbox.ts", "../src/main/path/transform.ts"],
  "sourcesContent": ["import { IPrimitiveShapeProps } from '../interfaces';\n\n/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\nexport interface ICreateSVGProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n    autoViewBox?: boolean;\n}\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props?: ICreateSVGProps) : SVGSVGElement => {\n\n    const doc = props?.document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n\n    let viewBox = props?.viewBox;\n    if(props?.autoViewBox){\n        viewBox = `${ props?.x || 0 } ${ props?.y || 0 } ${ props?.width || 0 } ${ props?.height || 0 }`;\n    }\n\n    setAttributes($svg, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['viewBox', viewBox],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};\n\nexport const getCommonAttributes = (props?: {\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from '../core';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport interface ICreatePathProps extends IPrimitiveShapeProps{\n    d?: string;\n    pathLength?: string|number;\n}\n\nexport const createPath = (props?: ICreatePathProps) : SVGPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(props?.d){\n        // remove newlines and double spaces\n        props.d = props?.d.replace(/\\s\\s+/g, ' ');\n    }\n\n    setAttributes($path, [\n        ['d', props?.d],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\nexport interface ICreateRectProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n    pathLength?: string|number;\n}\n\nexport const createRect = (props?: ICreateRectProps) : SVGRectElement => {\n    const doc = props?.document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\nexport interface ICreateCircleProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createCircle = (props?: ICreateCircleProps) : SVGCircleElement => {\n\n    const doc = props?.document || window.document;\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['r', props?.r],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\nexport interface ICreateEllipseProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createEllipse = (props?: ICreateEllipseProps) : SVGEllipseElement => {\n    const doc = props?.document || window.document;\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\nexport interface ICreateLineProps extends IPrimitiveShapeProps{\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createLine = (props?: ICreateLineProps) : SVGLineElement => {\n    const doc = props?.document || window.document;\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props?.x1],\n        ['x2', props?.x2],\n        ['y1', props?.y1],\n        ['y2', props?.y2],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\nexport interface ICreatePolygonProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolygon = (props?: ICreatePolygonProps) : SVGPolygonElement => {\n    const doc = props?.document || window.document;\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n\nexport interface ICreatePolylineProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolyline = (props?: ICreatePolylineProps) : SVGPolylineElement => {\n    const doc = props?.document || window.document;\n\n    const $polyline = doc.createElementNS(SVG_NAMESPACE, 'polyline');\n\n    setAttributes($polyline, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polyline;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n\n    return [\n        linearEquation(equation1, decimalPlaces),\n        linearEquation(equation2, decimalPlaces),\n    ];\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { EPathDataCommand, IPathDataScanResult } from './interfaces';\n\nconst NUMBER_REGEX = /^[+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d+)?(?:(?<=\\d)(?:[eE][+-]?\\d+))?/;\n\n/**\n * Path Data Scanner.\n */\nexport const scan = (pathData?: string) : IPathDataScanResult => {\n\n    const result: IPathDataScanResult = {\n        tokens: [],\n        errors: [],\n    };\n\n    if(!pathData || pathData.trim() === '') return result;\n\n    let current = 0;\n    let line = 0;\n    let col = 0;\n\n    const isEnd = () => {\n        return current >= pathData.length;\n    };\n\n    const addKeywordToken = (tokenType: EPathDataCommand) => {\n        result.tokens.push({\n            tokenType,\n            line,\n            col,\n        });\n    };\n\n    const addNumberToken = (num: number|string) => {\n        result.tokens.push({\n            tokenType: 'num',\n            value: num,\n            line,\n            col,\n        });\n    };\n\n    const addError = (msg: string) => {\n        result.errors.push({\n            line,\n            col,\n            msg,\n        });\n    };\n\n    const matchNumber = () : boolean => {\n        if(isEnd()) return false;\n        return NUMBER_REGEX.test(pathData.substring(current));\n    };\n\n    /**\n     * Scan a single token.\n     */\n    const scanToken = () => {\n        const char = pathData[current];\n\n        // Path data can contain newline characters and\n        // thus can be broken up into multiple lines to improve readability.\n        // If a newline character ---> update line and col params.\n        if(char.charAt(0) === '\\n' || char.charAt(0) === '\\r'){\n            current++;\n            col = 0;\n            line++;\n            return;\n        }\n\n        // Superfluous white space and separators such as commas can be eliminated.\n        // \"M 100 100 L 200 200\" contains unnecessary spaces and could be expressed more compactly as \"M100 100L200 200\".\n        if(/\\s/.test(char) || char === ','){\n            current++;\n            col++;\n            return;\n        }\n\n        // try to match a number\n        if(matchNumber()){\n            const matchRes = pathData.substring(current).match(NUMBER_REGEX);\n\n            if(matchRes && matchRes.length > 0){\n                const num = matchRes[0];\n                addNumberToken(num);\n\n                current += num.length;\n                col += num.length;\n                return;\n            }\n        }\n\n        switch(char){\n            case 'M': addKeywordToken(EPathDataCommand.MoveToAbs); break;\n            case 'm': addKeywordToken(EPathDataCommand.MoveToRel); break;\n            case 'Z': addKeywordToken(EPathDataCommand.ClosePathAbs); break;\n            case 'z': addKeywordToken(EPathDataCommand.ClosePathRel); break;\n            case 'L': addKeywordToken(EPathDataCommand.LineToAbs); break;\n            case 'l': addKeywordToken(EPathDataCommand.LineToRel); break;\n            case 'H': addKeywordToken(EPathDataCommand.LineToHorizontalAbs); break;\n            case 'h': addKeywordToken(EPathDataCommand.LineToHorizontalRel); break;\n            case 'V': addKeywordToken(EPathDataCommand.LineToVerticalAbs); break;\n            case 'v': addKeywordToken(EPathDataCommand.LineToVerticalRel); break;\n            case 'C': addKeywordToken(EPathDataCommand.CubicCurveToAbs); break;\n            case 'c': addKeywordToken(EPathDataCommand.CubicCurveToRel); break;\n            case 'S': addKeywordToken(EPathDataCommand.CubicCurveToSmoothAbs); break;\n            case 's': addKeywordToken(EPathDataCommand.CubicCurveToSmoothRel); break;\n            case 'Q': addKeywordToken(EPathDataCommand.QuadraticCurveToAbs); break;\n            case 'q': addKeywordToken(EPathDataCommand.QuadraticCurveToRel); break;\n            case 'T': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothAbs); break;\n            case 't': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothRel); break;\n            case 'A': addKeywordToken(EPathDataCommand.ArcAbs); break;\n            case 'a': addKeywordToken(EPathDataCommand.ArcRel); break;\n\n            default: {\n                addError(`Unexpected character ${ char }`);\n                break;\n            }\n        }\n\n        current++;\n        col++;\n    };\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        scanToken();\n    }\n\n    return result;\n};", "import { EPathDataCommand, IPathData, IPathDataScanResult, IPathDataToken } from './interfaces';\n\n/**\n * All path data instructions are expressed as one character (e.g., a moveto is expressed as an M).\n * Relative versions of all commands are available (uppercase means absolute coordinates, lowercase means relative coordinates).\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n */\nexport const parse = (scanResult: IPathDataScanResult) : IPathData => {\n\n    const pathData: IPathData = {\n        commands: [],\n        errors: scanResult.errors || [],\n    };\n\n    if(scanResult.errors.length > 0 ||\n        scanResult.tokens.length === 0) return pathData;\n\n    const { tokens, errors } = scanResult;\n\n    const error = (token: IPathDataToken, msg: string) => {\n        errors.push({\n            line: token?.line,\n            col: token?.col,\n            msg,\n        });\n    };\n\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    if(tokens[0].tokenType !== EPathDataCommand.MoveToAbs &&\n        tokens[0].tokenType !== EPathDataCommand.MoveToRel) {\n        error(tokens[0], `A path data segment must begin with a 'moveto' command 'M' or 'm'.`);\n        return pathData;\n    }\n\n    let current = 0;\n\n    const isEnd = () => {\n        return current >= tokens.length;\n    };\n\n    const areArcFlagsValid = (tokenType: string): boolean => {\n\n        // we are checking only 'A/a' type\n        if(!tokenType || tokenType.toLowerCase() !== 'a') return true;\n\n        // 4th and 5th param should be 0 or 1\n        const val4 = (tokens[current + 4]?.value || '').toString();\n        const val5 = (tokens[current + 5]?.value || '').toString();\n\n        return (val4 === '0' || val4 === '1') && (val5 === '0' || val5 === '1');\n    };\n\n    /**\n     * https://www.w3.org/TR/SVG11/paths.html#PathData\n     */\n    const parseCommand = (paramsCount: number, nextParamsTokenType: EPathDataCommand, isRelative: boolean) => {\n\n        const tokenType = tokens[current].tokenType;\n        const params: number[] = [];\n\n        if(paramsCount > 0){\n\n            // Validate the parameters count, and add them to the params list.\n            for(let i= 1; i <= paramsCount; i++){\n                if(!tokens[current + i] || tokens[current + i].tokenType !== 'num'){\n                    error(tokens[current], `Expected number(s) after command ${ tokenType }.`);\n                    current += paramsCount;\n                    return;\n                }\n\n                params.push(Number(tokens[current + i].value));\n            }\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        pathData.commands.push({\n            command: tokens[current].tokenType as EPathDataCommand,\n            params,\n        });\n\n        current += paramsCount + 1;\n\n        if(paramsCount <= 0) return;\n\n        // If the command is followed by multiple sets of coordinates, the subsequent pairs are treated as implicit commands.\n        const nextTokens: IPathDataToken[] = [];\n\n        // Add all 'next params' to the list.\n        while(tokens[current]?.tokenType === 'num'){\n            nextTokens.push(tokens[current]);\n            current++;\n        }\n\n        // Validate next params count.\n        if(nextTokens.length % paramsCount !== 0){\n            error(nextTokens[nextTokens.length - 1], `Expected a number.`);\n            return;\n        }\n\n        const nextCommand = (isRelative ? nextParamsTokenType.toLowerCase() : nextParamsTokenType.toUpperCase()) as EPathDataCommand;\n\n        // Add them to the commands list.\n        for(let i= 0; i < nextTokens.length; i += paramsCount){\n            const nextParams: number[] = [];\n            for(let j = 0; j < paramsCount; j++){\n                nextParams.push(Number(nextTokens[i + j].value));\n            }\n            pathData.commands.push({\n                command: nextCommand,\n                params: nextParams,\n            });\n        }\n    };\n\n    const parseNext = () => {\n        const token = tokens[current];\n\n        const isRelative = token.tokenType.toLowerCase() === token.tokenType;\n\n        switch (token.tokenType){\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.LineToRel:{\n                parseCommand(2, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                parseCommand(0, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:\n            case EPathDataCommand.LineToHorizontalRel:\n            case EPathDataCommand.LineToVerticalAbs:\n            case EPathDataCommand.LineToVerticalRel:{\n                parseCommand(1, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:\n            case EPathDataCommand.CubicCurveToRel:{\n                parseCommand(6, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToAbs:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                parseCommand(4, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                parseCommand(2, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:\n            case EPathDataCommand.ArcRel:{\n                parseCommand(7, token.tokenType, isRelative);\n                break;\n            }\n\n            default: {\n                error(tokens[current], `Wrong path command.`);\n                current++;\n                break;\n            }\n        }\n    };\n\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    parseCommand(2, EPathDataCommand.LineToAbs, tokens[0].tokenType === EPathDataCommand.MoveToRel);\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        parseNext();\n    }\n\n    return pathData;\n};", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\n\nconst numberToString = (num: number, decimalPlaces = 2) : string => {\n\n    if(Number.isInteger(num)) return num.toString();\n\n    const _num = setDecimalPlaces(num, decimalPlaces).toString();\n    const parts = _num.split('.');\n    const intPart = parts[0];\n    const decimalPart = parts[1];\n\n    if(intPart === '0') return `.${ decimalPart }`;\n    if(intPart === '-0') return `-.${ decimalPart }`;\n\n    return _num;\n};\n\nconst combineParams = (params: number[], decimalPlaces: number) => {\n    if(!params || params.length <= 0) return '';\n\n    let combined = numberToString(params[0], decimalPlaces);\n\n    for(let i= 1; i<params.length; i++){\n        const param = params[i];\n        const str = numberToString(param, decimalPlaces);\n        if(param < 0){\n            combined +=  str;\n        }\n        else{\n            combined += ` ${ str }`;\n        }\n    }\n\n    return combined;\n};\n\nexport const pathDataMinify = (pathData: IPathData, decimalPlaces = 2) : string => {\n\n    let d = '';\n    let lastCommand: EPathDataCommand|null = null;\n\n    for(const item of pathData.commands){\n\n        // handle cases like 'L80 0' ----> 'H80', 'L0 80' ----> 'V80'\n        if(item.command === EPathDataCommand.LineToAbs){\n            if(item.params[0] === 0){\n                d += `V${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalAbs;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `H${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalAbs;\n                continue;\n            }\n        }\n\n        // handle cases like 'l80 0' ----> 'h80' & 'l0 80' ----> 'v80'\n        if(item.command === EPathDataCommand.LineToRel){\n            if(item.params[0] === 0){\n                d += `v${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalRel;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `h${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalRel;\n                continue;\n            }\n        }\n\n        // handle cases like 'c0 0 10 0 10 10' ---> 's10 0 10 10'\n        if(item.command === EPathDataCommand.CubicCurveToRel &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToAbs.toLowerCase() &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToSmoothAbs.toLowerCase()){\n            if(item.params[0] === 0 && item.params[1] === 0){\n\n                const params = combineParams([\n                    item.params[2],\n                    item.params[3],\n                    item.params[4],\n                    item.params[5],\n                ], decimalPlaces);\n\n                d += `s${ params }`;\n                lastCommand = EPathDataCommand.CubicCurveToSmoothRel;\n                continue;\n            }\n        }\n\n        const canSkipCommand =\n            (lastCommand === item.command) ||\n            (lastCommand === EPathDataCommand.MoveToAbs && item.command === EPathDataCommand.LineToAbs) ||\n            (lastCommand === EPathDataCommand.MoveToRel && item.command === EPathDataCommand.LineToRel);\n\n        if(canSkipCommand){\n            if(item.params.length > 0 && item.params[0] >= 0){\n                d += ' ';\n            }\n        }\n        else{\n            d += item.command;\n        }\n\n        d += combineParams(item.params, decimalPlaces);\n\n        lastCommand = item.command;\n    }\n\n    return d.trim();\n};\n", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\nimport { pathDataMinify } from './minify';\n\nexport const pathDataToRelative = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToAbs:{\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToRel:{\n                x += commands[i].params[0];\n                y += commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] -= x;\n                x = savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                x += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] -= y;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                y += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] -= x;\n                commands[i].params[5] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                x += commands[i].params[4];\n                y += commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                x += commands[i].params[2];\n                y += commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] -= x;\n                commands[i].params[6] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                x += commands[i].params[5];\n                y += commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command lowercase\n        commands[i].command = commands[i].command.toLowerCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToAbsolute = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i]\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToRel:{\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToRel:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                x = commands[i].params[0];\n                y = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] += x;\n                x += savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                x = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] += y;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                y = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] += x;\n                commands[i].params[5] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                x = commands[i].params[4];\n                y = commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                x = commands[i].params[2];\n                y = commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] += x;\n                commands[i].params[6] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                x = commands[i].params[5];\n                y = commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command uppercase\n        commands[i].command = commands[i].command.toUpperCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToString = (pathData: IPathData, minify?: boolean, decimalPlaces = 2) : string => {\n    if(!pathData || pathData.commands.length <= 0) return '';\n\n    let d = '';\n\n    if(minify){\n        return pathDataMinify(pathData, decimalPlaces);\n    }\n\n    for(const item of pathData.commands){\n        d += item.command;\n        if(item.params.length > 0){\n            d += ` ${ item.params.map(param => Number.isInteger(param) ? param : setDecimalPlaces(param, decimalPlaces)).join(' ')} `\n        }\n        else{\n            d += ' ';\n        }\n    }\n\n    return d.trim();\n};\n\nexport const maximizeAbsolutePath = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n\n                // update y to be the same as in previous command\n                commands[i].params[1] = prev.params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n                const y = commands[i].params[0];\n\n                // update x to be the same as in previous command\n                commands[i].params[0] = prev.params[0];\n                commands[i].params.push(y);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:{\n                // prev should be Cubic B\u00E9zier Curve Abs (C)\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (C): x1,y1, x2,y2, x,y\n                commands[i].command = EPathDataCommand.CubicCurveToAbs;\n\n                // For S: (x2 y2 x y)\n                // The first control point is assumed to be the reflection\n                // of the second control point on the previous command\n                // relative to the current point.\n                // (If there is no previous command or if the previous command was not an C, c, S or s,\n                // assume the first control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[3]); // prev y2\n                commands[i].params.unshift(prev.params[2]); // prev x2\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                // prev should be Quadratic B\u00E9zier Curve Abs (Q)\n\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (Q): x1 y1 x y\n                commands[i].command = EPathDataCommand.QuadraticCurveToAbs;\n\n                // For T: (x y)\n                // The control point is assumed to be the reflection of the control point on the previous command relative to the current point.\n                // (If there is no previous command or if the previous command was not a Q, q, T or t,\n                // assume the control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[1]); // prev y2\n                commands[i].params.unshift(prev.params[0]); // prev x2\n                break;\n            }\n        }\n    }\n\n    return pathData;\n};", "import { IPathData } from './interfaces';\nimport { scan } from './scanner';\nimport { parse } from './parser';\nimport { pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { pathDataMinify } from './minify';\n\nexport const isPathValid = (d?: string): boolean => {\n    const parsed = parsePath(d);\n    return parsed.errors.length <= 0;\n};\n\n/**\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n * \u2018d\u2019 attribute contains the moveto, line, curve (both cubic and quadratic B\u00E9ziers), arc and closepath instructions.\n */\nexport const parsePath = (d?: string): IPathData => {\n    const scanResult = scan(d);\n    return parse(scanResult);\n};\n\n/**\n * Converts all path commands to relative.\n */\nexport const pathToRel = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToRelative(parsed), !beautify, decimalPlaces);\n};\n\n/**\n * Converts all path commands to absolute.\n */\nexport const pathToAbs = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToAbsolute(parsed), !beautify, decimalPlaces);\n};\n\nexport const minifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataMinify(parsed, decimalPlaces);\n};\n\nexport const beautifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(parsed, false, decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\n\nexport interface ICreateStarProps extends IPrimitiveShapeProps{\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n    type?: number;\n}\n\nexport const createStar = (props: ICreateStarProps) : SVGPathElement => {\n\n    switch (props.type){\n        case 2: {\n            return createStar2(props);\n        }\n        case 3: {\n            return createStar3(props);\n        }\n    }\n\n    return createStar1(props);\n};\n\nexport const createStar1 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n    d += dots.map(dot => `L ${ dot[0] } ${ dot[1] }`).join(' ');\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar2 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar3 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] } L ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\nimport { mod } from 'mz-math';\n\nexport interface ICreateFlowerProps extends IPrimitiveShapeProps{\n    petalsNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n}\n\nexport const createFlower = (props: ICreateFlowerProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_PETALS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const petalsNumber = Math.max(MIN_PETALS_NUMBER, Number(props.petalsNumber) || MIN_PETALS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / petalsNumber;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<petalsNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i= 0; i < dots.length; i += 2){\n        const outerDot = dots[mod(i + 1, dots.length)];\n        const innerDot2 = dots[mod(i + 2, dots.length)];\n        const outerDot2 = dots[mod(i + 3, dots.length)];\n\n        d += `C ${ outerDot[0] } ${ outerDot[1] } ${ outerDot2[0] } ${ outerDot2[1] } ${ innerDot2[0] } ${ innerDot2[1] } `;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport const getRectPathD = (props: {\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    rx?: number,\n    ry?: number,\n}) => {\n    const {\n        x, y,\n        width, height,\n        rx: _rx,\n        ry: _ry,\n    } = props;\n\n    const rx = _rx || 0;\n    const ry = _ry || 0;\n\n    if (rx || ry){\n\n        const w = width - 2 * rx;\n        const h = height - 2 * ry;\n\n        return `M${ x + rx } ${ y }h${ w }s${ rx } 0 ${ rx } ${ ry }v${ h }s0 ${ ry } ${ -rx } ${ ry }h${ -w }s${ -rx } 0 ${ -rx } ${ -ry }v${ -h }s0 ${ -ry } ${ rx } ${ -ry }z`;\n    }\n\n    return `M${ x } ${ y }h${ width }v${ height }h${ -width }z`;\n};\n\nexport interface ICreateRectPathProps extends IPrimitiveShapeProps{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rx?: number;\n    ry?: number;\n}\n\nexport const createRectPath = (props: ICreateRectPathProps) : SVGPathElement => {\n\n    const pathProps = {\n        ...props,\n        d: getRectPathD({\n            x: props.x,\n            y: props.y,\n            width: props.width,\n            height: props.height,\n            rx: props.rx,\n            ry: props.ry,\n        }),\n    };\n\n    return createPath(pathProps);\n};", "import { createSVGFromString, getSVGAsString } from './core';\n\nconst MISSING_SVG_ERR = 'Either an SVG element or an SVG string must be provided.';\n\nconst formatExt = (ext?: string) : string => {\n    if(!ext || !ext.trim()) return 'svg';\n\n    return ext.trim().toLowerCase();\n};\n\n/**\n * Download file in browser environment.\n */\nexport const download = (props: {\n    $svg?: SVGSVGElement,\n    svgString?: string;\n    outfileName?: string;\n    ext?: string; // svg, png, jpg, jpeg\n}) => {\n    return new Promise<{\n        isError: boolean;\n        msg?: string;\n    }>((resolve, reject) => {\n        if(!props.$svg && !props.svgString){\n            reject({\n                isError: true,\n                msg: MISSING_SVG_ERR,\n            });\n            return;\n        }\n\n        const _svgString = props.$svg ? getSVGAsString(props.$svg) : props.svgString;\n        const svgString = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${ _svgString }`;\n\n        const formattedExt = formatExt(props.ext);\n        const formattedFileName = `${ props.outfileName || 'out'}.${ formattedExt }`;\n\n        if(formattedExt === 'svg'){\n\n            const blob = new Blob([svgString], {type : 'text/plain'});\n            const url = URL.createObjectURL(blob);\n\n            const link = document.createElement('a');\n            link.href = url;\n            link.title = '';\n            link.download = formattedFileName;\n            link.click();\n\n            URL.revokeObjectURL(url);\n            resolve({\n                isError: false,\n            });\n        }\n        else{\n            const $svg = props.$svg || createSVGFromString({\n                svg: props.svgString || '',\n            });\n\n            const $canvas = document.createElement('canvas');\n            $canvas.width = $svg.width.baseVal.value;\n            $canvas.height = $svg.height.baseVal.value;\n\n            const ctx = $canvas.getContext('2d');\n            if(!ctx){\n                reject({\n                    isError: true,\n                });\n                return;\n            }\n\n            const data = (new XMLSerializer()).serializeToString($svg);\n            const blob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\n            const url = URL.createObjectURL(blob);\n\n            const $img = new Image();\n            $img.onload = () => {\n                ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                ctx.drawImage($img, 0, 0);\n\n                URL.revokeObjectURL(url);\n\n                $canvas.toBlob(cBlob => {\n\n                    if(!cBlob){\n                        resolve({\n                            isError: true,\n                        });\n                        return;\n                    }\n\n                    const cUrl = URL.createObjectURL(cBlob);\n                    const link = document.createElement('a');\n                    link.href = cUrl;\n                    link.title = '';\n                    link.download = formattedFileName;\n                    link.click();\n\n                    URL.revokeObjectURL(cUrl);\n\n                    resolve({\n                        isError: false,\n                    });\n                });\n            };\n\n            $img.onerror = () => {\n                resolve({\n                    isError: true,\n                });\n            };\n\n            $img.src = url;\n        }\n    });\n};", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from './core';\nimport { IPrimitiveShapeProps } from '../interfaces';\n\nexport const createGroup = (props?: IPrimitiveShapeProps) : SVGGElement => {\n    const doc = props?.document || window.document;\n    const $g = doc.createElementNS(SVG_NAMESPACE, 'g');\n\n    setAttributes($g, [\n        ...getCommonAttributes(props),\n    ]);\n\n    return $g;\n};\n\nexport const createDefs = (props?: {\n    document?: Document;\n    id?: string;\n    classes?: string;\n}) : SVGDefsElement => {\n    const doc = props?.document || window.document;\n    const $defs = doc.createElementNS(SVG_NAMESPACE, 'defs');\n\n    setAttributes($defs, [\n        ['id', props?.id],\n        ['class', props?.classes],\n    ]);\n\n    return $defs;\n};\n\nexport interface ICreateUseProps extends IPrimitiveShapeProps{\n    href?: string;\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n}\n\nexport const createUse = (props?: ICreateUseProps) : SVGUseElement => {\n\n    const doc = props?.document || window.document;\n    const $use = doc.createElementNS(SVG_NAMESPACE, 'use');\n\n    setAttributes($use, [\n        ['href', props?.href],\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $use;\n};\n\nexport interface ICreatePatternProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n\n    href?: string;\n    patternContentUnits?: string|number;\n    patternTransform?: string;\n    patternUnits?: string;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n}\n\nexport const createPattern = (props?: ICreatePatternProps) : SVGPatternElement => {\n    const doc = props?.document || window.document;\n    const $pattern = doc.createElementNS(SVG_NAMESPACE, 'pattern');\n\n    setAttributes($pattern, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['href', props?.href],\n        ['patternContentUnits', props?.patternContentUnits],\n        ['patternTransform', props?.patternTransform],\n        ['patternUnits', props?.patternUnits],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $pattern;\n};\n\nexport interface ICreateClipPathProps extends IPrimitiveShapeProps{\n    clipPathUnits?: string;\n}\n\nexport const createClipPath = (props?: ICreateClipPathProps) : SVGClipPathElement => {\n\n    const doc = props?.document || window.document;\n    const $clipPath = doc.createElementNS(SVG_NAMESPACE, 'clipPath');\n\n    setAttributes($clipPath, [\n        ['clipPathUnits', props?.clipPathUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $clipPath;\n};\n\nexport interface ICreateMaskProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    maskContentUnits?: string;\n    maskUnits?: string;\n}\n\nexport const createMask = (props?: ICreateMaskProps) : SVGMaskElement => {\n\n    const doc = props?.document || window.document;\n    const $mask = doc.createElementNS(SVG_NAMESPACE, 'mask');\n\n    setAttributes($mask, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['maskContentUnits', props?.maskContentUnits],\n        ['maskUnits', props?.maskUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $mask;\n};\n\nexport interface ICreateSymbolProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    preserveAspectRatio?: string;\n    refX?: number|string;\n    refY?: number|string;\n    viewBox?: string;\n}\n\nexport const createSymbol = (props?: ICreateSymbolProps) : SVGSymbolElement => {\n\n    const doc = props?.document || window.document;\n    const $symbol = doc.createElementNS(SVG_NAMESPACE, 'symbol');\n\n    setAttributes($symbol, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['refX', props?.refX],\n        ['refY', props?.refY],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $symbol;\n};", "export const appendOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.append($el);\n};\n\nexport const prependOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.prepend($el);\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute } from './convert';\nimport { EPathDataCommand } from './interfaces';\nimport {\n    degreesToRadians,\n    Matrix2, mMulVector,\n    setDecimalPlaces,\n    v2CubicBezierBBox, v2MulScalar,\n    v2QuadraticBezierBBox, v2Sum,\n    Vector2\n} from 'mz-math';\n\nexport interface IBBox {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    x2: number;\n    y2: number;\n}\n\n/**\n * https://www.w3.org/TR/SVG11/implnote.html#ArcConversionEndpointToCenter\n */\nexport const getSVGArcCenter = (\n    startX: number,\n    startY: number,\n    rx: number,\n    ry: number,\n    angleRad: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    endX: number,\n    endY: number\n) : Vector2 | null => {\n    // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\n    // F.6.5: Step 1 ---------------------------------------\n    const cos = Math.cos(angleRad);\n    const sin = Math.sin(angleRad);\n\n    const rotationMatrix: Matrix2 = [\n        [cos, -sin],\n        [sin, cos],\n    ];\n    const posVector1: Vector2 = [\n        (startX - endX) / 2,\n        (startY - endY) / 2,\n    ];\n\n    // Compute (x1\u2032, y1\u2032)\n    const posVector2 = mMulVector(rotationMatrix, posVector1);\n\n    // F.6.5: Step 2 ---------------------------------------\n    const rx2 = rx ** 2;\n    const ry2 = ry ** 2;\n    const posx2 = posVector2[0] ** 2;\n    const posy2 = posVector2[1] ** 2;\n\n    const t1 = rx2 * ry2 - rx2 * posy2 - ry2 * posx2;\n    const t2 = rx2 * posy2 + ry2 * posx2;\n    if(t2 === 0) return null;\n\n    const t3 = t1 / t2;\n    if(t3 < 0) return null;\n\n    let t4 = Math.sqrt(t3);\n\n    const posVector3: Vector2 = [\n        rx * posVector2[1] / ry,\n        -ry *  posVector2[0] / rx,\n    ];\n\n    if(largeArcFlag === sweepFlag){\n        t4 = -t4;\n    }\n\n    const centerVector1: Vector2 = v2MulScalar(posVector3, t4);\n\n    // F.6.5: Step 3 ---------------------------------------\n    const rotationMatrix2: Matrix2 = [\n        [cos, sin],\n        [-sin, cos],\n    ];\n\n    const centerVector2: Vector2 = mMulVector(rotationMatrix2, centerVector1) as Vector2;\n    const posVector4: Vector2 = [\n        (startX + endX) / 2,\n        (startY + endY) / 2,\n    ];\n\n    return v2Sum(centerVector2, posVector4);\n\n\n    /*if (rx < 0) {\n        rx *= -1;\n    }\n\n    if (ry < 0) {\n        ry *= -1;\n    }\n\n    if (rx === 0 || ry === 0) {\n        xmin = x1 < x2 ? x1 : x2;\n        xmax = x1 > x2 ? x1 : x2;\n        ymin = y1 < y2 ? y1 : y2;\n        ymax = y1 > y2 ? y1 : y2;\n\n        return formatBBox(xmin, xmax, ymin, ymax);\n    }\n\n    const x1prime: number = Math.cos(phi) * (x1 - x2) / 2 + Math.sin(phi) * (y1 - y2) / 2;\n    const y1prime: number = -Math.sin(phi) * (x1 - x2) / 2 + Math.cos(phi) * (y1 - y2) / 2;\n\n    let radicant: number = (rx * rx * ry * ry - rx * rx * y1prime * y1prime - ry * ry * x1prime * x1prime);\n    radicant /= (rx * rx * y1prime * y1prime + ry * ry * x1prime * x1prime);\n\n    let cxPrime = 0;\n    let cyPrime = 0;\n\n    if (radicant < 0) {\n        const ratio: number = rx / ry;\n        radicant = y1prime * y1prime + x1prime * x1prime / (ratio * ratio);\n        if (radicant < 0) {\n            xmin = (x1 < x2 ? x1 : x2);\n            xmax = (x1 > x2 ? x1 : x2);\n            ymin = (y1 < y2 ? y1 : y2);\n            ymax = (y1 > y2 ? y1 : y2);\n\n            return formatBBox(xmin, xmax, ymin, ymax);\n        }\n        ry = Math.sqrt(radicant);\n        rx = ratio * ry;\n    }\n    else {\n        const factor = (largeArc == sweep ? -1 : 1) * Math.sqrt(radicant);\n        cxPrime = factor * rx * y1prime / ry;\n        cyPrime = -factor * ry * x1prime / rx;\n    }\n\n    const cx = cxPrime * Math.cos(phi) - cyPrime * Math.sin(phi) + (x1 + x2) / 2;\n    const cy = cxPrime * Math.sin(phi) + cyPrime * Math.cos(phi) + (y1 + y2) / 2;*/\n};\n\nconst getAngle = (bx: number, by: number): number => {\n    const PI2 = 2 * Math.PI;\n    const t1 = by > 0 ? 1 : -1;\n    return ((PI2 + t1 * Math.acos(bx / Math.sqrt(bx * bx + by * by))) % PI2);\n};\n\nconst formatBBox = (xmin: number, xmax: number, ymin: number, ymax: number) : IBBox => {\n    return {\n        x: xmin,\n        y: ymin,\n        w: Math.abs(ymax - ymin),\n        h: Math.abs(xmax - xmin),\n        x2: xmax,\n        y2: ymax,\n    };\n};\n\nconst getArcBoundingBox = (\n    x1: number, y1: number,\n    rx: number, ry: number,\n    angleRad: number, largeArc: boolean,\n    sweep: boolean,\n    x2: number, y2: number\n) : IBBox => {\n\n    let xmin, xmax, ymin, ymax;\n\n    const center = getSVGArcCenter(\n        x1,\n        y1,\n        rx,\n        ry,\n        angleRad,\nlargeArc ? 1 : 0,\nsweep ? 1 : 0,\n        x2,\n        y2\n    );\n    if(!center) return formatBBox(0, 0, 0, 0);\n\n    const cx = center[0];\n    const cy = center[1];\n\n    let txMin: number, txMax: number, tyMin: number, tyMax: number;\n\n    if (angleRad === 0 || angleRad === Math.PI) {\n        xmin = cx - rx;\n        txMin = getAngle(-rx, 0);\n        xmax = cx + rx;\n        txMax = getAngle(rx, 0);\n        ymin = cy - ry;\n        tyMin = getAngle(0, -ry);\n        ymax = cy + ry;\n        tyMax = getAngle(0, ry);\n    }\n    else if (angleRad === Math.PI / 2 || angleRad === 3.0 * Math.PI / 2) {\n        xmin = cx - ry;\n        txMin = getAngle(-ry, 0);\n        xmax = cx + ry;\n        txMax = getAngle(ry, 0);\n        ymin = cy - rx;\n        tyMin = getAngle(0, -rx);\n        ymax = cy + rx;\n        tyMax = getAngle(0, rx);\n    }\n    else {\n        txMin = -Math.atan(ry * Math.tan(angleRad) / rx);\n        txMax = Math.PI - Math.atan(ry * Math.tan(angleRad) / rx);\n\n        xmin = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMin) * Math.sin(angleRad);\n        xmax = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMax) * Math.sin(angleRad);\n\n        // swap ------------------------\n        if (xmin > xmax) {\n            [xmin, xmax] = [xmax, xmin];\n            [txMin, txMax] = [txMax, txMin];\n        }\n\n        let tmpY = cy + rx * Math.cos(txMin) * Math.sin(angleRad) + ry * Math.sin(txMin) * Math.cos(angleRad);\n        txMin = getAngle(xmin - cx, tmpY - cy);\n        tmpY = cy + rx * Math.cos(txMax) * Math.sin(angleRad) + ry * Math.sin(txMax) * Math.cos(angleRad);\n        txMax = getAngle(xmax - cx, tmpY - cy);\n\n        tyMin = Math.atan(ry / (Math.tan(angleRad) * rx));\n        tyMax = Math.atan(ry / (Math.tan(angleRad) * rx)) + Math.PI;\n        ymin = cy + rx * Math.cos(tyMin) * Math.sin(angleRad) + ry * Math.sin(tyMin) * Math.cos(angleRad);\n        ymax = cy + rx * Math.cos(tyMax) * Math.sin(angleRad) + ry * Math.sin(tyMax) * Math.cos(angleRad);\n\n        // swap ------------------------\n        if (ymin > ymax) {\n            [ymin, ymax] = [ymax, ymin];\n            [tyMin, tyMax] = [tyMax, tyMin];\n        }\n\n        let tmpX = cx + rx * Math.cos(tyMin) * Math.cos(angleRad) - ry * Math.sin(tyMin) * Math.sin(angleRad);\n        tyMin = getAngle(tmpX - cx, ymin - cy);\n        tmpX = cx + rx * Math.cos(tyMax) * Math.cos(angleRad) - ry * Math.sin(tyMax) * Math.sin(angleRad);\n        tyMax = getAngle(tmpX - cx, ymax - cy);\n    }\n\n    let angle1 = getAngle(x1 - cx, y1 - cy);\n    let angle2 = getAngle(x2 - cx, y2 - cy);\n\n    if (!sweep){\n        [angle1, angle2] = [angle2, angle1];\n    }\n\n    let otherArc = false;\n\n    if (angle1 > angle2) {\n        // swap ------------------------\n        [angle1, angle2] = [angle2, angle1];\n        otherArc = true;\n    }\n\n    if ((!otherArc && (angle1 > txMin || angle2 < txMin)) || (otherArc && !(angle1 > txMin || angle2 < txMin))) {\n        xmin = Math.min(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > txMax || angle2 < txMax)) || (otherArc && !(angle1 > txMax || angle2 < txMax))) {\n        xmax = Math.max(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > tyMin || angle2 < tyMin)) || (otherArc && !(angle1 > tyMin || angle2 < tyMin))) {\n        ymin = Math.min(y1, y2);\n    }\n\n    if ((!otherArc && (angle1 > tyMax || angle2 < tyMax)) || (otherArc && !(angle1 > tyMax || angle2 < tyMax))) {\n        ymax = Math.max(y1, y2);\n    }\n\n    return formatBBox(xmin, xmax, ymin, ymax);\n}\n\n/**\n * Determine the coordinates of the smallest rectangle in which the path fits.\n */\nexport const getPathBBox = (d?: string, decimalPlaces = 2) : IBBox|null => {\n    if(!d || d.trim() === '') return null;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return null;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return null;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const max = maximizeAbsolutePath(abs);\n\n    // current (x, y) pair\n    let x = max.commands[0].params[0];\n    let y = max.commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    for(const item of max.commands) {\n\n        switch (item.command){\n            case EPathDataCommand.MoveToAbs: {\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                mx = item.params[0];\n                my = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:{\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                x = item.params[0];\n                y = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint1: Vector2 = [item.params[0], item.params[1]];\n                const centerControlPoint2: Vector2 = [item.params[2], item.params[3]];\n                const endControlPoint: Vector2 = [item.params[4], item.params[5]];\n                const bbox = v2CubicBezierBBox(startControlPoint, centerControlPoint1, centerControlPoint2, endControlPoint);\n\n                minX = bbox.x;\n                minY = bbox.y;\n\n                maxX = bbox.x2;\n                maxY = bbox.y2;\n\n                x = item.params[4];\n                y = item.params[5];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint: Vector2 = [item.params[0], item.params[1]];\n                const endControlPoint: Vector2 = [item.params[2], item.params[3]];\n                const bbox = v2QuadraticBezierBBox(startControlPoint, centerControlPoint, endControlPoint);\n\n                minX = bbox.x;\n                minY = bbox.y;\n\n                maxX = bbox.x2;\n                maxY = bbox.y2;\n\n                x = item.params[2];\n                y = item.params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                const rx = item.params[0];\n                const ry = item.params[1];\n                const angleDeg = item.params[2];\n                const largeArcFlag = item.params[3];\n                const sweepFlag = item.params[4];\n                const endX = item.params[5];\n                const endY = item.params[6];\n\n                //const arcCenter = getSVGArcCenter(x, y, rx, ry, angleDeg, largeArcFlag, sweepFlag, endX, endY);\n                //console.log('arcCenter', arcCenter)\n\n                const bbox = getArcBoundingBox(x, y, rx, ry, degreesToRadians(angleDeg), largeArcFlag === 1, sweepFlag === 1, endX, endY);\n\n                minX = bbox?.x ?? 0;\n                minY = bbox?.y ?? 0;\n\n                maxX = bbox?.x2 ?? 0;\n                maxY = bbox?.y2 ?? 0;\n\n                x = item.params[5];\n                y = item.params[6];\n                break;\n            }\n        }\n    }\n\n    return {\n        x: setDecimalPlaces(minX, decimalPlaces),\n        y: setDecimalPlaces(minY, decimalPlaces),\n        w: setDecimalPlaces(Math.abs(maxX - minX), decimalPlaces),\n        h: setDecimalPlaces(Math.abs(maxY - minY), decimalPlaces),\n        x2: setDecimalPlaces(maxX, decimalPlaces),\n        y2: setDecimalPlaces(maxY, decimalPlaces),\n    };\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { Vector3, m2RotateAroundPointH, degreesToRadians } from 'mz-math';\nimport { EPathDataCommand } from './interfaces';\nimport { getPathBBox } from './bbox';\n\nexport const translatePath = (d: string, x: number, y: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const relative = pathDataToRelative(parsed);\n    if(!relative || relative.commands.length <= 0) return d;\n\n    const mCommand = relative.commands[0];\n    mCommand.params[0] = x;\n    mCommand.params[1] = y;\n\n    return pathDataToString(relative, true, decimalPlaces);\n};\n\nconst rotateDot = (x: number, y: number, cx: number, cy: number, angleRad: number, decimalPlaces = 2) => {\n    return m2RotateAroundPointH(\n        angleRad,\n        [cx, cy, 1],\n        [x, y, 1],\n        true,\n        decimalPlaces\n    );\n};\n\nexport const rotatePathAroundDot = (d: string, cx: number, cy: number, angleDegrees: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return d;\n\n    const angleRad = degreesToRadians(angleDegrees, decimalPlaces);\n\n    const max = maximizeAbsolutePath(abs);\n    for(const item of max.commands){\n\n        switch(item.command){\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                // 2 params (x, y)\n\n                // get the new position after rotation\n                const pos: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos[0];\n                item.params[1] = pos[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                // 6 parameters\n                const pos1: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot(item.params[2], item.params[3], cx, cy, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n\n                const pos3: Vector3 = rotateDot(item.params[4], item.params[5], cx, cy, angleRad, decimalPlaces);\n                item.params[4] = pos3[0];\n                item.params[5] = pos3[1];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                // 4 parameters\n                const pos1: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot(item.params[2], item.params[3], cx, cy, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                const pos1: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot(item.params[5], item.params[6], cx, cy, angleRad, decimalPlaces);\n                item.params[5] = pos2[0];\n                item.params[6] = pos2[1];\n                break;\n            }\n        }\n    }\n\n    const rel = pathDataToRelative(abs);\n    return pathDataToString(rel, true, decimalPlaces);\n};\n\nexport const rotatePath = (d: string, angleDegrees: number, decimalPlaces = 2) => {\n\n    const bbox = getPathBBox(d);\n\n    const x = bbox?.x ?? 0;\n    const y = bbox?.y ?? 0;\n    const w = bbox?.w ?? 0;\n    const h = bbox?.h ?? 0;\n\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n\n    return rotatePathAroundDot(d, cx, cy, angleDegrees, decimalPlaces);\n};\n"],
  "mappings": "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",
  "names": ["SVG_NAMESPACE", "XMLNS_NAMESPACE", "DEFAULT_DECIMAL_PLACES", "createSVG", "props", "$svg", "viewBox", "setAttributes", "getCommonAttributes", "createSVGFromString", "_document", "svg", "$box", "getSVGAsString", "$svgElement", "attr", "pair", "prop", "value", "createPath", "props", "$path", "SVG_NAMESPACE", "setAttributes", "getCommonAttributes", "createRect", "$rect", "createCircle", "$circle", "createEllipse", "$ellipse", "createLine", "$line", "createPolygon", "$polygon", "createPolyline", "$polyline", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "degreesToRadians", "degrees", "decimalPlaces", "res", "setDecimalPlaces", "vSum", "vector1", "vector2", "decimalPlaces", "vector", "i", "setDecimalPlaces", "v2Sum", "vMulScalar", "v", "scalar", "decimalPlaces", "vector", "i", "setDecimalPlaces", "v2MulScalar", "v2", "v3MulScalar", "v3", "vDotProduct", "vector1", "vector2", "decimalPlaces", "sum", "i", "setDecimalPlaces", "mTranspose", "m", "vectorsCount", "vectorLength", "matrix", "i", "j", "mMul", "matrix1", "matrix2", "decimalPlaces", "matrix", "i", "transposed", "mTranspose", "vector1", "j", "vector2", "product", "vDotProduct", "mMulVector", "vector", "res", "m2TranslationH", "position", "decimalPlaces", "setDecimalPlaces", "m2RotationH", "angleRad", "isClockwise", "decimalPlaces", "cos", "setDecimalPlaces", "sin", "m2RotationAroundPointH", "transformOrigin", "translation", "m2TranslationH", "rotation", "translationBack", "v3MulScalar", "temp1", "mMul", "m2RotateAroundPointH", "position", "mat3h", "mMulVector", "mod", "n", "m", "isNumber", "value", "linearEquation", "equation", "decimalPlaces", "a", "b", "diff", "setDecimalPlaces", "quadraticEquation", "equation", "decimalPlaces", "a", "b", "c", "d", "res", "linearEquation", "isNumber", "diff", "discriminant", "setDecimalPlaces", "t1", "t2", "v2QuadraticBezierCurve", "t", "startControlPoint", "centerControlPoint", "endControlPoint", "temp1", "temp2", "temp3", "v2CubicBezierCurve", "t", "startControlPoint", "center1ControlPoint", "center2ControlPoint", "endControlPoint", "decimalPlaces", "temp1", "temp2", "temp3", "temp4", "setDecimalPlaces", "v2QuadraticBezierCurveExtrema", "startControlPoint", "centerControlPoint", "endControlPoint", "decimalPlaces", "a1", "b1", "equation1", "a2", "b2", "equation2", "linearEquation", "v2CubicBezierCurveExtrema", "center1ControlPoint", "center2ControlPoint", "c1", "c2", "res1", "quadraticEquation", "num", "res2", "v2QuadraticBezierBBox", "extrema", "minX", "minY", "maxX", "maxY", "percent", "point", "v2QuadraticBezierCurve", "x", "y", "setDecimalPlaces", "v2CubicBezierBBox", "v2CubicBezierCurve", "NUMBER_REGEX", "scan", "pathData", "result", "current", "line", "col", "isEnd", "addKeywordToken", "tokenType", "addNumberToken", "num", "addError", "msg", "matchNumber", "scanToken", "char", "matchRes", "parse", "scanResult", "pathData", "tokens", "errors", "error", "token", "msg", "current", "isEnd", "areArcFlagsValid", "tokenType", "_a", "_b", "val4", "val5", "parseCommand", "paramsCount", "nextParamsTokenType", "isRelative", "params", "i", "nextTokens", "nextCommand", "nextParams", "j", "parseNext", "numberToString", "num", "decimalPlaces", "_num", "i", "parts", "intPart", "decimalPart", "combineParams", "params", "combined", "param", "str", "pathDataMinify", "pathData", "d", "lastCommand", "item", "pathDataToRelative", "pathData", "commands", "x", "y", "mx", "my", "i", "savedX", "savedY", "pathDataToAbsolute", "pathDataToString", "minify", "decimalPlaces", "d", "pathDataMinify", "item", "param", "maximizeAbsolutePath", "prev", "isPathValid", "d", "parsePath", "scanResult", "scan", "parse", "pathToRel", "beautify", "decimalPlaces", "parsed", "pathDataToString", "pathDataToRelative", "pathToAbs", "pathDataToAbsolute", "minifyPath", "pathDataMinify", "beautifyPath", "createStar", "props", "createStar2", "createStar3", "createStar1", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_RAYS_NUMBER", "dots", "raysNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "halfAngle", "i", "angle", "d", "dot", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "dot1", "dot2", "createFlower", "props", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_PETALS_NUMBER", "dots", "petalsNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "i", "angle", "d", "outerDot", "X", "innerDot2", "outerDot2", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "getRectPathD", "props", "x", "y", "width", "height", "_rx", "_ry", "rx", "ry", "w", "h", "createRectPath", "pathProps", "__spreadProps", "__spreadValues", "createPath", "MISSING_SVG_ERR", "formatExt", "ext", "download", "props", "resolve", "reject", "svgString", "getSVGAsString", "formattedExt", "formattedFileName", "blob", "url", "link", "$svg", "createSVGFromString", "$canvas", "ctx", "data", "$img", "cBlob", "cUrl", "createGroup", "props", "$g", "SVG_NAMESPACE", "setAttributes", "getCommonAttributes", "createDefs", "$defs", "createUse", "$use", "createPattern", "$pattern", "createClipPath", "$clipPath", "createMask", "$mask", "createSymbol", "$symbol", "appendOnce", "$parent", "$el", "tagName", "prependOnce", "getSVGArcCenter", "startX", "startY", "rx", "ry", "angleRad", "largeArcFlag", "sweepFlag", "endX", "endY", "cos", "sin", "rotationMatrix", "posVector1", "posVector2", "V", "rx2", "__pow", "ry2", "posx2", "posy2", "t1", "t2", "t3", "t4", "posVector3", "centerVector1", "or", "rotationMatrix2", "centerVector2", "posVector4", "rr", "getAngle", "bx", "by", "PI2", "formatBBox", "xmin", "xmax", "ymin", "ymax", "getArcBoundingBox", "x1", "y1", "largeArc", "sweep", "x2", "y2", "center", "cx", "cy", "txMin", "txMax", "tyMin", "tyMax", "tmpY", "tmpX", "angle1", "angle2", "otherArc", "getPathBBox", "d", "decimalPlaces", "_a", "_b", "_c", "_d", "parsed", "parsePath", "abs", "pathDataToAbsolute", "minX", "minY", "maxX", "maxY", "max", "maximizeAbsolutePath", "x", "y", "mx", "my", "item", "startControlPoint", "centerControlPoint1", "centerControlPoint2", "endControlPoint", "bbox", "Zn", "centerControlPoint", "Gn", "angleDeg", "Jt", "i", "translatePath", "d", "x", "y", "decimalPlaces", "parsed", "parsePath", "relative", "pathDataToRelative", "mCommand", "pathDataToString", "rotateDot", "cx", "cy", "angleRad", "fe", "rotatePathAroundDot", "angleDegrees", "abs", "pathDataToAbsolute", "Jt", "max", "maximizeAbsolutePath", "item", "pos", "pos1", "pos2", "pos3", "rel", "rotatePath", "_a", "_b", "_c", "_d", "bbox", "getPathBBox", "w", "h"]
}
