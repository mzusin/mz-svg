{
  "version": 3,
  "sources": ["../src/main/core.ts", "../src/main/shapes/primitive-shapes.ts", "../node_modules/mz-math/src/format.ts", "../node_modules/mz-math/src/angle.ts", "../node_modules/mz-math/src/vector.ts", "../node_modules/mz-math/src/matrix.ts", "../node_modules/mz-math/src/random.ts", "../node_modules/mz-math/src/other.ts", "../node_modules/mz-math/src/convert.ts", "../node_modules/mz-math/src/bezier-curve.ts", "../node_modules/mz-math/src/equations.ts", "../node_modules/mz-math/src/path-movement.ts", "../node_modules/mz-math/src/color.ts", "../node_modules/mz-math/src/id.ts", "../node_modules/mz-math/src/shapes.ts", "../src/main/shapes/star-shapes.ts", "../src/main/shapes/shape-paths.ts", "../src/main/io-browser.ts", "../src/main/containers.ts", "../src/main/helpers.ts"],
  "sourcesContent": ["/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props: {\n    width: number;\n    height: number;\n    document?: Document;\n}) : SVGSVGElement => {\n\n    const {\n        width: _width,\n        height: _height,\n        document: _document,\n    } = props;\n\n    const doc = _document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    const width = Math.max(0, Number(_width) || 0);\n    const height = Math.max(0, Number(_height) || 0);\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n    $svg.setAttribute('width', width.toString());\n    $svg.setAttribute('height', height.toString());\n    $svg.setAttribute('viewBox', `0 0 ${ width } ${ height }`);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};", "import { setAttributes, SVG_NAMESPACE } from '../core';\n\nconst getCommonAttributes = (props: {\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : [string, string|number|undefined][] => {\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['pathLength', props.pathLength],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n\n/**\n * Create SVG path.\n */\nexport const createPath = (props: {\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    d?: string;\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n\n}) : SVGPathElement => {\n\n    const {\n        document: _document,\n        d: _d,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(_d){\n        // remove newlines and double spaces\n        const d = _d.replace(/\\s\\s+/g, ' ');\n\n        $path.setAttribute('d', d);\n    }\n\n    setAttributes($path, [\n        ['d', _d],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\n/**\n * Create SVG rectangle.\n */\nexport const createRect = (props: {\n    document?: Document;\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n\n    // -------------------------\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGRectElement => {\n    const {\n        document: _document\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props.x],\n        ['y', props.y],\n        ['rx', props.rx],\n        ['ry', props.ry],\n        ['width', props.width],\n        ['height', props.height],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\n/**\n * Create SVG circle.\n */\nexport const createCircle = (props: {\n    document?: Document;\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n\n    // -------------------------\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGCircleElement => {\n    const {\n        document: _document,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props.cx],\n        ['cy', props.cy],\n        ['r', props.r],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\n/**\n * Create SVG ellipse.\n */\nexport const createEllipse = (props: {\n    document?: Document;\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n\n    // -------------------------\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGEllipseElement => {\n    const {\n        document: _document,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props.cx],\n        ['cy', props.cy],\n        ['rx', props.rx],\n        ['ry', props.ry],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\n/**\n * Create SVG line.\n */\nexport const createLine = (props: {\n    document?: Document;\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n\n    // -------------------------\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGLineElement => {\n    const {\n        document: _document,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props.x1],\n        ['x2', props.x2],\n        ['y1', props.y1],\n        ['y2', props.y2],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\n/**\n * Create SVG polygon.\n */\nexport const createPolygon = (props: {\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    points?: string;\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n\n}) : SVGPolygonElement => {\n\n    const {\n        document: _document\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n        ['points', props.points],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from './types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from './types';\nimport { setDecimalPlaces } from './format';\nimport { getV2Angle, setV2Angle } from './angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from './types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { Vector2, Vector3 } from './types';\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0],\n        temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1],\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0],\n        temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1],\n        temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2],\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0],\n        temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1],\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0],\n        temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1],\n        temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2],\n    ];\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from './types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from './matrix';\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const equationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const equationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const equationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector2 } from './types';\nimport { v2Sub } from './vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from './types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\n\nexport const createStar = (props: {\n    document?: Document;\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n\n    decimalPlaces?: number;\n\n    // --------------------\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    d?: string;\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAY_NUMBERS = 4;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAY_NUMBERS, Number(props.raysNumber) || MIN_RAY_NUMBERS);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${dots[0][0]} ${dots[0][1]} `;\n    d += dots.map(dot => `L ${dot[0]} ${dot[1]}`).join(' ');\n    d += ' Z';\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\n\nexport const getRectPathD = (props: {\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    rx?: number,\n    ry?: number,\n}) => {\n    const {\n        x, y,\n        width, height,\n        rx: _rx,\n        ry: _ry,\n    } = props;\n\n    const rx = _rx || 0;\n    const ry = _ry || 0;\n\n    if (rx || ry){\n\n        const top1 = `${ x } ${ y }`;\n        const top2 = `${ x + rx } ${ y }`;\n        const top3 = `${ x + width - rx } ${ y }`;\n        const top4 = `${ x + width } ${ y }`;\n\n        const right1 = `${ x + width } ${ y + ry }`;\n        const right2 = `${ x + width } ${ y + height - ry }`;\n\n        const bottom1 = `${ x + width } ${ y + height }`;\n        const bottom2 = `${ x + width - rx } ${ y + height }`;\n        const bottom3 = `${ x + rx } ${ y + height }`;\n        const bottom4 = `${ x } ${ y + height }`;\n\n        const left1 = `${ x } ${ y + height - ry }`;\n        const left2 = `${ x } ${ y + ry }`;\n\n        return `\n            M${ top2 } \n            L${ top3 }\n            C${ top3 } ${ top4 } ${ right1 } \n            L${ right2 } \n            C${ right2 } ${ bottom1 } ${ bottom2 } \n            L${ bottom3 } \n            C${ bottom3 } ${ bottom4 } ${ left1 } \n            L${ left2 } \n            C${ left2 } ${ top1 } ${ top2 } Z`.replace(/\\s\\s+/g, ' ').trim();\n    }\n\n    return `M${ x + width } ${ y } L${ x + width } ${ height + y } L${ x } ${ height + y } L${ x } ${ y } L${ x + width } ${ y } Z`;\n};\n\nexport const createRectPath = (props: {\n    document?: Document;\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rx?: number;\n    ry?: number;\n\n    // -------------------------\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    pathLength?: string|number;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : SVGPathElement => {\n\n    const pathProps = {\n        ...props,\n        d: getRectPathD({\n            x: props.x,\n            y: props.y,\n            width: props.width,\n            height: props.height,\n            rx: props.rx,\n            ry: props.ry,\n        }),\n    };\n\n    return createPath(pathProps);\n};", "import { createSVGFromString, getSVGAsString } from './core';\n\nconst MISSING_SVG_ERR = 'Either an SVG element or an SVG string must be provided.';\n\nconst formatExt = (ext?: string) : string => {\n    if(!ext || !ext.trim()) return 'svg';\n\n    return ext.trim().toLowerCase();\n};\n\n/**\n * Download file in browser environment.\n */\nexport const download = (props: {\n    $svg?: SVGSVGElement,\n    svgString?: string;\n    outfileName?: string;\n    ext?: string; // svg, png, jpg, jpeg\n}) => {\n    return new Promise<{\n        isError: boolean;\n        msg?: string;\n    }>((resolve, reject) => {\n        if(!props.$svg && !props.svgString){\n            reject({\n                isError: true,\n                msg: MISSING_SVG_ERR,\n            });\n            return;\n        }\n\n        const _svgString = props.$svg ? getSVGAsString(props.$svg) : props.svgString;\n        const svgString = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${ _svgString }`;\n\n        const formattedExt = formatExt(props.ext);\n        const formattedFileName = `${ props.outfileName || 'out'}.${ formattedExt }`;\n\n        if(formattedExt === 'svg'){\n\n            const blob = new Blob([svgString], {type : 'text/plain'});\n            const url = URL.createObjectURL(blob);\n\n            const link = document.createElement('a');\n            link.href = url;\n            link.title = '';\n            link.download = formattedFileName;\n            link.click();\n\n            URL.revokeObjectURL(url);\n            resolve({\n                isError: false,\n            });\n        }\n        else{\n            const $svg = props.$svg || createSVGFromString({\n                svg: props.svgString || '',\n            });\n\n            const $canvas = document.createElement('canvas');\n            $canvas.width = $svg.width.baseVal.value;\n            $canvas.height = $svg.height.baseVal.value;\n\n            const ctx = $canvas.getContext('2d');\n            if(!ctx){\n                reject({\n                    isError: true,\n                });\n                return;\n            }\n\n            const data = (new XMLSerializer()).serializeToString($svg);\n            const blob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\n            const url = URL.createObjectURL(blob);\n\n            const $img = new Image();\n            $img.onload = () => {\n                ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                ctx.drawImage($img, 0, 0);\n\n                URL.revokeObjectURL(url);\n\n                $canvas.toBlob(cBlob => {\n\n                    if(!cBlob){\n                        resolve({\n                            isError: true,\n                        });\n                        return;\n                    }\n\n                    const cUrl = URL.createObjectURL(cBlob);\n                    const link = document.createElement('a');\n                    link.href = cUrl;\n                    link.title = '';\n                    link.download = formattedFileName;\n                    link.click();\n\n                    URL.revokeObjectURL(cUrl);\n\n                    resolve({\n                        isError: false,\n                    });\n                });\n            };\n\n            $img.onerror = () => {\n                resolve({\n                    isError: true,\n                });\n            };\n\n            $img.src = url;\n        }\n    });\n};", "import { setAttributes, SVG_NAMESPACE } from './core';\n\nexport const createDefs = (props?: {\n    document?: Document;\n    id?: string;\n    classes?: string;\n}) : SVGDefsElement => {\n\n    const doc = props?.document || window.document;\n\n    const $defs = doc.createElementNS(SVG_NAMESPACE, 'defs');\n\n    setAttributes($defs, [\n        ['id', props?.id],\n        ['class', props?.classes],\n    ]);\n\n    return $defs;\n};\n\nexport const createPattern = (props: {\n    document?: Document;\n\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n\n    href?: string;\n    patternContentUnits?: string|number;\n    patternTransform?: string;\n    patternUnits?: string;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n\n    // ------------------\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n}) : SVGPatternElement => {\n\n    const {\n        document: _document,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $pattern = doc.createElementNS(SVG_NAMESPACE, 'pattern');\n\n    setAttributes($pattern, [\n        ['x', props.x],\n        ['y', props.y],\n        ['width', props.width],\n        ['height', props.height],\n\n        ['href', props.href],\n        ['patternContentUnits', props.patternContentUnits],\n        ['patternTransform', props.patternTransform],\n        ['patternUnits', props.patternUnits],\n        ['preserveAspectRatio', props.preserveAspectRatio],\n        ['viewBox', props.viewBox],\n\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ]);\n\n    return $pattern;\n};", "export const appendOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.append($el);\n};\n\nexport const prependOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.prepend($el);\n};"],
  "mappings": "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",
  "names": ["SVG_NAMESPACE", "XMLNS_NAMESPACE", "DEFAULT_DECIMAL_PLACES", "createSVG", "props", "_width", "_height", "_document", "$svg", "width", "height", "createSVGFromString", "svg", "$box", "getSVGAsString", "setAttributes", "$svgElement", "attr", "pair", "prop", "value", "getCommonAttributes", "props", "createPath", "_document", "_d", "$path", "SVG_NAMESPACE", "d", "setAttributes", "createRect", "$rect", "createCircle", "$circle", "createEllipse", "$ellipse", "createLine", "$line", "createPolygon", "$polygon", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "createStar", "props", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_RAY_NUMBERS", "dots", "raysNumber", "decimalPlaces", "angleDiff", "halfAngle", "i", "angle", "c", "d", "dot", "pathProps", "__spreadProps", "__spreadValues", "createPath", "getRectPathD", "props", "x", "y", "width", "height", "_rx", "_ry", "rx", "ry", "top1", "top2", "top3", "top4", "right1", "right2", "bottom1", "bottom2", "bottom3", "bottom4", "left1", "left2", "createRectPath", "pathProps", "__spreadProps", "__spreadValues", "createPath", "MISSING_SVG_ERR", "formatExt", "ext", "download", "props", "resolve", "reject", "svgString", "getSVGAsString", "formattedExt", "formattedFileName", "blob", "url", "link", "$svg", "createSVGFromString", "$canvas", "ctx", "data", "$img", "cBlob", "cUrl", "createDefs", "props", "$defs", "SVG_NAMESPACE", "setAttributes", "createPattern", "_document", "$pattern", "appendOnce", "$parent", "$el", "tagName", "prependOnce"]
}
