{
  "version": 3,
  "sources": ["../../src/main/core.ts", "../../src/main/shapes/primitive-shapes.ts", "../../node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-math/src/main/shapes.ts", "../../src/main/path/scanner.ts", "../../src/main/path/parser.ts", "../../src/main/path/minify.ts", "../../src/main/path/convert.ts", "../../src/main/path/index.ts", "../../src/main/shapes/stars.ts", "../../src/main/shapes/flowers.ts", "../../src/docs/client-side/js/examples.ts", "../../src/docs/client-side/js/menu/mobile-menu.ts", "../../src/docs/client-side/js/menu/side-menu.ts", "../../src/docs/client-side/js/dark-mode.ts", "../../src/docs/client-side/js/index.tsx"],
  "sourcesContent": ["import { IPrimitiveShapeProps } from '../interfaces';\n\n/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\nexport interface ICreateSVGProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n    autoViewBox?: boolean;\n}\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props?: ICreateSVGProps) : SVGSVGElement => {\n\n    const doc = props?.document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n\n    let viewBox = props?.viewBox;\n    if(props?.autoViewBox){\n        viewBox = `${ props?.x || 0 } ${ props?.y || 0 } ${ props?.width || 0 } ${ props?.height || 0 }`;\n    }\n\n    setAttributes($svg, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['viewBox', viewBox],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};\n\nexport const getCommonAttributes = (props?: {\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    stroke?: string;\n    strokeWidth?: number|string;\n    strokeOpacity?: number|string;\n    strokeLinecap?: string; // 'round'\n    strokeLinejoin?: string;\n    strokeDasharray?: string;\n    strokeDashoffset?: number|string;\n    strokeMiterlimit?: number|string;\n\n    fill?: string;\n    fillOpacity?: number|string;\n    fillRule?: string;\n\n    filter?: string;\n    mask?: string;\n    transform?: string;\n\n    vectorEffect?: string; // 'non-scaling-stroke' - used to disable line scale\n    shapeRendering?: string;\n\n    clipPath?: string;\n    clipRule?: string;\n\n    opacity?: string|number;\n    visibility?: string;\n}) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from '../core';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport interface ICreatePathProps extends IPrimitiveShapeProps{\n    d?: string;\n    pathLength?: string|number;\n}\n\nexport const createPath = (props?: ICreatePathProps) : SVGPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(props?.d){\n        // remove newlines and double spaces\n        props.d = props?.d.replace(/\\s\\s+/g, ' ');\n    }\n\n    setAttributes($path, [\n        ['d', props?.d],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\nexport interface ICreateRectProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n    pathLength?: string|number;\n}\n\nexport const createRect = (props?: ICreateRectProps) : SVGRectElement => {\n    const doc = props?.document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\nexport interface ICreateCircleProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createCircle = (props?: ICreateCircleProps) : SVGCircleElement => {\n\n    const doc = props?.document || window.document;\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['r', props?.r],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\nexport interface ICreateEllipseProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createEllipse = (props?: ICreateEllipseProps) : SVGEllipseElement => {\n    const doc = props?.document || window.document;\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\nexport interface ICreateLineProps extends IPrimitiveShapeProps{\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createLine = (props?: ICreateLineProps) : SVGLineElement => {\n    const doc = props?.document || window.document;\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props?.x1],\n        ['x2', props?.x2],\n        ['y1', props?.y1],\n        ['y2', props?.y2],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\nexport interface ICreatePolygonProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolygon = (props?: ICreatePolygonProps) : SVGPolygonElement => {\n    const doc = props?.document || window.document;\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n\nexport interface ICreatePolylineProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolyline = (props?: ICreatePolylineProps) : SVGPolylineElement => {\n    const doc = props?.document || window.document;\n\n    const $polyline = doc.createElementNS(SVG_NAMESPACE, 'polyline');\n\n    setAttributes($polyline, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polyline;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n\n    return [\n        linearEquation(equation1, decimalPlaces),\n        linearEquation(equation2, decimalPlaces),\n    ];\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { EPathDataCommand, IPathDataScanResult } from './interfaces';\n\nconst NUMBER_REGEX = /^[+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d+)?(?:(?<=\\d)(?:[eE][+-]?\\d+))?/;\n\n/**\n * Path Data Scanner.\n */\nexport const scan = (pathData?: string) : IPathDataScanResult => {\n\n    const result: IPathDataScanResult = {\n        tokens: [],\n        errors: [],\n    };\n\n    if(!pathData || pathData.trim() === '') return result;\n\n    let current = 0;\n    let line = 0;\n    let col = 0;\n\n    const isEnd = () => {\n        return current >= pathData.length;\n    };\n\n    const addKeywordToken = (tokenType: EPathDataCommand) => {\n        result.tokens.push({\n            tokenType,\n            line,\n            col,\n        });\n    };\n\n    const addNumberToken = (num: number|string) => {\n        result.tokens.push({\n            tokenType: 'num',\n            value: num,\n            line,\n            col,\n        });\n    };\n\n    const addError = (msg: string) => {\n        result.errors.push({\n            line,\n            col,\n            msg,\n        });\n    };\n\n    const matchNumber = () : boolean => {\n        if(isEnd()) return false;\n        return NUMBER_REGEX.test(pathData.substring(current));\n    };\n\n    /**\n     * Scan a single token.\n     */\n    const scanToken = () => {\n        const char = pathData[current];\n\n        // Path data can contain newline characters and\n        // thus can be broken up into multiple lines to improve readability.\n        // If a newline character ---> update line and col params.\n        if(char.charAt(0) === '\\n' || char.charAt(0) === '\\r'){\n            current++;\n            col = 0;\n            line++;\n            return;\n        }\n\n        // Superfluous white space and separators such as commas can be eliminated.\n        // \"M 100 100 L 200 200\" contains unnecessary spaces and could be expressed more compactly as \"M100 100L200 200\".\n        if(/\\s/.test(char) || char === ','){\n            current++;\n            col++;\n            return;\n        }\n\n        // try to match a number\n        if(matchNumber()){\n            const matchRes = pathData.substring(current).match(NUMBER_REGEX);\n\n            if(matchRes && matchRes.length > 0){\n                const num = matchRes[0];\n                addNumberToken(num);\n\n                current += num.length;\n                col += num.length;\n                return;\n            }\n        }\n\n        switch(char){\n            case 'M': addKeywordToken(EPathDataCommand.MoveToAbs); break;\n            case 'm': addKeywordToken(EPathDataCommand.MoveToRel); break;\n            case 'Z': addKeywordToken(EPathDataCommand.ClosePathAbs); break;\n            case 'z': addKeywordToken(EPathDataCommand.ClosePathRel); break;\n            case 'L': addKeywordToken(EPathDataCommand.LineToAbs); break;\n            case 'l': addKeywordToken(EPathDataCommand.LineToRel); break;\n            case 'H': addKeywordToken(EPathDataCommand.LineToHorizontalAbs); break;\n            case 'h': addKeywordToken(EPathDataCommand.LineToHorizontalRel); break;\n            case 'V': addKeywordToken(EPathDataCommand.LineToVerticalAbs); break;\n            case 'v': addKeywordToken(EPathDataCommand.LineToVerticalRel); break;\n            case 'C': addKeywordToken(EPathDataCommand.CubicCurveToAbs); break;\n            case 'c': addKeywordToken(EPathDataCommand.CubicCurveToRel); break;\n            case 'S': addKeywordToken(EPathDataCommand.CubicCurveToSmoothAbs); break;\n            case 's': addKeywordToken(EPathDataCommand.CubicCurveToSmoothRel); break;\n            case 'Q': addKeywordToken(EPathDataCommand.QuadraticCurveToAbs); break;\n            case 'q': addKeywordToken(EPathDataCommand.QuadraticCurveToRel); break;\n            case 'T': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothAbs); break;\n            case 't': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothRel); break;\n            case 'A': addKeywordToken(EPathDataCommand.ArcAbs); break;\n            case 'a': addKeywordToken(EPathDataCommand.ArcRel); break;\n\n            default: {\n                addError(`Unexpected character ${ char }`);\n                break;\n            }\n        }\n\n        current++;\n        col++;\n    };\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        scanToken();\n    }\n\n    return result;\n};", "import { EPathDataCommand, IPathData, IPathDataScanResult, IPathDataToken } from './interfaces';\n\n/**\n * All path data instructions are expressed as one character (e.g., a moveto is expressed as an M).\n * Relative versions of all commands are available (uppercase means absolute coordinates, lowercase means relative coordinates).\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n */\nexport const parse = (scanResult: IPathDataScanResult) : IPathData => {\n\n    const pathData: IPathData = {\n        commands: [],\n        errors: scanResult.errors || [],\n    };\n\n    if(scanResult.errors.length > 0 ||\n        scanResult.tokens.length === 0) return pathData;\n\n    const { tokens, errors } = scanResult;\n\n    const error = (token: IPathDataToken, msg: string) => {\n        errors.push({\n            line: token?.line,\n            col: token?.col,\n            msg,\n        });\n    };\n\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    if(tokens[0].tokenType !== EPathDataCommand.MoveToAbs &&\n        tokens[0].tokenType !== EPathDataCommand.MoveToRel) {\n        error(tokens[0], `A path data segment must begin with a 'moveto' command 'M' or 'm'.`);\n        return pathData;\n    }\n\n    let current = 0;\n\n    const isEnd = () => {\n        return current >= tokens.length;\n    };\n\n    const areArcFlagsValid = (tokenType: string): boolean => {\n\n        // we are checking only 'A/a' type\n        if(!tokenType || tokenType.toLowerCase() !== 'a') return true;\n\n        // 4th and 5th param should be 0 or 1\n        const val4 = (tokens[current + 4]?.value || '').toString();\n        const val5 = (tokens[current + 5]?.value || '').toString();\n\n        return (val4 === '0' || val4 === '1') && (val5 === '0' || val5 === '1');\n    };\n\n    /**\n     * https://www.w3.org/TR/SVG11/paths.html#PathData\n     */\n    const parseCommand = (paramsCount: number, nextParamsTokenType: EPathDataCommand, isRelative: boolean) => {\n\n        const tokenType = tokens[current].tokenType;\n        const params: number[] = [];\n\n        if(paramsCount > 0){\n\n            // Validate the parameters count, and add them to the params list.\n            for(let i= 1; i <= paramsCount; i++){\n                if(!tokens[current + i] || tokens[current + i].tokenType !== 'num'){\n                    error(tokens[current], `Expected number(s) after command ${ tokenType }.`);\n                    current += paramsCount;\n                    return;\n                }\n\n                params.push(Number(tokens[current + i].value));\n            }\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        pathData.commands.push({\n            command: tokens[current].tokenType as EPathDataCommand,\n            params,\n        });\n\n        current += paramsCount + 1;\n\n        if(paramsCount <= 0) return;\n\n        // If the command is followed by multiple sets of coordinates, the subsequent pairs are treated as implicit commands.\n        const nextTokens: IPathDataToken[] = [];\n\n        // Add all 'next params' to the list.\n        while(tokens[current]?.tokenType === 'num'){\n            nextTokens.push(tokens[current]);\n            current++;\n        }\n\n        // Validate next params count.\n        if(nextTokens.length % paramsCount !== 0){\n            error(nextTokens[nextTokens.length - 1], `Expected a number.`);\n            return;\n        }\n\n        const nextCommand = (isRelative ? nextParamsTokenType.toLowerCase() : nextParamsTokenType.toUpperCase()) as EPathDataCommand;\n\n        // Add them to the commands list.\n        for(let i= 0; i < nextTokens.length; i += paramsCount){\n            const nextParams: number[] = [];\n            for(let j = 0; j < paramsCount; j++){\n                nextParams.push(Number(nextTokens[i + j].value));\n            }\n            pathData.commands.push({\n                command: nextCommand,\n                params: nextParams,\n            });\n        }\n    };\n\n    const parseNext = () => {\n        const token = tokens[current];\n\n        const isRelative = token.tokenType.toLowerCase() === token.tokenType;\n\n        switch (token.tokenType){\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.LineToRel:{\n                parseCommand(2, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                parseCommand(0, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:\n            case EPathDataCommand.LineToHorizontalRel:\n            case EPathDataCommand.LineToVerticalAbs:\n            case EPathDataCommand.LineToVerticalRel:{\n                parseCommand(1, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:\n            case EPathDataCommand.CubicCurveToRel:{\n                parseCommand(6, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToAbs:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                parseCommand(4, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                parseCommand(2, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:\n            case EPathDataCommand.ArcRel:{\n                parseCommand(7, token.tokenType, isRelative);\n                break;\n            }\n\n            default: {\n                error(tokens[current], `Wrong path command.`);\n                current++;\n                break;\n            }\n        }\n    };\n\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    parseCommand(2, EPathDataCommand.LineToAbs, tokens[0].tokenType === EPathDataCommand.MoveToRel);\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        parseNext();\n    }\n\n    return pathData;\n};", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\n\nconst numberToString = (num: number, decimalPlaces = 2) : string => {\n\n    if(Number.isInteger(num)) return num.toString();\n\n    const _num = setDecimalPlaces(num, decimalPlaces).toString();\n    const parts = _num.split('.');\n    const intPart = parts[0];\n    const decimalPart = parts[1];\n\n    if(intPart === '0') return `.${ decimalPart }`;\n    if(intPart === '-0') return `-.${ decimalPart }`;\n\n    return _num;\n};\n\nconst combineParams = (params: number[], decimalPlaces: number) => {\n    if(!params || params.length <= 0) return '';\n\n    let combined = numberToString(params[0], decimalPlaces);\n\n    for(let i= 1; i<params.length; i++){\n        const param = params[i];\n        const str = numberToString(param, decimalPlaces);\n        if(param < 0){\n            combined +=  str;\n        }\n        else{\n            combined += ` ${ str }`;\n        }\n    }\n\n    return combined;\n};\n\nexport const pathDataMinify = (pathData: IPathData, decimalPlaces = 2) : string => {\n\n    let d = '';\n    let lastCommand: EPathDataCommand|null = null;\n\n    for(const item of pathData.commands){\n\n        // handle cases like 'L80 0' ----> 'H80', 'L0 80' ----> 'V80'\n        if(item.command === EPathDataCommand.LineToAbs){\n            if(item.params[0] === 0){\n                d += `V${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalAbs;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `H${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalAbs;\n                continue;\n            }\n        }\n\n        // handle cases like 'l80 0' ----> 'h80' & 'l0 80' ----> 'v80'\n        if(item.command === EPathDataCommand.LineToRel){\n            if(item.params[0] === 0){\n                d += `v${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalRel;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `h${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalRel;\n                continue;\n            }\n        }\n\n        // handle cases like 'c0 0 10 0 10 10' ---> 's10 0 10 10'\n        if(item.command === EPathDataCommand.CubicCurveToRel &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToAbs.toLowerCase() &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToSmoothAbs.toLowerCase()){\n            if(item.params[0] === 0 && item.params[1] === 0){\n\n                const params = combineParams([\n                    item.params[2],\n                    item.params[3],\n                    item.params[4],\n                    item.params[5],\n                ], decimalPlaces);\n\n                d += `s${ params }`;\n                lastCommand = EPathDataCommand.CubicCurveToSmoothRel;\n                continue;\n            }\n        }\n\n        const canSkipCommand =\n            (lastCommand === item.command) ||\n            (lastCommand === EPathDataCommand.MoveToAbs && item.command === EPathDataCommand.LineToAbs) ||\n            (lastCommand === EPathDataCommand.MoveToRel && item.command === EPathDataCommand.LineToRel);\n\n        if(canSkipCommand){\n            if(item.params.length > 0 && item.params[0] >= 0){\n                d += ' ';\n            }\n        }\n        else{\n            d += item.command;\n        }\n\n        d += combineParams(item.params, decimalPlaces);\n\n        lastCommand = item.command;\n    }\n\n    return d.trim();\n};\n", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\nimport { pathDataMinify } from './minify';\n\nexport const pathDataToRelative = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToAbs:{\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToRel:{\n                x += commands[i].params[0];\n                y += commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] -= x;\n                x = savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                x += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] -= y;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                y += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] -= x;\n                commands[i].params[5] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                x += commands[i].params[4];\n                y += commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                x += commands[i].params[2];\n                y += commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] -= x;\n                commands[i].params[6] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                x += commands[i].params[5];\n                y += commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command lowercase\n        commands[i].command = commands[i].command.toLowerCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToAbsolute = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i]\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToRel:{\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToRel:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                x = commands[i].params[0];\n                y = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] += x;\n                x += savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                x = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] += y;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                y = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] += x;\n                commands[i].params[5] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                x = commands[i].params[4];\n                y = commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                x = commands[i].params[2];\n                y = commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] += x;\n                commands[i].params[6] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                x = commands[i].params[5];\n                y = commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command uppercase\n        commands[i].command = commands[i].command.toUpperCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToString = (pathData: IPathData, minify?: boolean, decimalPlaces = 2) : string => {\n    if(!pathData || pathData.commands.length <= 0) return '';\n\n    let d = '';\n\n    if(minify){\n        return pathDataMinify(pathData, decimalPlaces);\n    }\n\n    for(const item of pathData.commands){\n        d += item.command;\n        if(item.params.length > 0){\n            d += ` ${ item.params.map(param => Number.isInteger(param) ? param : setDecimalPlaces(param, decimalPlaces)).join(' ')} `\n        }\n        else{\n            d += ' ';\n        }\n    }\n\n    return d.trim();\n};\n\nexport const maximizeAbsolutePath = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n\n                // update y to be the same as in previous command\n                commands[i].params[1] = prev.params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n                const y = commands[i].params[0];\n\n                // update x to be the same as in previous command\n                commands[i].params[0] = prev.params[0];\n                commands[i].params.push(y);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:{\n                // prev should be Cubic B\u00E9zier Curve Abs (C)\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (C): x1,y1, x2,y2, x,y\n                commands[i].command = EPathDataCommand.CubicCurveToAbs;\n\n                // For S: (x2 y2 x y)\n                // The first control point is assumed to be the reflection\n                // of the second control point on the previous command\n                // relative to the current point.\n                // (If there is no previous command or if the previous command was not an C, c, S or s,\n                // assume the first control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[3]); // prev y2\n                commands[i].params.unshift(prev.params[2]); // prev x2\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                // prev should be Quadratic B\u00E9zier Curve Abs (Q)\n\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (Q): x1 y1 x y\n                commands[i].command = EPathDataCommand.QuadraticCurveToAbs;\n\n                // For T: (x y)\n                // The control point is assumed to be the reflection of the control point on the previous command relative to the current point.\n                // (If there is no previous command or if the previous command was not a Q, q, T or t,\n                // assume the control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[1]); // prev y2\n                commands[i].params.unshift(prev.params[0]); // prev x2\n                break;\n            }\n        }\n    }\n\n    return pathData;\n};", "import { IPathData } from './interfaces';\nimport { scan } from './scanner';\nimport { parse } from './parser';\nimport { pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { pathDataMinify } from './minify';\n\nexport const isPathValid = (d?: string): boolean => {\n    const parsed = parsePath(d);\n    return parsed.errors.length <= 0;\n};\n\n/**\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n * \u2018d\u2019 attribute contains the moveto, line, curve (both cubic and quadratic B\u00E9ziers), arc and closepath instructions.\n */\nexport const parsePath = (d?: string): IPathData => {\n    const scanResult = scan(d);\n    return parse(scanResult);\n};\n\n/**\n * Converts all path commands to relative.\n */\nexport const pathToRel = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToRelative(parsed), !beautify, decimalPlaces);\n};\n\n/**\n * Converts all path commands to absolute.\n */\nexport const pathToAbs = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToAbsolute(parsed), !beautify, decimalPlaces);\n};\n\nexport const minifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataMinify(parsed, decimalPlaces);\n};\n\nexport const beautifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(parsed, false, decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\n\nexport interface ICreateStarProps extends IPrimitiveShapeProps{\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n    type?: number;\n}\n\nexport const createStar = (props: ICreateStarProps) : SVGPathElement => {\n\n    switch (props.type){\n        case 2: {\n            return createStar2(props);\n        }\n        case 3: {\n            return createStar3(props);\n        }\n    }\n\n    return createStar1(props);\n};\n\nexport const createStar1 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n    d += dots.map(dot => `L ${ dot[0] } ${ dot[1] }`).join(' ');\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar2 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar3 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] } L ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\nimport { mod } from 'mz-math';\n\nexport interface ICreateFlowerProps extends IPrimitiveShapeProps{\n    petalsNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n}\n\nexport const createFlower = (props: ICreateFlowerProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_PETALS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const petalsNumber = Math.max(MIN_PETALS_NUMBER, Number(props.petalsNumber) || MIN_PETALS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / petalsNumber;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<petalsNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i= 0; i < dots.length; i += 2){\n        const outerDot = dots[mod(i + 1, dots.length)];\n        const innerDot2 = dots[mod(i + 2, dots.length)];\n        const outerDot2 = dots[mod(i + 3, dots.length)];\n\n        d += `C ${ outerDot[0] } ${ outerDot[1] } ${ outerDot2[0] } ${ outerDot2[1] } ${ innerDot2[0] } ${ innerDot2[1] } `;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createStar } from '../../../main/shapes/stars';\nimport { createSVG } from '../../../main/core';\nimport { getRandomHSLColorWithinRanges, hslToHex, getRandomInt } from 'mz-math';\nimport { createFlower } from '../../../main/shapes/flowers';\n\nexport const starExamples = () => {\n\n  if(!document.querySelector('[data-examples=\"star-examples\"]')) return;\n\n  try{\n\n    const $btn = document.getElementById('star-random-btn') as HTMLButtonElement;\n    const $placeholder = document.getElementById('star-ph') as HTMLDivElement;\n\n    const renderStar = () => {\n      $placeholder.innerHTML = '';\n\n      const $svg = createSVG({\n        width: 200,\n        height: 200\n      });\n\n      const hslColor = getRandomHSLColorWithinRanges(\n          0, 360, // hue range\n          60, 100, // saturation range\n          30, 50, // lightness range\n      );\n      const hex = hslToHex(hslColor); // #1c1817\n\n      const raysNumber = getRandomInt(4, 12);\n      const type = getRandomInt(1, 3);\n\n      const $star = createStar({\n        raysNumber,\n        centerX: 100,\n        centerY: 100,\n        outerRadius: type === 2 ? 80 : 100,\n        innerRadius: 50,\n        fill: hex,\n        type: type,\n      });\n\n      $svg.append($star);\n\n      $placeholder.append($svg);\n    };\n\n    $btn.addEventListener('click', () => {\n      renderStar();\n    });\n\n    renderStar();\n  }\n  catch(ex) { console.error(ex); }\n\n};\n\nexport const flowerExamples = () => {\n\n  if(!document.querySelector('[data-examples=\"flower-examples\"]')) return;\n\n  try{\n\n    const $btn = document.getElementById('flower-random-btn') as HTMLButtonElement;\n    const $placeholder = document.getElementById('flower-ph') as HTMLDivElement;\n\n    const renderflower = () => {\n      $placeholder.innerHTML = '';\n\n      const $svg = createSVG({\n        width: 200,\n        height: 200\n      });\n\n      const hslColor = getRandomHSLColorWithinRanges(\n          0, 360, // hue range\n          60, 100, // saturation range\n          30, 50, // lightness range\n      );\n      const hex = hslToHex(hslColor); // #1c1817\n\n      const petalsNumber = getRandomInt(4, 12);\n      const innerRadius = getRandomInt(2, 60);\n\n      const $flower = createFlower({\n        petalsNumber,\n        centerX: 100,\n        centerY: 100,\n        outerRadius: 100,\n        innerRadius,\n        fill: hex,\n      });\n\n      $svg.append($flower);\n\n      $placeholder.append($svg);\n    };\n\n    $btn.addEventListener('click', () => {\n      renderflower();\n    });\n\n    renderflower();\n  }\n  catch(ex) { console.error(ex); }\n\n};", "export const initMobileMenu = () => {\n    const $btn = document.getElementById('mobile-menu-btn');\n    if(!$btn) return;\n\n    $btn.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n        document.body.classList.toggle('mobile-menu-opened');\n    });\n\n    document.body.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n\n    const $sideMenu = document.getElementById('side-menu');\n    if(!$sideMenu) return;\n\n    $sideMenu.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n    });\n\n    const $close = document.getElementById('mobile-menu-close-btn');\n    if(!$close) return;\n\n    $close.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n};\n", "const COLLAPSIBLE_STORAGE_KEY = 'side-menu';\n\ninterface ICollapsible {\n    id: string;\n    opened: boolean;\n}\n\nexport const initMenuScroll = () => {\n    const $menu = document.querySelector('.side-menu');\n    if(!$menu) return;\n\n    const path = window.location.pathname;\n    const $link = $menu.querySelector(`a[href='${ path }']`);\n    if(!$link) return;\n\n    $link.scrollIntoView({\n        block: 'center',\n    });\n};\n\nconst getStateFromStorage = (): ICollapsible[] => {\n    const data = window.localStorage.getItem(COLLAPSIBLE_STORAGE_KEY);\n    if(!data) return [];\n\n    let menu: ICollapsible[] = [];\n\n    try{\n        menu = JSON.parse(data) || [];\n    }\n    catch(ex){\n        // ...\n    }\n\n    return menu;\n};\n\nconst saveStateToStorage = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]');\n    const menu: ICollapsible[] = [];\n\n    for(const $title of $titles){\n        const id = $title.getAttribute('data-id') || '';\n        if(!id) continue;\n\n        const opened = $title.getAttribute('data-opened') === 'true';\n\n        menu.push({\n            id,\n            opened\n        });\n    }\n\n    window.localStorage.setItem(COLLAPSIBLE_STORAGE_KEY, JSON.stringify(menu));\n};\n\nconst restoreCollapsible = () => {\n    const menu = getStateFromStorage();\n    if(!Array.isArray(menu)) return;\n\n    for(const menuItem of menu){\n        const $title = document.querySelector(`.side-menu [data-id=\"${ menuItem.id }\"]`) as HTMLElement;\n        toggle($title, menuItem.opened, false);\n    }\n};\n\nconst toggle = ($title: HTMLElement, opened: boolean, saveToStorage: boolean) => {\n\n    $title.setAttribute('data-opened', opened.toString());\n\n    const $arrow = $title.querySelector('[data-arrow]');\n    if(!$arrow) return;\n\n    $arrow.classList.toggle('rotate-90', opened);\n    $title.nextElementSibling?.classList.toggle('hidden', !opened);\n\n    if(saveToStorage){\n        saveStateToStorage();\n    }\n};\n\nexport const initMenuCollapsible = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]') as NodeListOf<HTMLElement>;\n\n    for(const $title of $titles){\n        $title.addEventListener('click', () => {\n            const isOpened = $title.getAttribute('data-opened') === 'true';\n            toggle($title, !isOpened, true);\n        });\n    }\n\n    // try to restore collapsible state on page load\n    restoreCollapsible();\n};", "const MODE_STORAGE_KEY = 'mode';\n\nexport const handleDarkLightModes = () => {\n\n    const mode = window.localStorage.getItem(MODE_STORAGE_KEY) || 'light';\n    document.documentElement.classList.toggle('dark', mode === 'dark');\n\n    const $moveToDarkBtn = document.getElementById('move-to-dark-mode-btn') as HTMLButtonElement;\n    const $moveToLightBtn = document.getElementById('move-to-light-mode-btn') as HTMLButtonElement;\n\n    const moveToDark = () => {\n        document.documentElement.classList.add('dark');\n        $moveToDarkBtn.classList.add('hidden');\n        $moveToLightBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'dark');\n    };\n\n    const moveToLight = () => {\n        document.documentElement.classList.remove('dark');\n        $moveToLightBtn.classList.add('hidden');\n        $moveToDarkBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'light');\n    };\n\n    if(mode === 'dark'){\n        moveToDark();\n    }\n    else{\n        moveToLight();\n    }\n\n    $moveToDarkBtn?.addEventListener('click', moveToDark);\n    $moveToLightBtn?.addEventListener('click', moveToLight);\n};\n", "import {\n  flowerExamples,\n  starExamples,\n} from './examples';\nimport { initMobileMenu } from './menu/mobile-menu';\nimport { initMenuCollapsible, initMenuScroll } from './menu/side-menu';\nimport { handleDarkLightModes } from './dark-mode';\n\nconst init = () => {\n  initMobileMenu();\n  initMenuScroll();\n  initMenuCollapsible();\n  handleDarkLightModes();\n};\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  init();\n  starExamples();\n  flowerExamples();\n});\n\nexport {};\n"],
  "mappings": "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",
  "names": ["SVG_NAMESPACE", "XMLNS_NAMESPACE", "DEFAULT_DECIMAL_PLACES", "createSVG", "props", "$svg", "viewBox", "setAttributes", "getCommonAttributes", "setAttributes", "$svgElement", "attr", "pair", "prop", "value", "getCommonAttributes", "props", "createPath", "props", "$path", "SVG_NAMESPACE", "setAttributes", "getCommonAttributes", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "getRandom", "min", "max", "decimalPlaces", "setDecimalPlaces", "getRandomInt", "mod", "n", "m", "getRandomHSLColorWithinRanges", "hueStart", "hueEnd", "saturationStart", "saturationEnd", "lightStart", "lightEnd", "h", "getRandom", "s", "l", "hslToHex", "hsl", "h", "s", "l", "r", "g", "b", "hue2rgb", "p", "q", "t", "toHex", "x", "hex", "NUMBER_REGEX", "scan", "pathData", "result", "current", "line", "col", "isEnd", "addKeywordToken", "tokenType", "addNumberToken", "num", "addError", "msg", "matchNumber", "scanToken", "char", "matchRes", "parse", "scanResult", "pathData", "tokens", "errors", "error", "token", "msg", "current", "isEnd", "areArcFlagsValid", "tokenType", "_a", "_b", "val4", "val5", "parseCommand", "paramsCount", "nextParamsTokenType", "isRelative", "params", "i", "nextTokens", "nextCommand", "nextParams", "j", "parseNext", "numberToString", "num", "decimalPlaces", "_num", "i", "parts", "intPart", "decimalPart", "combineParams", "params", "combined", "param", "str", "pathDataMinify", "pathData", "d", "lastCommand", "item", "pathDataToRelative", "pathData", "commands", "x", "y", "mx", "my", "i", "savedX", "savedY", "pathDataToString", "pathData", "minify", "decimalPlaces", "d", "pathDataMinify", "item", "param", "i", "parsePath", "d", "scanResult", "scan", "parse", "pathToRel", "beautify", "decimalPlaces", "parsed", "pathDataToString", "pathDataToRelative", "createStar", "props", "createStar2", "createStar3", "createStar1", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_RAYS_NUMBER", "dots", "raysNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "halfAngle", "i", "angle", "d", "dot", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "dot1", "dot2", "createFlower", "props", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_PETALS_NUMBER", "dots", "petalsNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "i", "angle", "d", "outerDot", "X", "innerDot2", "outerDot2", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "starExamples", "$btn", "$placeholder", "renderStar", "$svg", "createSVG", "hslColor", "uo", "hex", "Qt", "raysNumber", "Tt", "type", "$star", "createStar", "ex", "flowerExamples", "renderflower", "petalsNumber", "innerRadius", "$flower", "createFlower", "initMobileMenu", "$btn", "evt", "$sideMenu", "$close", "COLLAPSIBLE_STORAGE_KEY", "initMenuScroll", "$menu", "path", "$link", "getStateFromStorage", "data", "menu", "ex", "saveStateToStorage", "$titles", "$title", "id", "opened", "restoreCollapsible", "menuItem", "toggle", "saveToStorage", "_a", "$arrow", "initMenuCollapsible", "isOpened", "MODE_STORAGE_KEY", "handleDarkLightModes", "mode", "$moveToDarkBtn", "$moveToLightBtn", "moveToDark", "moveToLight", "init", "initMobileMenu", "initMenuScroll", "initMenuCollapsible", "handleDarkLightModes", "starExamples", "flowerExamples"]
}
