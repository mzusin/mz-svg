{
  "version": 3,
  "sources": ["../../src/main/core.ts", "../../src/main/shapes/primitive-shapes.ts", "../../node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-math/src/main/shapes.ts", "../../src/main/path/scanner.ts", "../../src/main/path/parser.ts", "../../src/main/path/minify.ts", "../../src/main/path/convert.ts", "../../src/main/path/index.ts", "../../src/main/shapes/stars.ts", "../../src/main/shapes/flowers.ts", "../../src/docs/client-side/js/examples.ts", "../../src/docs/client-side/js/menu/mobile-menu.ts", "../../src/docs/client-side/js/menu/side-menu.ts", "../../src/docs/client-side/js/dark-mode.ts", "../../node_modules/mz-particles/node_modules/mz-canvas/src/core/canvas.ts", "../../node_modules/mz-particles/node_modules/mz-canvas/src/core/shapes/primitive-shapes.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/shapes.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/collision-detection.ts", "../../node_modules/mz-particles/node_modules/mz-math/src/main/animation.ts", "../../node_modules/mz-particles/src/core/domain/colors-provider.ts", "../../node_modules/mz-particles/src/core/domain/viewport-provider.ts", "../../node_modules/mz-particles/src/core/domain/connections-provider.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/core.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/primitive-shapes.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/format.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/angle.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/vector.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/matrix.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/linear-algebra/matrix-transformations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/random.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/other.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/convert.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/derivative.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/equations/linear-equations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/equations/quadratic-equations.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/bezier-curves/bezier-curve.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/path-movement.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/color.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/id.ts", "../../node_modules/mz-particles/node_modules/mz-svg/node_modules/mz-math/src/main/shapes.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/scanner.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/parser.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/minify.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/convert.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/index.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/stars.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/flowers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/shapes/shape-paths.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/io-browser.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/containers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/helpers.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/bbox.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/path/transform.ts", "../../node_modules/mz-particles/node_modules/mz-svg/src/main/animation/animate.ts", "../../node_modules/mz-particles/node_modules/tinycolor2/esm/tinycolor.js", "../../node_modules/mz-particles/src/core/domain/particles-provider.ts", "../../node_modules/mz-particles/src/core/domain/settings-provider.ts", "../../node_modules/mz-particles/node_modules/lodash-es/isObject.js", "../../node_modules/mz-particles/node_modules/lodash-es/_freeGlobal.js", "../../node_modules/mz-particles/node_modules/lodash-es/_root.js", "../../node_modules/mz-particles/node_modules/lodash-es/now.js", "../../node_modules/mz-particles/node_modules/lodash-es/_trimmedEndIndex.js", "../../node_modules/mz-particles/node_modules/lodash-es/_baseTrim.js", "../../node_modules/mz-particles/node_modules/lodash-es/_Symbol.js", "../../node_modules/mz-particles/node_modules/lodash-es/_getRawTag.js", "../../node_modules/mz-particles/node_modules/lodash-es/_objectToString.js", "../../node_modules/mz-particles/node_modules/lodash-es/_baseGetTag.js", "../../node_modules/mz-particles/node_modules/lodash-es/isObjectLike.js", "../../node_modules/mz-particles/node_modules/lodash-es/isSymbol.js", "../../node_modules/mz-particles/node_modules/lodash-es/toNumber.js", "../../node_modules/mz-particles/node_modules/lodash-es/debounce.js", "../../node_modules/mz-particles/src/core/app.ts", "../../node_modules/mz-particles/src/core/index.ts", "../../src/docs/client-side/js/index.tsx"],
  "sourcesContent": ["import { IPrimitiveShapeProps } from '../interfaces';\n\n/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\nexport interface ICreateSVGProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n    autoViewBox?: boolean;\n}\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props?: ICreateSVGProps) : SVGSVGElement => {\n\n    const doc = props?.document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n\n    let viewBox = props?.viewBox;\n    if(props?.autoViewBox){\n        viewBox = `${ props?.x || 0 } ${ props?.y || 0 } ${ props?.width || 0 } ${ props?.height || 0 }`;\n    }\n\n    setAttributes($svg, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['viewBox', viewBox],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};\n\nexport const getCommonAttributes = (props?: IPrimitiveShapeProps) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from '../core';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport interface ICreatePathProps extends IPrimitiveShapeProps{\n    d?: string;\n    pathLength?: string|number;\n}\n\nexport const createPath = (props?: ICreatePathProps) : SVGPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(props?.d){\n        // remove newlines and double spaces\n        props.d = props?.d.replace(/\\s\\s+/g, ' ');\n    }\n\n    setAttributes($path, [\n        ['d', props?.d],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\nexport interface ICreateRectProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n    pathLength?: string|number;\n}\n\nexport const createRect = (props?: ICreateRectProps) : SVGRectElement => {\n    const doc = props?.document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\nexport interface ICreateCircleProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createCircle = (props?: ICreateCircleProps) : SVGCircleElement => {\n\n    const doc = props?.document || window.document;\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['r', props?.r],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\nexport interface ICreateEllipseProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createEllipse = (props?: ICreateEllipseProps) : SVGEllipseElement => {\n    const doc = props?.document || window.document;\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\nexport interface ICreateLineProps extends IPrimitiveShapeProps{\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createLine = (props?: ICreateLineProps) : SVGLineElement => {\n    const doc = props?.document || window.document;\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props?.x1],\n        ['x2', props?.x2],\n        ['y1', props?.y1],\n        ['y2', props?.y2],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\nexport interface ICreatePolygonProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolygon = (props?: ICreatePolygonProps) : SVGPolygonElement => {\n    const doc = props?.document || window.document;\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n\nexport interface ICreatePolylineProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolyline = (props?: ICreatePolylineProps) : SVGPolylineElement => {\n    const doc = props?.document || window.document;\n\n    const $polyline = doc.createElementNS(SVG_NAMESPACE, 'polyline');\n\n    setAttributes($polyline, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polyline;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\nimport { isNumber } from '../other';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n    const res1 = linearEquation(equation1, decimalPlaces);\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n    const res2 = linearEquation(equation2, decimalPlaces);\n\n    const res: Vector = [];\n\n    if(isNumber(res1)){\n        res.push(res1);\n    }\n\n    if(isNumber(res2)){\n        res.push(res2);\n    }\n\n    return res;\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { EPathDataCommand, IPathDataScanResult } from './interfaces';\n\nconst NUMBER_REGEX = /^[+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d+)?(?:(?<=\\d)(?:[eE][+-]?\\d+))?/;\n\n/**\n * Path Data Scanner.\n */\nexport const scan = (pathData?: string) : IPathDataScanResult => {\n\n    const result: IPathDataScanResult = {\n        tokens: [],\n        errors: [],\n    };\n\n    if(!pathData || pathData.trim() === '') return result;\n\n    let current = 0;\n    let line = 0;\n    let col = 0;\n\n    const isEnd = () => {\n        return current >= pathData.length;\n    };\n\n    const addKeywordToken = (tokenType: EPathDataCommand) => {\n        result.tokens.push({\n            tokenType,\n            line,\n            col,\n        });\n    };\n\n    const addNumberToken = (num: number|string) => {\n        result.tokens.push({\n            tokenType: 'num',\n            value: num,\n            line,\n            col,\n        });\n    };\n\n    const addError = (msg: string) => {\n        result.errors.push({\n            line,\n            col,\n            msg,\n        });\n    };\n\n    const matchNumber = () : boolean => {\n        if(isEnd()) return false;\n        return NUMBER_REGEX.test(pathData.substring(current));\n    };\n\n    /**\n     * Scan a single token.\n     */\n    const scanToken = () => {\n        const char = pathData[current];\n\n        // Path data can contain newline characters and\n        // thus can be broken up into multiple lines to improve readability.\n        // If a newline character ---> update line and col params.\n        if(char.charAt(0) === '\\n' || char.charAt(0) === '\\r'){\n            current++;\n            col = 0;\n            line++;\n            return;\n        }\n\n        // Superfluous white space and separators such as commas can be eliminated.\n        // \"M 100 100 L 200 200\" contains unnecessary spaces and could be expressed more compactly as \"M100 100L200 200\".\n        if(/\\s/.test(char) || char === ','){\n            current++;\n            col++;\n            return;\n        }\n\n        // try to match a number\n        if(matchNumber()){\n            const matchRes = pathData.substring(current).match(NUMBER_REGEX);\n\n            if(matchRes && matchRes.length > 0){\n                const num = matchRes[0];\n                addNumberToken(num);\n\n                current += num.length;\n                col += num.length;\n                return;\n            }\n        }\n\n        switch(char){\n            case 'M': addKeywordToken(EPathDataCommand.MoveToAbs); break;\n            case 'm': addKeywordToken(EPathDataCommand.MoveToRel); break;\n            case 'Z': addKeywordToken(EPathDataCommand.ClosePathAbs); break;\n            case 'z': addKeywordToken(EPathDataCommand.ClosePathRel); break;\n            case 'L': addKeywordToken(EPathDataCommand.LineToAbs); break;\n            case 'l': addKeywordToken(EPathDataCommand.LineToRel); break;\n            case 'H': addKeywordToken(EPathDataCommand.LineToHorizontalAbs); break;\n            case 'h': addKeywordToken(EPathDataCommand.LineToHorizontalRel); break;\n            case 'V': addKeywordToken(EPathDataCommand.LineToVerticalAbs); break;\n            case 'v': addKeywordToken(EPathDataCommand.LineToVerticalRel); break;\n            case 'C': addKeywordToken(EPathDataCommand.CubicCurveToAbs); break;\n            case 'c': addKeywordToken(EPathDataCommand.CubicCurveToRel); break;\n            case 'S': addKeywordToken(EPathDataCommand.CubicCurveToSmoothAbs); break;\n            case 's': addKeywordToken(EPathDataCommand.CubicCurveToSmoothRel); break;\n            case 'Q': addKeywordToken(EPathDataCommand.QuadraticCurveToAbs); break;\n            case 'q': addKeywordToken(EPathDataCommand.QuadraticCurveToRel); break;\n            case 'T': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothAbs); break;\n            case 't': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothRel); break;\n            case 'A': addKeywordToken(EPathDataCommand.ArcAbs); break;\n            case 'a': addKeywordToken(EPathDataCommand.ArcRel); break;\n\n            default: {\n                addError(`Unexpected character ${ char }`);\n                break;\n            }\n        }\n\n        current++;\n        col++;\n    };\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        scanToken();\n    }\n\n    return result;\n};", "import { EPathDataCommand, IPathData, IPathDataScanResult, IPathDataToken } from './interfaces';\n\n/**\n * All path data instructions are expressed as one character (e.g., a moveto is expressed as an M).\n * Relative versions of all commands are available (uppercase means absolute coordinates, lowercase means relative coordinates).\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n */\nexport const parse = (scanResult: IPathDataScanResult) : IPathData => {\n\n    const pathData: IPathData = {\n        commands: [],\n        errors: scanResult.errors || [],\n    };\n\n    if(scanResult.errors.length > 0 ||\n        scanResult.tokens.length === 0) return pathData;\n\n    const { tokens, errors } = scanResult;\n\n    const error = (token: IPathDataToken, msg: string) => {\n        errors.push({\n            line: token?.line,\n            col: token?.col,\n            msg,\n        });\n    };\n\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    if(tokens[0].tokenType !== EPathDataCommand.MoveToAbs &&\n        tokens[0].tokenType !== EPathDataCommand.MoveToRel) {\n        error(tokens[0], `A path data segment must begin with a 'moveto' command 'M' or 'm'.`);\n        return pathData;\n    }\n\n    let current = 0;\n\n    const isEnd = () => {\n        return current >= tokens.length;\n    };\n\n    const areArcFlagsValid = (tokenType: string): boolean => {\n\n        // we are checking only 'A/a' type\n        if(!tokenType || tokenType.toLowerCase() !== 'a') return true;\n\n        // 4th and 5th param should be 0 or 1\n        const val4 = (tokens[current + 4]?.value || '').toString();\n        const val5 = (tokens[current + 5]?.value || '').toString();\n\n        return (val4 === '0' || val4 === '1') && (val5 === '0' || val5 === '1');\n    };\n\n    /**\n     * https://www.w3.org/TR/SVG11/paths.html#PathData\n     */\n    const parseCommand = (paramsCount: number, nextParamsTokenType: EPathDataCommand, isRelative: boolean) => {\n\n        const tokenType = tokens[current].tokenType;\n        const params: number[] = [];\n\n        if(paramsCount > 0){\n\n            // Validate the parameters count, and add them to the params list.\n            for(let i= 1; i <= paramsCount; i++){\n                if(!tokens[current + i] || tokens[current + i].tokenType !== 'num'){\n                    error(tokens[current], `Expected number(s) after command ${ tokenType }.`);\n                    current += paramsCount;\n                    return;\n                }\n\n                params.push(Number(tokens[current + i].value));\n            }\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        pathData.commands.push({\n            command: tokens[current].tokenType as EPathDataCommand,\n            params,\n        });\n\n        current += paramsCount + 1;\n\n        if(paramsCount <= 0) return;\n\n        // If the command is followed by multiple sets of coordinates, the subsequent pairs are treated as implicit commands.\n        const nextTokens: IPathDataToken[] = [];\n\n        // Add all 'next params' to the list.\n        while(tokens[current]?.tokenType === 'num'){\n            nextTokens.push(tokens[current]);\n            current++;\n        }\n\n        // Validate next params count.\n        if(nextTokens.length % paramsCount !== 0){\n            error(nextTokens[nextTokens.length - 1], `Expected a number.`);\n            return;\n        }\n\n        const nextCommand = (isRelative ? nextParamsTokenType.toLowerCase() : nextParamsTokenType.toUpperCase()) as EPathDataCommand;\n\n        // Add them to the commands list.\n        for(let i= 0; i < nextTokens.length; i += paramsCount){\n            const nextParams: number[] = [];\n            for(let j = 0; j < paramsCount; j++){\n                nextParams.push(Number(nextTokens[i + j].value));\n            }\n            pathData.commands.push({\n                command: nextCommand,\n                params: nextParams,\n            });\n        }\n    };\n\n    const parseNext = () => {\n        const token = tokens[current];\n\n        const isRelative = token.tokenType.toLowerCase() === token.tokenType;\n\n        switch (token.tokenType){\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.LineToRel:{\n                parseCommand(2, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                parseCommand(0, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:\n            case EPathDataCommand.LineToHorizontalRel:\n            case EPathDataCommand.LineToVerticalAbs:\n            case EPathDataCommand.LineToVerticalRel:{\n                parseCommand(1, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:\n            case EPathDataCommand.CubicCurveToRel:{\n                parseCommand(6, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToAbs:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                parseCommand(4, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                parseCommand(2, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:\n            case EPathDataCommand.ArcRel:{\n                parseCommand(7, token.tokenType, isRelative);\n                break;\n            }\n\n            default: {\n                error(tokens[current], `Wrong path command.`);\n                current++;\n                break;\n            }\n        }\n    };\n\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    parseCommand(2, EPathDataCommand.LineToAbs, tokens[0].tokenType === EPathDataCommand.MoveToRel);\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        parseNext();\n    }\n\n    return pathData;\n};", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\n\nconst numberToString = (num: number, decimalPlaces = 2) : string => {\n\n    if(Number.isInteger(num)) return num.toString();\n\n    const _num = setDecimalPlaces(num, decimalPlaces).toString();\n    const parts = _num.split('.');\n    const intPart = parts[0];\n    const decimalPart = parts[1];\n\n    if(intPart === '0') return `.${ decimalPart }`;\n    if(intPart === '-0') return `-.${ decimalPart }`;\n\n    return _num;\n};\n\nconst combineParams = (params: number[], decimalPlaces: number) => {\n    if(!params || params.length <= 0) return '';\n\n    let combined = numberToString(params[0], decimalPlaces);\n\n    for(let i= 1; i<params.length; i++){\n        const param = params[i];\n        const str = numberToString(param, decimalPlaces);\n        if(param < 0){\n            combined +=  str;\n        }\n        else{\n            combined += ` ${ str }`;\n        }\n    }\n\n    return combined;\n};\n\nexport const pathDataMinify = (pathData: IPathData, decimalPlaces = 2) : string => {\n\n    let d = '';\n    let lastCommand: EPathDataCommand|null = null;\n\n    for(const item of pathData.commands){\n\n        // handle cases like 'L80 0' ----> 'H80', 'L0 80' ----> 'V80'\n        if(item.command === EPathDataCommand.LineToAbs){\n            if(item.params[0] === 0){\n                d += `V${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalAbs;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `H${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalAbs;\n                continue;\n            }\n        }\n\n        // handle cases like 'l80 0' ----> 'h80' & 'l0 80' ----> 'v80'\n        if(item.command === EPathDataCommand.LineToRel){\n            if(item.params[0] === 0){\n                d += `v${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalRel;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `h${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalRel;\n                continue;\n            }\n        }\n\n        // handle cases like 'c0 0 10 0 10 10' ---> 's10 0 10 10'\n        if(item.command === EPathDataCommand.CubicCurveToRel &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToAbs.toLowerCase() &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToSmoothAbs.toLowerCase()){\n            if(item.params[0] === 0 && item.params[1] === 0){\n\n                const params = combineParams([\n                    item.params[2],\n                    item.params[3],\n                    item.params[4],\n                    item.params[5],\n                ], decimalPlaces);\n\n                d += `s${ params }`;\n                lastCommand = EPathDataCommand.CubicCurveToSmoothRel;\n                continue;\n            }\n        }\n\n        const canSkipCommand =\n            (lastCommand === item.command) ||\n            (lastCommand === EPathDataCommand.MoveToAbs && item.command === EPathDataCommand.LineToAbs) ||\n            (lastCommand === EPathDataCommand.MoveToRel && item.command === EPathDataCommand.LineToRel);\n\n        if(canSkipCommand){\n            if(item.params.length > 0 && item.params[0] >= 0){\n                d += ' ';\n            }\n        }\n        else{\n            d += item.command;\n        }\n\n        d += combineParams(item.params, decimalPlaces);\n\n        lastCommand = item.command;\n    }\n\n    return d.trim();\n};\n", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\nimport { pathDataMinify } from './minify';\n\nexport const pathDataToRelative = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToAbs:{\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToRel:{\n                x += commands[i].params[0];\n                y += commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] -= x;\n                x = savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                x += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] -= y;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                y += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] -= x;\n                commands[i].params[5] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                x += commands[i].params[4];\n                y += commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                x += commands[i].params[2];\n                y += commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] -= x;\n                commands[i].params[6] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                x += commands[i].params[5];\n                y += commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command lowercase\n        commands[i].command = commands[i].command.toLowerCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToAbsolute = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i]\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToRel:{\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToRel:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                x = commands[i].params[0];\n                y = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] += x;\n                x += savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                x = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] += y;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                y = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] += x;\n                commands[i].params[5] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                x = commands[i].params[4];\n                y = commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                x = commands[i].params[2];\n                y = commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] += x;\n                commands[i].params[6] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                x = commands[i].params[5];\n                y = commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command uppercase\n        commands[i].command = commands[i].command.toUpperCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToString = (pathData: IPathData, minify?: boolean, decimalPlaces = 2) : string => {\n    if(!pathData || pathData.commands.length <= 0) return '';\n\n    let d = '';\n\n    if(minify){\n        return pathDataMinify(pathData, decimalPlaces);\n    }\n\n    for(const item of pathData.commands){\n        d += item.command;\n        if(item.params.length > 0){\n            d += ` ${ item.params.map(param => Number.isInteger(param) ? param : setDecimalPlaces(param, decimalPlaces)).join(' ')} `\n        }\n        else{\n            d += ' ';\n        }\n    }\n\n    return d.trim();\n};\n\nexport const maximizeAbsolutePath = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n\n                // update y to be the same as in previous command\n                commands[i].params[1] = prev.params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n                const y = commands[i].params[0];\n\n                // update x to be the same as in previous command\n                commands[i].params[0] = prev.params[0];\n                commands[i].params.push(y);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:{\n                // prev should be Cubic B\u00E9zier Curve Abs (C)\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (C): x1,y1, x2,y2, x,y\n                commands[i].command = EPathDataCommand.CubicCurveToAbs;\n\n                // For S: (x2 y2 x y)\n                // The first control point is assumed to be the reflection\n                // of the second control point on the previous command\n                // relative to the current point.\n                // (If there is no previous command or if the previous command was not an C, c, S or s,\n                // assume the first control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[3]); // prev y2\n                commands[i].params.unshift(prev.params[2]); // prev x2\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                // prev should be Quadratic B\u00E9zier Curve Abs (Q)\n\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (Q): x1 y1 x y\n                commands[i].command = EPathDataCommand.QuadraticCurveToAbs;\n\n                // For T: (x y)\n                // The control point is assumed to be the reflection of the control point on the previous command relative to the current point.\n                // (If there is no previous command or if the previous command was not a Q, q, T or t,\n                // assume the control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[1]); // prev y2\n                commands[i].params.unshift(prev.params[0]); // prev x2\n                break;\n            }\n        }\n    }\n\n    return pathData;\n};", "import { IPathData } from './interfaces';\nimport { scan } from './scanner';\nimport { parse } from './parser';\nimport { pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { pathDataMinify } from './minify';\n\nexport const isPathValid = (d?: string): boolean => {\n    const parsed = parsePath(d);\n    return parsed.errors.length <= 0;\n};\n\n/**\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n * \u2018d\u2019 attribute contains the moveto, line, curve (both cubic and quadratic B\u00E9ziers), arc and closepath instructions.\n */\nexport const parsePath = (d?: string): IPathData => {\n    const scanResult = scan(d);\n    return parse(scanResult);\n};\n\n/**\n * Converts all path commands to relative.\n */\nexport const pathToRel = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToRelative(parsed), !beautify, decimalPlaces);\n};\n\n/**\n * Converts all path commands to absolute.\n */\nexport const pathToAbs = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToAbsolute(parsed), !beautify, decimalPlaces);\n};\n\nexport const minifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataMinify(parsed, decimalPlaces);\n};\n\nexport const beautifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(parsed, false, decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\n\nexport interface ICreateStarProps extends IPrimitiveShapeProps{\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n    type?: number;\n}\n\nexport const createStar = (props: ICreateStarProps) : SVGPathElement => {\n\n    switch (props.type){\n        case 2: {\n            return createStar2(props);\n        }\n        case 3: {\n            return createStar3(props);\n        }\n    }\n\n    return createStar1(props);\n};\n\nexport const createStar1 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n    d += dots.map(dot => `L ${ dot[0] } ${ dot[1] }`).join(' ');\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar2 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar3 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] } L ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\nimport { mod } from 'mz-math';\n\nexport interface ICreateFlowerProps extends IPrimitiveShapeProps{\n    petalsNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n}\n\nexport const createFlower = (props: ICreateFlowerProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_PETALS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const petalsNumber = Math.max(MIN_PETALS_NUMBER, Number(props.petalsNumber) || MIN_PETALS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / petalsNumber;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<petalsNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i= 0; i < dots.length; i += 2){\n        const outerDot = dots[mod(i + 1, dots.length)];\n        const innerDot2 = dots[mod(i + 2, dots.length)];\n        const outerDot2 = dots[mod(i + 3, dots.length)];\n\n        d += `C ${ outerDot[0] } ${ outerDot[1] } ${ outerDot2[0] } ${ outerDot2[1] } ${ innerDot2[0] } ${ innerDot2[1] } `;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createStar } from '../../../main/shapes/stars';\nimport { createSVG } from '../../../main/core';\nimport { getRandomHSLColorWithinRanges, hslToHex, getRandomInt } from 'mz-math';\nimport { createFlower } from '../../../main/shapes/flowers';\n\nexport const starExamples = () => {\n\n  if(!document.querySelector('[data-examples=\"star-examples\"]')) return;\n\n  try{\n\n    const $btn = document.getElementById('star-random-btn') as HTMLButtonElement;\n    const $placeholder = document.getElementById('star-ph') as HTMLDivElement;\n\n    const renderStar = () => {\n      $placeholder.innerHTML = '';\n\n      const $svg = createSVG({\n        width: 200,\n        height: 200\n      });\n\n      const hslColor = getRandomHSLColorWithinRanges(\n          0, 360, // hue range\n          60, 100, // saturation range\n          30, 50, // lightness range\n      );\n      const hex = hslToHex(hslColor); // #1c1817\n\n      const raysNumber = getRandomInt(4, 12);\n      const type = getRandomInt(1, 3);\n\n      const $star = createStar({\n        raysNumber,\n        centerX: 100,\n        centerY: 100,\n        outerRadius: type === 2 ? 80 : 100,\n        innerRadius: 50,\n        fill: hex,\n        type: type,\n      });\n\n      $svg.append($star);\n\n      $placeholder.append($svg);\n    };\n\n    $btn.addEventListener('click', () => {\n      renderStar();\n    });\n\n    renderStar();\n  }\n  catch(ex) { console.error(ex); }\n\n};\n\nexport const flowerExamples = () => {\n\n  if(!document.querySelector('[data-examples=\"flower-examples\"]')) return;\n\n  try{\n\n    const $btn = document.getElementById('flower-random-btn') as HTMLButtonElement;\n    const $placeholder = document.getElementById('flower-ph') as HTMLDivElement;\n\n    const renderflower = () => {\n      $placeholder.innerHTML = '';\n\n      const $svg = createSVG({\n        width: 200,\n        height: 200\n      });\n\n      const hslColor = getRandomHSLColorWithinRanges(\n          0, 360, // hue range\n          60, 100, // saturation range\n          30, 50, // lightness range\n      );\n      const hex = hslToHex(hslColor); // #1c1817\n\n      const petalsNumber = getRandomInt(4, 12);\n      const innerRadius = getRandomInt(2, 60);\n\n      const $flower = createFlower({\n        petalsNumber,\n        centerX: 100,\n        centerY: 100,\n        outerRadius: 100,\n        innerRadius,\n        fill: hex,\n      });\n\n      $svg.append($flower);\n\n      $placeholder.append($svg);\n    };\n\n    $btn.addEventListener('click', () => {\n      renderflower();\n    });\n\n    renderflower();\n  }\n  catch(ex) { console.error(ex); }\n\n};", "export const initMobileMenu = () => {\n    const $btn = document.getElementById('mobile-menu-btn');\n    if(!$btn) return;\n\n    $btn.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n        document.body.classList.toggle('mobile-menu-opened');\n    });\n\n    document.body.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n\n    const $sideMenu = document.getElementById('side-menu');\n    if(!$sideMenu) return;\n\n    $sideMenu.addEventListener('click', (evt) => {\n        evt.stopPropagation();\n    });\n\n    const $close = document.getElementById('mobile-menu-close-btn');\n    if(!$close) return;\n\n    $close.addEventListener('click', () => {\n        document.body.classList.remove('mobile-menu-opened');\n    });\n};\n", "const COLLAPSIBLE_STORAGE_KEY = 'side-menu';\n\ninterface ICollapsible {\n    id: string;\n    opened: boolean;\n}\n\nexport const initMenuScroll = () => {\n    const $menu = document.querySelector('.side-menu');\n    if(!$menu) return;\n\n    const path = window.location.pathname;\n    const $link = $menu.querySelector(`a[href='${ path }']`);\n    if(!$link) return;\n\n    $link.scrollIntoView({\n        block: 'center',\n    });\n};\n\nconst getStateFromStorage = (): ICollapsible[] => {\n    const data = window.localStorage.getItem(COLLAPSIBLE_STORAGE_KEY);\n    if(!data) return [];\n\n    let menu: ICollapsible[] = [];\n\n    try{\n        menu = JSON.parse(data) || [];\n    }\n    catch(ex){\n        // ...\n    }\n\n    return menu;\n};\n\nconst saveStateToStorage = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]');\n    const menu: ICollapsible[] = [];\n\n    for(const $title of $titles){\n        const id = $title.getAttribute('data-id') || '';\n        if(!id) continue;\n\n        const opened = $title.getAttribute('data-opened') === 'true';\n\n        menu.push({\n            id,\n            opened\n        });\n    }\n\n    window.localStorage.setItem(COLLAPSIBLE_STORAGE_KEY, JSON.stringify(menu));\n};\n\nconst restoreCollapsible = () => {\n    const menu = getStateFromStorage();\n    if(!Array.isArray(menu)) return;\n\n    for(const menuItem of menu){\n        const $title = document.querySelector(`.side-menu [data-id=\"${ menuItem.id }\"]`) as HTMLElement;\n        if(!$title) continue;\n\n        toggle($title, menuItem.opened, false);\n    }\n};\n\nconst toggle = ($title: HTMLElement, opened: boolean, saveToStorage: boolean) => {\n\n    $title.setAttribute('data-opened', opened.toString());\n\n    const $arrow = $title.querySelector('[data-arrow]');\n    if(!$arrow) return;\n\n    $arrow.classList.toggle('rotate-90', opened);\n    $title.nextElementSibling?.classList.toggle('hidden', !opened);\n\n    if(saveToStorage){\n        saveStateToStorage();\n    }\n};\n\nexport const initMenuCollapsible = () => {\n    const $titles = document.querySelectorAll('.side-menu [data-collapsible-title]') as NodeListOf<HTMLElement>;\n\n    for(const $title of $titles){\n        $title.addEventListener('click', () => {\n            const isOpened = $title.getAttribute('data-opened') === 'true';\n            toggle($title, !isOpened, true);\n        });\n    }\n\n    // try to restore collapsible state on page load\n    restoreCollapsible();\n};", "const MODE_STORAGE_KEY = 'mode';\n\nexport const handleDarkLightModes = () => {\n\n    const mode = window.localStorage.getItem(MODE_STORAGE_KEY) || 'light';\n    document.documentElement.classList.toggle('dark', mode === 'dark');\n\n    const $moveToDarkBtn = document.getElementById('move-to-dark-mode-btn') as HTMLButtonElement;\n    const $moveToLightBtn = document.getElementById('move-to-light-mode-btn') as HTMLButtonElement;\n\n    const moveToDark = () => {\n        document.documentElement.classList.add('dark');\n        $moveToDarkBtn.classList.add('hidden');\n        $moveToLightBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'dark');\n    };\n\n    const moveToLight = () => {\n        document.documentElement.classList.remove('dark');\n        $moveToLightBtn.classList.add('hidden');\n        $moveToDarkBtn.classList.remove('hidden');\n        window.localStorage.setItem(MODE_STORAGE_KEY, 'light');\n    };\n\n    if(mode === 'dark'){\n        moveToDark();\n    }\n    else{\n        moveToLight();\n    }\n\n    $moveToDarkBtn?.addEventListener('click', moveToDark);\n    $moveToLightBtn?.addEventListener('click', moveToLight);\n};\n", "import { ICanvas, IFillProps, IStrokeProps } from '../interfaces';\n\nconst setAttributes = ($canvas: HTMLCanvasElement, attributes: [string, string|number|undefined][]) => {\n    for(const attr of attributes){\n\n        const value = attr[1];\n        if(value === undefined) continue;\n\n        const key = attr[0];\n        $canvas.setAttribute(key, value.toString());\n    }\n};\n\nexport const setContextProps = (props: [string, string|number|undefined][], ctx: CanvasRenderingContext2D) => {\n    for(const prop of props){\n\n        const value = prop[1];\n        if(value === undefined) continue;\n\n        const key = prop[0];\n        ctx[key] = value;\n    }\n};\n\nexport const canvas = (props: ICanvas) => {\n\n    const $canvas: HTMLCanvasElement = document.createElement('canvas');\n\n    setAttributes($canvas, [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n        ['title', props.title],\n        ['tabindex', props.tabindex],\n        ['role', props.role],\n        ['aria-label', props.ariaLabel],\n    ]);\n\n    // Used to make the canvas accessible by providing fallback text\n    // to be displayed when the media doesn't load\n    // or the user is unable to experience it as intended\n    if(props.fallback){\n        $canvas.textContent = props.fallback;\n    }\n\n    const ctx =\n        typeof $canvas.getContext === 'function' ?\n            $canvas.getContext('2d', props.contextAttributes) :\n            null;\n\n    $canvas.width = props.width;\n    $canvas.height = props.height;\n\n    return { ctx, $canvas };\n};\n\nexport const stroke = (props: IStrokeProps, ctx: CanvasRenderingContext2D) => {\n    setContextProps([\n        ['lineWidth', props.lineWidth],\n        ['strokeStyle', props.strokeStyle],\n        ['lineCap', props.lineCap],\n        ['lineJoin', props.lineJoin],\n        ['miterLimit', props.miterLimit],\n        ['lineDashOffset', props.lineDashOffset],\n    ],ctx);\n\n    if(props.lineDashSegments){\n        ctx.setLineDash(props.lineDashSegments);\n    }\n};\n\nexport const fill = (props: IFillProps, ctx: CanvasRenderingContext2D) => {\n\n    if(props.fillStyle !== undefined){\n        ctx.fillStyle = props.fillStyle;\n    }\n\n    setContextProps([\n        ['shadowOffsetX', props.shadowOffsetX],\n        ['shadowOffsetY', props.shadowOffsetY],\n        ['shadowBlur', props.shadowBlur],\n        ['shadowColor', props.shadowColor],\n    ],ctx);\n};", "import { fill, stroke } from '../canvas';\nimport {\n    IPolynomialProps,\n    IRectProps,\n    ICircleProps,\n    ILineProps,\n} from '../../interfaces';\n\n/**\n * Draw a line.\n */\nexport const line = (props: ILineProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    ctx.save();\n\n    ctx.beginPath();\n    ctx.moveTo(x1, y1);\n    ctx.lineTo(x2, y2);\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a line, and optionally draw it.\n */\nexport const linePath = (props: ILineProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x1, y1, x2, y2 } = props;\n\n    const path = new Path2D();\n\n    path.moveTo(x1, y1);\n    path.lineTo(x2, y2);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a rectangle, including a rectangle with rounded corners.\n * Can also \"clear\" a rectangular space.\n */\nexport const rect = (props: IRectProps, ctx: CanvasRenderingContext2D) => {\n\n    const { x, y, w, h} = props;\n\n    if(props.clear){\n        ctx.clearRect(x, y, w, h);\n        return;\n    }\n\n    if(props.radii){\n        ctx.save();\n\n        fill(props, ctx);\n        stroke(props, ctx);\n\n        ctx.beginPath();\n\n        // @ts-ignore\n        ctx.roundRect(x, y, w, h, props.radii)\n        if(props.fillStyle){\n            ctx.fill();\n        }\n\n        if(props.strokeStyle){\n            ctx.stroke();\n        }\n\n        ctx.restore();\n        return;\n    }\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fillRect(x, y, w, h);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.strokeRect(x, y, w, h);\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a rectangle, and optionally draw it.\n */\nexport const rectPath = (props: IRectProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { x, y, w, h} = props;\n\n    const path = new Path2D();\n\n    if(props.radii){\n        // @ts-ignore\n        path.roundRect(x, y, w, h, props.radii)\n    }\n    else{\n        path.rect(x, y, w, h);\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomial = (props: IPolynomialProps, ctx: CanvasRenderingContext2D) => {\n\n    const { points } = props;\n\n    ctx.save();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.beginPath();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            ctx.moveTo(point[0], point[1]);\n        }\n        else{\n            ctx.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        ctx.closePath();\n    }\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Used to draw polynomials like triangles etc.\n */\nexport const polynomialPath = (props: IPolynomialProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n\n    const { points } = props;\n\n    const path = new Path2D();\n\n    for(let i= 0; i<points.length; i++) {\n        const point = points[i];\n\n        if(i === 0){\n            path.moveTo(point[0], point[1]);\n        }\n        else{\n            path.lineTo(point[0], point[1]);\n        }\n    }\n\n    if(props.closed){\n        path.closePath();\n    }\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n\n/**\n * Draw a circle, or it's segment.\n */\nexport const circle = (props: ICircleProps, ctx: CanvasRenderingContext2D) => {\n    const { cx, cy,r} = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    ctx.save();\n\n    ctx.beginPath();\n\n    fill(props, ctx);\n    stroke(props, ctx);\n\n    ctx.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(props.fillStyle){\n        ctx.fill();\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke();\n    }\n\n    ctx.restore();\n};\n\n/**\n * Get Path2D of a circle or its segment, and optionally draw it.\n */\nexport const circlePath = (props: ICircleProps, ctx?: CanvasRenderingContext2D) : Path2D => {\n    const { cx, cy, r } = props;\n\n    const startAngleRad = props.startAngleRad === undefined ? 0 : props.startAngleRad;\n    const endAngleRad = props.endAngleRad === undefined ? 2 * Math.PI : props.endAngleRad;\n\n    const path = new Path2D();\n\n    path.arc(cx, cy, r, startAngleRad, endAngleRad, props.counterclockwise);\n\n    if(!ctx) return path;\n\n    ctx.save();\n\n    if(props.fillStyle){\n        fill(props, ctx);\n        ctx.fill(path);\n    }\n\n    if(props.strokeStyle){\n        stroke(props, ctx);\n        ctx.stroke(path);\n    }\n\n    ctx.restore();\n\n    return path;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};\n\n// --------------- NORMAL --------------------------\n\nexport const v2GetNormal = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity): Vector2 => {\n    const sub = v2Sub(vector2, vector1);\n    return [\n        -setDecimalPlaces(sub[1], decimalPlaces),\n        setDecimalPlaces(sub[0], decimalPlaces)\n    ];\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\nimport { isNumber } from '../other';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n    const res1 = linearEquation(equation1, decimalPlaces);\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n    const res2 = linearEquation(equation2, decimalPlaces);\n\n    const res: Vector = [];\n\n    if(isNumber(res1)){\n        res.push(res1);\n    }\n\n    if(isNumber(res2)){\n        res.push(res2);\n    }\n\n    return res;\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { ICircle, IPolygon, IRect, Matrix2, Vector2 } from '../types';\nimport { mod } from './other';\nimport { v2GetNormal, v2DotProduct } from './linear-algebra/vector';\n\n/**\n * Rectangles collision detection.\n * Rectangles should not be rotated.\n * The algorithm works by ensuring there is no gap between any of the 4 sides of the rectangles.\n * Any gap means a collision does not exist.\n * Returns true if collision is detected.\n */\nexport const rectCollide = (rect1: IRect, rect2: IRect) : boolean => {\n    return rect1.x <= rect2.x + rect2.w &&\n            rect1.x + rect1.w >= rect2.x &&\n            rect1.y <= rect2.y + rect2.h &&\n            rect1.h + rect1.y >= rect2.y;\n};\n\n/**\n * Circles collision detection.\n * This algorithm works by taking the center points of the two circles\n * and ensuring the distance between the center points\n * are less than the two radii added together.\n * Returns true if collision is detected.\n */\nexport const circleCollide = (circle1: ICircle, circle2: ICircle) => {\n    const dx = Math.abs(circle1.cx - circle2.cx);\n    const dy = Math.abs(circle1.cy - circle2.cy);\n    const distance = Math.sqrt(dx * dx + dy * dy);\n    return distance <= circle1.r + circle2.r;\n};\n\n//-------------------- Separating Axis Theorem (SAT) Collision detection -------------------------\n\nconst getEdges = (poly: IPolygon) : Matrix2[] => {\n    const edges: Matrix2[] = [];\n\n    for(let i= 0; i<poly.length; i++){\n        const nextIndex = mod(i + 1, poly.length);\n        const edge: Matrix2 = [poly[i], poly[nextIndex]];\n        edges.push(edge);\n    }\n\n    return edges;\n};\n\nexport const convexPolygonsCollide = (poly1: IPolygon, poly2: IPolygon): boolean => {\n    const edges: Matrix2[] = [];\n\n    // collect polygon edges, and combine then into a single array\n    edges.push(...getEdges(poly1));\n    edges.push(...getEdges(poly2));\n\n    // for each edge, find the normal vector and project both polygons onto it\n    for (const edge of edges) {\n        const normal = v2GetNormal(edge[0], edge[1]);\n        const p1Proj = projectPolygon(poly1, normal);\n        const p2Proj = projectPolygon(poly2, normal);\n\n        // Check if the projections overlap\n        const isOverlap = p1Proj.max >= p2Proj.min && p2Proj.max >= p1Proj.min;\n\n        // Check if the projections overlap; if not, the polygons do not collide\n        if (!isOverlap) return false;\n    }\n\n    // If all tests pass, the polygons overlap and collide\n    return true;\n};\n\n/**\n * Project every polygon point onto the normal.\n * Then find min and max.\n */\nconst projectPolygon = (polygon: IPolygon, normal: Vector2): { min: number, max: number } => {\n    let min = Infinity;\n    let max = -Infinity;\n\n    // Project each vertex of the polygon onto the axis\n    for (const vertex of polygon) {\n        const projection = v2DotProduct(vertex, normal);\n        min = Math.min(min, projection);\n        max = Math.max(max, projection);\n    }\n\n    return { min, max };\n};", "export interface IAnimationProps {\n    duration?: number;\n    callback: (result: IAnimationResult) => void;\n    restartOnResize?: boolean;\n    resizeCallback?: (_entries: ResizeObserverEntry[], _observer: ResizeObserver) => void;\n}\n\nexport interface IAnimationResult {\n    start: () => void;\n    stop: () => void;\n    pause: () => void;\n    resume: () => void;\n    restart: () => void;\n    isAnimating: () => boolean;\n    getStartTime: () => number|undefined;\n    getElapsedTime: () => number|undefined;\n    getPercent: () => number|undefined;\n    getResizeObserver: () => ResizeObserver|undefined;\n}\n\nexport const animate = (props: IAnimationProps) : IAnimationResult => {\n\n    const _duration = props.duration !== undefined ? props.duration : Infinity;\n\n    let startTime: number|undefined = undefined; // in milliseconds\n    let animationId: number|undefined = undefined;\n\n    // the time elapsed since the start of the animation (in milliseconds)\n    let elapsed: number|undefined = undefined;\n    let previousTimeStamp: number|undefined = undefined;\n\n    let animating = false;\n    let observer: ResizeObserver|undefined = undefined;\n\n    // -------------------- COMMANDS ---------------------\n\n    const stop = () => {\n        startTime = undefined;\n        elapsed = undefined;\n        previousTimeStamp = undefined;\n        animating = false;\n\n        /*if(observer !== undefined){\n            observer.disconnect();\n            observer = undefined;\n        }*/\n\n        if(animationId === undefined) return;\n        window.cancelAnimationFrame(animationId);\n    };\n\n    const restart = () => {\n        stop();\n        start();\n    };\n\n    const pause = () => {\n        animating = false;\n    };\n\n    const resume = () => {\n        animating = true;\n    };\n\n    /**\n     * Animation Step.\n     * @param {number} timeStamp in milliseconds\n     */\n    const step = (timeStamp: DOMHighResTimeStamp) => {\n\n        if (startTime === undefined) {\n            startTime = timeStamp;\n        }\n\n        // the time elapsed since the start of the animation (in milliseconds)\n        elapsed = timeStamp - startTime;\n\n        if (animating && previousTimeStamp !== timeStamp && typeof props.callback === 'function') {\n\n            // do the rendering .............\n            props.callback(getResult());\n        }\n\n        if(elapsed <= _duration){\n            previousTimeStamp = timeStamp;\n            animationId = window.requestAnimationFrame(step);\n        }\n        else{\n            stop();\n        }\n    };\n\n    const observerHandler = (_entries: ResizeObserverEntry[], _observer: ResizeObserver) => {\n        restart();\n\n        if(typeof props.resizeCallback === 'function'){\n            props.resizeCallback(_entries, _observer);\n        }\n    };\n\n    const start = () => {\n        startTime = undefined;\n        elapsed = undefined;\n        previousTimeStamp = undefined;\n        animating = true;\n\n        if(props.restartOnResize && window.ResizeObserver && observer === undefined){\n            observer = new ResizeObserver(observerHandler);\n            observer.observe(document.body, { box: 'border-box' });\n        }\n        else{\n            animationId = window.requestAnimationFrame(step);\n        }\n    };\n\n    // --------------- GET INFO ----------------------\n\n    /**\n     * the time elapsed since the start of the animation (in milliseconds)\n     */\n    const getElapsedTime = () : number|undefined => {\n        return elapsed;\n    };\n\n    const isAnimating = () => {\n        return animating;\n    };\n\n    const getStartTime = () => {\n        return startTime;\n    };\n\n    const getPercent = () => {\n        if(_duration === Infinity || elapsed === undefined) return undefined;\n        return elapsed * 100 / _duration;\n    };\n\n    const getResizeObserver = () => {\n      return observer;\n    };\n\n    const getResult = () : IAnimationResult => {\n        return {\n\n            // commands --------------\n            start,\n            stop,\n            pause,\n            resume,\n            restart,\n\n            // information -------\n            isAnimating,\n            getElapsedTime,\n            getStartTime,\n            getPercent,\n            getResizeObserver,\n        };\n    };\n\n    return getResult();\n};\n", "export const rgbaToString = (r: number, g: number, b: number, a: number) => {\n    return `rgba(${ r }, ${ g }, ${ b }, ${ a } )`;\n};", "import { Vector2 } from 'mz-math';\nimport { ISettings } from '../interfaces';\n\n// breakpoints for device resolutions -----------\nexport const SM_BREAK_POINT = 640;\nexport const MD_BREAK_POINT = 768;\nexport const LG_BREAK_POINT = 1024;\nexport const XL_BREAK_POINT = 1280;\n\nexport const getViewPortSize = () : Vector2 => {\n    const vw = Math.max(document.documentElement.clientWidth || 0, window.innerWidth || 0);\n    const vh = Math.max(document.documentElement.clientHeight || 0, window.innerHeight || 0);\n    return [vw, vh];\n};\n\nexport const getConnectionSizePerViewport = (options: ISettings, placeholderWidth: number) : number => {\n\n    const viewport = getViewPortSize();\n    const vw = viewport[0];\n\n    if(options.smConnectionSize !== undefined && vw <= SM_BREAK_POINT){\n        return options.smConnectionSize * placeholderWidth;\n    }\n\n    if(options.mdConnectionSize !== undefined && vw <= MD_BREAK_POINT){\n        return options.mdConnectionSize * placeholderWidth;\n    }\n\n    if(options.lgConnectionSize !== undefined && vw <= LG_BREAK_POINT){\n        return options.lgConnectionSize * placeholderWidth;\n    }\n\n    // --- XL ----\n    return options.connectionSize as number * placeholderWidth;\n};\n\nexport const getParticlesNumberPerViewport = (options: ISettings) : number => {\n\n    const viewport = getViewPortSize();\n    const vw = viewport[0];\n\n    if(options.smParticlesNumber !== undefined && vw <= SM_BREAK_POINT){\n        return options.smParticlesNumber;\n    }\n\n    if(options.mdParticlesNumber !== undefined && vw <= MD_BREAK_POINT){\n        return options.mdParticlesNumber;\n    }\n\n    if(options.lgParticlesNumber !== undefined && vw <= LG_BREAK_POINT){\n        return options.lgParticlesNumber;\n    }\n\n    // --- XL ----\n    return options.particlesNumber as number;\n};\n", "import { ISettings, IState } from '../interfaces';\nimport { line } from 'mz-canvas';\nimport { v2Distance } from 'mz-math';\nimport { rgbaToString } from './colors-provider';\nimport { getConnectionSizePerViewport } from './viewport-provider';\n\n/**\n * Draw connection between the shapes.\n */\nexport const drawConnections = (options: ISettings, state: IState) => {\n\n    const { particles, ctx, connectionRgbColor } = state;\n\n    const rect = options.$placeholder?.getBoundingClientRect();\n    const placeholderWidth = rect?.width || 0;\n    const maxConnectionSize = getConnectionSizePerViewport(options, placeholderWidth);\n\n    for(let i= 0; i<particles.length; i++){\n        const particle1 = particles[i];\n\n        for(let j= 0; j<particles.length; j++){\n            const particle2 = particles[j];\n\n            const distance = v2Distance(particle1.center, particle2.center);\n\n            if(distance < maxConnectionSize){\n\n                const opacity = maxConnectionSize === 0 ? 1 : (1 - distance / maxConnectionSize);\n\n                line({\n                    x1: particle1.center[0],\n                    y1: particle1.center[1],\n                    x2: particle2.center[0],\n                    y2: particle2.center[1],\n                    strokeStyle: rgbaToString(\n                        connectionRgbColor[0],\n                        connectionRgbColor[1],\n                        connectionRgbColor[2],\n                        opacity,\n                    ),\n                }, ctx);\n            }\n        }\n    }\n};", "import { IPrimitiveShapeProps } from '../interfaces';\n\n/**\n * SVG namespace that is defined in SVG v1.0 Specification\n * and subsequently added to by SVG 1.1, SVG 1.2 and SVG 2\n */\nexport const SVG_NAMESPACE= 'http://www.w3.org/2000/svg';\nexport const XMLNS_NAMESPACE = 'http://www.w3.org/2000/xmlns/';\nexport const DEFAULT_DECIMAL_PLACES = 2;\n\nexport interface ICreateSVGProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n    autoViewBox?: boolean;\n}\n\n/**\n * Create new SVG element in browser or Node.js environment.\n * In case of Node.js, JSDom document can be provided.\n */\nexport const createSVG = (props?: ICreateSVGProps) : SVGSVGElement => {\n\n    const doc = props?.document || window.document;\n    const $svg= doc.createElementNS(SVG_NAMESPACE, 'svg');\n\n    $svg.setAttributeNS(XMLNS_NAMESPACE, 'xmlns', SVG_NAMESPACE);\n\n    let viewBox = props?.viewBox;\n    if(props?.autoViewBox){\n        viewBox = `${ props?.x || 0 } ${ props?.y || 0 } ${ props?.width || 0 } ${ props?.height || 0 }`;\n    }\n\n    setAttributes($svg, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['viewBox', viewBox],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $svg;\n};\n\n/**\n * Create SVG document from string\n */\nexport const createSVGFromString = (props: {\n    document?: Document;\n    svg: string;\n}) : SVGSVGElement => {\n    const {\n        document: _document,\n        svg,\n    } = props;\n\n    const doc = _document || window.document;\n\n    const $box = doc.createElement('div');\n    $box.innerHTML = svg;\n    return $box.firstElementChild as SVGSVGElement;\n};\n\nexport const getSVGAsString = ($svg: SVGSVGElement) => {\n    return $svg.outerHTML;\n};\n\nexport const setAttributes = ($svgElement: SVGElement, attr: [string, string|number|undefined][]) => {\n    if(!$svgElement || !attr) return;\n\n    for(const pair of attr){\n        if(pair.length !== 2) continue;\n\n        const prop = pair[0];\n        if(prop === null || prop === undefined) continue;\n\n        const value = pair[1];\n        if(value === null || value === undefined) continue;\n\n        $svgElement.setAttribute(prop, value.toString());\n    }\n};\n\nexport const getCommonAttributes = (props?: IPrimitiveShapeProps) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props.id],\n        ['class', props.classes],\n        ['style', props.style],\n\n        ['stroke', props.stroke],\n        ['stroke-width', props.strokeWidth],\n        ['stroke-opacity', props.strokeOpacity],\n        ['stroke-linecap', props.strokeLinecap],\n        ['stroke-linejoin', props.strokeLinejoin],\n        ['stroke-dasharray', props.strokeDasharray],\n        ['stroke-dashoffset', props.strokeDashoffset],\n        ['stroke-miterlimit', props.strokeMiterlimit],\n\n        ['fill', props.fill],\n        ['fill-opacity', props.fillOpacity],\n        ['fill-rule', props.fillRule],\n\n        ['filter', props.filter],\n        ['mask', props.mask],\n        ['transform', props.transform],\n\n        ['vector-effect', props.vectorEffect],\n        ['shape-rendering', props.shapeRendering],\n\n        ['clip-path', props.clipPath],\n        ['clip-rule', props.clipRule],\n\n        ['opacity', props.opacity],\n        ['visibility', props.visibility],\n    ];\n};\n", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from '../core';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport interface ICreatePathProps extends IPrimitiveShapeProps{\n    d?: string;\n    pathLength?: string|number;\n}\n\nexport const createPath = (props?: ICreatePathProps) : SVGPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $path = doc.createElementNS(SVG_NAMESPACE, 'path');\n\n    if(props?.d){\n        // remove newlines and double spaces\n        props.d = props?.d.replace(/\\s\\s+/g, ' ');\n    }\n\n    setAttributes($path, [\n        ['d', props?.d],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $path;\n};\n\nexport interface ICreateRectProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    rx?: number|string;\n    ry?: number|string;\n    pathLength?: string|number;\n}\n\nexport const createRect = (props?: ICreateRectProps) : SVGRectElement => {\n    const doc = props?.document || window.document;\n\n    const $rect = doc.createElementNS(SVG_NAMESPACE, 'rect');\n\n    setAttributes($rect, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $rect;\n};\n\nexport interface ICreateCircleProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    r?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createCircle = (props?: ICreateCircleProps) : SVGCircleElement => {\n\n    const doc = props?.document || window.document;\n    const $circle = doc.createElementNS(SVG_NAMESPACE, 'circle');\n\n    setAttributes($circle, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['r', props?.r],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $circle;\n};\n\nexport interface ICreateEllipseProps extends IPrimitiveShapeProps{\n    cx?: string|number;\n    cy?: string|number;\n    rx?: string|number;\n    ry?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createEllipse = (props?: ICreateEllipseProps) : SVGEllipseElement => {\n    const doc = props?.document || window.document;\n    const $ellipse = doc.createElementNS(SVG_NAMESPACE, 'ellipse');\n\n    setAttributes($ellipse, [\n        ['cx', props?.cx],\n        ['cy', props?.cy],\n        ['rx', props?.rx],\n        ['ry', props?.ry],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $ellipse;\n};\n\nexport interface ICreateLineProps extends IPrimitiveShapeProps{\n    x1?: string|number;\n    y1?: string|number;\n    x2?: string|number;\n    y2?: string|number;\n    pathLength?: string|number;\n}\n\nexport const createLine = (props?: ICreateLineProps) : SVGLineElement => {\n    const doc = props?.document || window.document;\n    const $line = doc.createElementNS(SVG_NAMESPACE, 'line');\n\n    setAttributes($line, [\n        ['x1', props?.x1],\n        ['x2', props?.x2],\n        ['y1', props?.y1],\n        ['y2', props?.y2],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $line;\n};\n\nexport interface ICreatePolygonProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolygon = (props?: ICreatePolygonProps) : SVGPolygonElement => {\n    const doc = props?.document || window.document;\n    const $polygon = doc.createElementNS(SVG_NAMESPACE, 'polygon');\n\n    setAttributes($polygon, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polygon;\n};\n\nexport interface ICreatePolylineProps extends IPrimitiveShapeProps{\n    points?: string;\n    pathLength?: string|number;\n}\n\nexport const createPolyline = (props?: ICreatePolylineProps) : SVGPolylineElement => {\n    const doc = props?.document || window.document;\n\n    const $polyline = doc.createElementNS(SVG_NAMESPACE, 'polyline');\n\n    setAttributes($polyline, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n        ['points', props?.points],\n        ['pathLength', props?.pathLength],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $polyline;\n};\n", "export const setDecimalPlaces = (num: number, decimalPlaces: number | undefined = Infinity) => {\n    if(decimalPlaces === Infinity) return num;\n\n    if(decimalPlaces < 0){\n        decimalPlaces = 0;\n    }\n\n    const coefficient = 10 ** decimalPlaces;\n    return Math.round(num * coefficient) / coefficient;\n};", "import { Vector, Vector2, Vector3 } from '../types';\nimport { setDecimalPlaces } from './format';\nimport { v2Length, vNormalize, vDotProduct, vSub } from './linear-algebra/vector';\n\nexport const getV2Angle = (v2: Vector2, decimalPlaces = Infinity) => {\n    const angle = Math.atan2(v2[1], v2[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const setV2Angle = (v2: Vector2, newAngleRad: number, decimalPlaces = Infinity): Vector2 => {\n    const length = v2Length(v2);\n    return [\n        setDecimalPlaces(Math.cos(newAngleRad) * length, decimalPlaces),\n        setDecimalPlaces(Math.sin(newAngleRad) * length, decimalPlaces),\n    ];\n};\n\nexport const radiansToDegrees = (radians: number, decimalPlaces = Infinity) => {\n    const res = radians * (180 / Math.PI);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\nexport const degreesToRadians = (degrees: number, decimalPlaces = Infinity) => {\n    const res = degrees * (Math.PI / 180);\n    return setDecimalPlaces(res, decimalPlaces);\n};\n\n/**\n * Returns the range [0, Math.PI]\n * A = Math.acos( dot(v1, v2)/(v1.length()*v2.length()) );\n */\nexport const getVNAngleBetween = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : number => {\n    const unitVector1 = vNormalize(vector1);\n    const unitVector2 = vNormalize(vector2);\n    const dotProduct = vDotProduct(unitVector1, unitVector2);\n    const angle = Math.acos(dotProduct);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV2AngleBetween = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : number => {\n    // return getVNAngleBetween(vector1, vector2, decimalPlaces);\n    const diff = vSub(vector1, vector2);\n    const angle = Math.atan2(diff[1], diff[0]);\n    return setDecimalPlaces(angle, decimalPlaces);\n};\n\nexport const getV3AngleBetween = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : number => {\n    return getVNAngleBetween(vector1, vector2, decimalPlaces);\n};", "import { Vector, Vector2, Vector3, Vector4 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { getV2Angle, setV2Angle } from '../angle';\n\n// ------------ SUM ------------------------\n\nexport const vSum = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] + vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sum = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sum = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSum(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ SUB ------------------------\n\nexport const vSub = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) : Vector => {\n\n    const vector: Vector = [];\n\n    for(let i=0; i<vector1.length; i++){\n        vector.push(setDecimalPlaces(vector1[i] - vector2[i], decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2Sub = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector2;\n};\n\nexport const v3Sub = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vSub(vector1, vector2, decimalPlaces) as Vector3;\n};\n\n// ------------ MUL SCALAR ------------------------\n\nexport const vMulScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] * scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2MulScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vMulScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3MulScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vMulScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ DIVIDE ------------------------\n\nexport const vDivideScalar = (v: Vector, scalar: number, decimalPlaces = Infinity): Vector => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const vector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        vector.push(setDecimalPlaces(v[i] / scalar, decimalPlaces));\n    }\n\n    return vector;\n};\n\nexport const v2DivideScalar = (v2: Vector2, scalar: number, decimalPlaces = Infinity): Vector2 => {\n    return vDivideScalar(v2, scalar, decimalPlaces) as Vector2;\n};\n\nexport const v3DivideScalar = (v3: Vector3, scalar: number, decimalPlaces = Infinity): Vector3 => {\n    return vDivideScalar(v3, scalar, decimalPlaces) as Vector3;\n};\n\n// ------------ LENGTH ------------------------\n\nexport const vLength = (vector: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector.length; i++){\n        sum += vector[i] * vector[i];\n    }\n\n    return setDecimalPlaces(Math.sqrt(sum), decimalPlaces);\n};\n\nexport const v2Length = (vector: Vector2, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v3Length = (vector: Vector3, decimalPlaces = Infinity) => {\n    return vLength(vector, decimalPlaces);\n};\n\nexport const v2SetLength = (v2: Vector2, newLength: number, decimalPlaces = Infinity): Vector2 => {\n    const angle = getV2Angle(v2);\n    return [\n        setDecimalPlaces(Math.cos(angle) * newLength, decimalPlaces),\n        setDecimalPlaces(Math.sin(angle) * newLength, decimalPlaces),\n    ];\n};\n\n// ----------- DISTANCE ------------------------\n\nexport const vDistance = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v2Distance = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\nexport const v3Distance = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    const diff = vSub(vector1, vector2);\n    return vLength(diff, decimalPlaces);\n};\n\n// ------------ NORMALIZE ------------------------\n\n/**\n * Normalization creates a unit vector, which is a vector of length 1.\n */\nexport const vNormalize = (v: Vector, decimalPlaces = Infinity) : Vector => {\n    const length = vLength(v);\n    const unitVector: Vector = [];\n\n    for(let i=0; i<v.length; i++){\n        unitVector.push(length === 0 ? 0 : setDecimalPlaces(v[i] / length, decimalPlaces));\n    }\n\n    return unitVector;\n};\n\nexport const v2Normalize = (v2: Vector2, decimalPlaces = Infinity) : Vector2 => {\n    return vNormalize(v2, decimalPlaces) as Vector2;\n};\n\nexport const v3Normalize = (v3: Vector3, decimalPlaces = Infinity) : Vector3 => {\n    return vNormalize(v3, decimalPlaces) as Vector3;\n};\n\n// ------------ DOT PRODUCT ------------------------\n\nexport const vDotProduct = (vector1: Vector, vector2: Vector, decimalPlaces = Infinity) => {\n    let sum = 0;\n\n    for(let i=0; i<vector1.length; i++){\n        sum += vector1[i] * vector2[i];\n    }\n\n    return setDecimalPlaces(sum, decimalPlaces);\n};\n\nexport const v2DotProduct = (vector1: Vector2, vector2: Vector2, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\nexport const v3DotProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity) => {\n    return vDotProduct(vector1, vector2, decimalPlaces);\n};\n\n// ------------ CROSS PRODUCT ------------------------\n\n/**\n * Cross product is possible on 3D vectors only.\n * The cross product a \u00D7 b is defined as a vector c that is perpendicular (orthogonal) to both a and b.\n */\nexport const v3CrossProduct = (vector1: Vector3, vector2: Vector3, decimalPlaces = Infinity): Vector3 => {\n    return [\n        setDecimalPlaces(vector1[1] * vector2[2] - vector1[2] * vector2[1], decimalPlaces),\n        setDecimalPlaces(vector1[2] * vector2[0] - vector1[0] * vector2[2], decimalPlaces),\n        setDecimalPlaces(vector1[0] * vector2[1] - vector1[1] * vector2[0], decimalPlaces),\n    ];\n};\n\n// --------------- INIT VECTOR HELPER -----------------\n\nexport const v2 = (defaultValue = 0): Vector2 => {\n    return [defaultValue, defaultValue];\n};\n\nexport const v3 = (defaultValue = 0): Vector3 => {\n    return [defaultValue, defaultValue, defaultValue];\n};\n\nexport const v4 = (defaultValue = 0): Vector4 => {\n    return [defaultValue, defaultValue, defaultValue, defaultValue];\n};\n\nexport const vN = (N: number, defaultValue = 0): Vector => {\n\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    const vector: Vector = [];\n    for(let i=0; i<N; i++){\n        vector.push(defaultValue);\n    }\n    return vector;\n};\n\n/**\n * Initialize vector using polar coordinates\n */\nexport const v2FromPolarCoords = (distance: number, angleRad: number): Vector2 => {\n    let vector: Vector2 = [0, 0];\n    vector = v2SetLength(vector, distance);\n    return setV2Angle(vector, angleRad);\n};\n\n// --------------- EQUALITY -------------------------\n\nexport const vEqual = (vector1: Vector, vector2: Vector): boolean => {\n    if(vector1.length !== vector2.length) return false;\n\n    for(let i=0; i<vector1.length; i++){\n        if(vector1[i] !== vector2[i]) return false;\n    }\n\n    return true;\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector, Vector2, Vector3 } from '../../types';\nimport { vMulScalar, vSum, vSub, vDotProduct, vN, vEqual, vDivideScalar } from './vector';\n\n// --------------- SUM ----------------------\n\nexport const mSum = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSum(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sum = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sum = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSum(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- SUB ----------------------\n\nexport const mSub = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push(vSub(matrix1[i], matrix2[i], decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2Sub = (matrix1: Matrix2, matrix2: Matrix2, decimalPlaces = Infinity): Matrix2 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix2;\n};\n\nexport const m3Sub = (matrix1: Matrix3, matrix2: Matrix3, decimalPlaces = Infinity): Matrix3 => {\n    return mSub(matrix1, matrix2, decimalPlaces) as Matrix3;\n};\n\n// --------------- MUL SCALAR ----------------------\n\nexport const mMulScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vMulScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2MulScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mMulScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3MulScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mMulScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n// --------------- DIVIDE SCALAR ----------------------\n\nexport const mDivideScalar = (m: Matrix, scalar: number, decimalPlaces = Infinity): Matrix => {\n    if(scalar === 0){\n        throw new Error('Division by zero error.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(const v of m){\n        matrix.push(vDivideScalar(v, scalar, decimalPlaces));\n    }\n\n    return matrix;\n};\n\nexport const m2DivideScalar = (m2: Matrix2, scalar: number, decimalPlaces = Infinity): Matrix2 => {\n    return mDivideScalar(m2, scalar, decimalPlaces) as Matrix2;\n};\n\nexport const m3DivideScalar = (m3: Matrix3, scalar: number, decimalPlaces = Infinity): Matrix3 => {\n    return mDivideScalar(m3, scalar, decimalPlaces) as Matrix3;\n};\n\n\n// --------------- TRANSPOSE ----------------------\n\nexport const mTranspose = (m: Matrix): Matrix => {\n\n    const vectorsCount = m.length;\n    if(vectorsCount <= 0) return m;\n\n    const vectorLength = m[0].length;\n    if(vectorLength <= 0) return m;\n\n    const matrix: Matrix = [];\n    for(let i=0; i<vectorLength; i++){\n        matrix.push([]);\n    }\n\n    for(let i=0; i<vectorsCount; i++){\n        for(let j=0; j<vectorLength; j++){\n            matrix[j].push(m[i][j]);\n        }\n    }\n\n    return matrix;\n};\n\nexport const m2Transpose = (m2: Matrix2): Matrix => {\n    return mTranspose(m2);\n};\n\nexport const m3Transpose = (m3: Matrix3): Matrix => {\n    return mTranspose(m3);\n};\n\n// ----------------- RESET ----------------------\n\nexport const mReset = (m: Matrix, defaultValue = 0): Matrix => {\n\n    if(m.length <= 0) return [];\n\n    const res: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const size = m[i].length;\n\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            vector.push(defaultValue);\n        }\n\n        res.push(vector);\n    }\n\n    return res;\n};\n\nexport const m2Reset = (m2: Matrix2, defaultValue = 0): Matrix2 => {\n    return mReset(m2, defaultValue) as Matrix2;\n};\n\nexport const m3Reset = (m3: Matrix3, defaultValue = 0): Matrix3 => {\n    return mReset(m3, defaultValue) as Matrix3;\n};\n\n// --------------- MATRIX INIT HELPERS -----------------\n\nexport const m2x2 = (defaultValue = 0): Matrix2 => {\n    return [\n        [defaultValue, defaultValue],\n        [defaultValue, defaultValue],\n    ];\n};\n\nexport const m3x3 = (defaultValue = 0): Matrix3 => {\n    return [\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const m4x4 = (defaultValue = 0): Matrix4 => {\n    return [\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n        [defaultValue, defaultValue, defaultValue, defaultValue],\n    ];\n};\n\nexport const mNxM = (N: number, M: number, defaultValue = 0): Matrix => {\n    if(N <= 0 || M <= 0){\n        throw new Error('M and N must be positive numbers.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        matrix.push(vN(M, defaultValue));\n    }\n\n    return matrix;\n};\n\nexport const identity2 = (): Matrix2 => {\n    return [\n        [1, 0],\n        [0, 1],\n    ];\n};\n\nexport const identity3 = (): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const identity4 = (): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Identity Matrix (I).\n * M x I = I x M = M for any matrix M.\n * Identity Matrix is a special case of scale matrix.\n */\nexport const identityN = (N: number): Matrix => {\n    if(N < 0){\n        throw new Error('N must be a non-negative number.');\n    }\n\n    if(N === 0) return [];\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<N; i++){\n        const vector: Vector = [];\n        for(let j=0; j<N; j++){\n            vector.push(i === j ? 1 : 0);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n// -------------- MATRIX MANIPULATION HELPERS ------------\n\nexport const mDeepCopy = (m: Matrix): Matrix => {\n    const matrix: Matrix = [];\n\n    for(let i=0; i<m.length; i++){\n        const v = m[i];\n        const vector: Vector = [];\n        for(let j=0; j<v.length; j++){\n            vector.push(v[j]);\n        }\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\nexport const m2DeepCopy = (m2: Matrix2): Matrix2 => {\n    return mDeepCopy(m2) as Matrix2;\n};\n\nexport const m3DeepCopy = (m3: Matrix3): Matrix3 => {\n    return mDeepCopy(m3) as Matrix3;\n};\n\n// -------------- APPEND / PREPEND ROW OR COLUMN ---------------\n\nexport const mAppendCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].push(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mPrependCol = (m: Matrix, col: Vector): Matrix  => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].unshift(col[i]);\n    }\n\n    return copy;\n};\n\nexport const mAppendRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.push(row);\n    return copy;\n};\n\nexport const m2AppendRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.push(row);\n    return copy;\n};\n\nexport const m3AppendRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.push(row);\n    return copy;\n};\n\nexport const mPrependRow = (m: Matrix, row: Vector) : Matrix => {\n    const copy = mDeepCopy(m);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m2PrependRow = (m2: Matrix2, row: Vector2) : Matrix2 => {\n    const copy = m2DeepCopy(m2);\n    copy.unshift(row);\n    return copy;\n};\n\nexport const m3PrependRow = (m3: Matrix3, row: Vector3) : Matrix3 => {\n    const copy = m3DeepCopy(m3);\n    copy.unshift(row);\n    return copy;\n};\n\n// ------------ DELETE ROW OR COLUMN ----------------------------\n\nexport const mDelLastRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.pop();\n    return copy;\n};\n\nexport const mDelFirstRow = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    copy.shift();\n    return copy;\n};\n\nexport const mDelLastColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].pop();\n    }\n\n    return copy;\n};\n\nexport const mDelFirstColumn = (m: Matrix): Matrix => {\n    if(m.length <= 0) return [];\n\n    const copy = mDeepCopy(m);\n    for(let i=0; i<copy.length; i++){\n        copy[i].shift();\n    }\n\n    return copy;\n};\n\n// ----------- GET COLUMN ---------------------------\n\nexport const mGetFirstColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][0]);\n    }\n    return vector;\n};\n\nexport const mGetLastColumn = (m: Matrix) : Vector => {\n    if(m.length <= 0) return [];\n\n    const size = m[0].length;\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][size - 1]);\n    }\n    return vector;\n};\n\nexport const mGetColumn = (m: Matrix, colIndex: number) : Vector => {\n    if(m.length <= 0) return [];\n\n    const vector: Vector = [];\n    for(let i=0; i<m.length; i++){\n        vector.push(m[i][colIndex]);\n    }\n    return vector;\n};\n\n// --------------- MULTIPLICATION ------------------------\n\n/**\n * Matrix Multiplication.\n * - Matrix multiplication is not commutative: M1 x M2 !== M2 x M1\n * - Matrix multiplication is associative: A x (B x C) = (A x B) x C.\n * - A x (B + C) = A x B + A x C\n */\nexport const mMul = (matrix1: Matrix, matrix2: Matrix, decimalPlaces = Infinity): Matrix => {\n\n    const matrix: Matrix = [];\n    for(let i=0; i<matrix1.length; i++){\n        matrix.push([]);\n    }\n\n    const transposed = mTranspose(matrix2);\n\n    if(matrix.length !== transposed.length){\n        throw new Error('The number of columns in the 1st matrix must be equal to the number of rows in the 2nd matrix.');\n    }\n\n    for(let i=0; i<matrix1.length; i++){\n        const vector1 = matrix1[i];\n\n        for(let j=0; j<transposed.length; j++){\n            const vector2 = transposed[j];\n            const product = vDotProduct(vector1, vector2, decimalPlaces);\n            matrix[i].push(product);\n        }\n    }\n\n    return matrix;\n};\n\nexport const mMulVector = (matrix: Matrix, vector: Vector, decimalPlaces = Infinity): Vector => {\n\n    if(matrix.length < 0) return [];\n\n    if(matrix[0].length !== vector.length){\n        throw new Error('The number of columns in the matrix must be equal to the length of the vector.');\n    }\n\n    const res: Vector = [];\n\n    for(let i=0; i<matrix.length; i++){\n        res[i] = vDotProduct(matrix[i], vector, decimalPlaces);\n    }\n\n    return res;\n};\n\n// --------------- EQUALITY -----------------------------\n\nexport const mEqual = (matrix1: Matrix, matrix2: Matrix): boolean => {\n    if(matrix1.length !== matrix2.length) return false;\n\n    for(let i=0; i<matrix1.length; i++){\n        if(!vEqual(matrix1[i], matrix2[i])) return false;\n    }\n\n    return true;\n};\n\n// ------------------- Determinant ---------------\n\n/**\n * Returns a matrix without provided row / col.\n * If we received a matrix M (mxm) ===> returns matrix N (m-1 x m-1)\n * The matrix must be square.\n */\nconst mMinorHelper = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const matrix: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        if(i === row) continue;\n\n        const vector: Vector = [];\n\n        for(let j=0; j<size; j++){\n            if(j === col) continue;\n            vector.push(m[i][j]);\n        }\n\n        matrix.push(vector);\n    }\n\n    return matrix;\n};\n\n/**\n * Calculate matrix minor.\n */\nexport const mMinor = (m: Matrix, row: number, col: number) => {\n    const size = m.length;\n\n    if(size <= 0){\n        throw new Error('The matrix should not be empty.');\n    }\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // prepare the matrix without provided row and column\n    const matrix = mMinorHelper(m, row, col);\n\n    // calculate the matrix determinant\n    return mDeterminant(matrix);\n};\n\n/**\n * Calculate determinant for NxN matrix.\n * Matrix should be square.\n */\nexport const mDeterminant = (matrix: Matrix): number => {\n    const size = matrix.length;\n    if(size === 0) return 1;\n\n    if(size !== matrix[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return matrix[0][0];\n    if(size === 2) return m2Determinant(matrix as Matrix2);\n\n    let d = 0;\n\n    for(let i=0; i<size; i++){\n        const minor = mMinor(matrix, 0, i);\n\n        let param = matrix[0][i];\n        if(i % 2 !== 0){\n            param = -param;\n        }\n\n        d += minor * param;\n    }\n\n    return d;\n};\n\n/**\n * Calculate determinant for 2x2 matrix.\n * Matrix should be square.\n */\nexport const m2Determinant = (m2: Matrix2): number => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return m2[0][0] * m2[1][1] - m2[1][0] * m2[0][1];\n};\n\n/**\n * Calculate determinant for 3x3 matrix.\n * Matrix should be square.\n */\nexport const m3Determinant = (m3: Matrix3): number => {\n    if(m3.length !== m3[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return mDeterminant(m3);\n};\n\n// ------------------ INVERSE -----------------------\n\nexport const m2Adjugate = (m2: Matrix2): Matrix2|null => {\n    if(m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    return [\n      [m2[1][1], -m2[0][1]],\n      [-m2[1][0], m2[0][0]],\n    ];\n};\n\nexport const m3Adjugate = (m3: Matrix3) : Matrix3|null => {\n    return mAdjugate(m3) as (Matrix3|null);\n};\n\n/**\n * Adjugate is a transpose of a cofactor matrix\n */\nexport const mAdjugate = (m: Matrix): Matrix|null => {\n\n    const size = m.length;\n    if(size <= 0) return null;\n\n    if(size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    if(size === 1) return m;\n\n    if(size === 2) return m2Adjugate(m as Matrix2);\n\n    // build a cofactor matrix ----------------\n    const cofactors: Matrix = [];\n\n    for(let i=0; i<size; i++){\n        const vector: Vector = [];\n        for(let j=0; j<size; j++){\n            const minor = mMinor(m, i, j);\n            const sign = Math.pow(-1, i + j)\n            vector.push(sign * minor);\n        }\n        cofactors.push(vector);\n    }\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    return mTranspose(cofactors);\n};\n\n/**\n * Singular Matrix = a square matrix that does not have a matrix inverse.\n * A matrix is singular iff its determinant is 0.\n */\nexport const isSingularMatrix = (m: Matrix) => {\n    if(m.length > 0 && m.length !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = mDeterminant(m);\n    return d === 0;\n};\n\n/**\n * Square matrix A (nxn) is invertible is there is another square matrix B (nxn) so AxB = BxA = I\n * For A (2x2) matrix, the inverse is:\n * (1 / (determinant(A))) * adj(A)\n */\nexport const m2Inverse = (m2: Matrix2, decimalPlaces = Infinity): (Matrix2 | null) => {\n    if(m2.length > 0 && m2.length !== m2[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    const d = m2Determinant(m2);\n    if(d === 0) return null;\n\n    const adj = m2Adjugate(m2);\n    if(adj === null) return null;\n\n    return m2DivideScalar(adj, d, decimalPlaces);\n};\n\nexport const m3Inverse = (m3: Matrix3, decimalPlaces = Infinity): (Matrix3 | null) => {\n    return mInverse(m3, decimalPlaces) as (Matrix3|null);\n};\n\nexport const mInverse = (m: Matrix, decimalPlaces = Infinity): (Matrix | null) => {\n    const size = m.length;\n\n    if(size > 0 && size !== m[0].length){\n        throw new Error('The matrix must be square.');\n    }\n\n    // find a determinant ----------------------\n    const d = mDeterminant(m);\n\n    // find an Adjugate - a transpose of a cofactor matrix\n    const adj = mAdjugate(m);\n    if(adj === null) return null;\n\n    return mDivideScalar(adj, d, decimalPlaces);\n};", "import { Matrix2, Matrix3, Matrix4, Matrix, Vector2, Vector3, Vector4 } from '../../types';\nimport { v2Normalize, v3MulScalar, v3Normalize } from './vector';\nimport { mMulVector, mMul } from './matrix';\nimport { setDecimalPlaces } from '../format';\n\n/*\nAny 2D affine transformation can be decomposed\ninto a rotation, followed by a scaling, followed by a\nshearing, and followed by a translation.\n---------------------------------------------------------\nAffine matrix = translation x shearing x scaling x rotation\n */\n\n// ----------------- CSS -------------------------------------\n\n/**\n * Matrix 2D in non-homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2ToCSS = (m: Matrix2) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, 0, 0)`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix\n */\nexport const m2hToCSS = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix(${ a }, ${ b }, ${ c }, ${ d }, ${ tx }, ${ ty })`;\n};\n\n/**\n * Matrix 2D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m2hToCSS3d = (m: Matrix3) : string => {\n    const a = m[0][0];\n    const b = m[1][0];\n    const c = m[0][1];\n    const d = m[1][1];\n    const tx = m[0][2];\n    const ty = m[1][2];\n\n    return `matrix3d(${ a }, ${ b }, 0, 0, ${ c }, ${ d }, 0, 0, 0, 0, 1, 0, ${ tx }, ${ ty }, 0, 1)`;\n};\n\n/**\n * Matrix 3D in homogeneous coordinates to CSS matrix3d() function\n * https://developer.mozilla.org/en-US/docs/Web/CSS/transform-function/matrix3d\n */\nexport const m3hToCSS3d = (m: Matrix4) : string => {\n\n    return `matrix3d(\n        ${ m[0][0] }, ${ m[0][1] }, ${ m[0][2] }, ${ m[0][3] },\n        ${ m[1][0] }, ${ m[1][1] }, ${ m[1][2] }, ${ m[1][3] },\n        ${ m[2][0] }, ${ m[2][1] }, ${ m[2][2] }, ${ m[2][3] },\n        ${ m[3][0] }, ${ m[3][1] }, ${ m[3][2] }, ${ m[3][3] }\n    )`;\n};\n\n// ---------------- TRANSLATION MATRICES ----------------------\n\nexport const m2Translation = (position: Vector2, decimalPlaces = Infinity): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, 1],\n        [setDecimalPlaces(position[0], decimalPlaces), setDecimalPlaces(position[1], decimalPlaces)],\n    ];\n};\n\nexport const m3Translation = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n        [\n            setDecimalPlaces(position[0], decimalPlaces),\n            setDecimalPlaces(position[1], decimalPlaces),\n            setDecimalPlaces(position[2], decimalPlaces)\n        ],\n    ];\n};\n\n/**\n * 2D Translation matrix in homogeneous coordinates.\n */\nexport const m2TranslationH = (position: Vector3, decimalPlaces = Infinity): Matrix3 => {\n\n    return [\n        [1, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * 3D Translation matrix in homogeneous coordinates.\n */\nexport const m3TranslationH = (position: Vector4, decimalPlaces = Infinity): Matrix4 => {\n\n    return [\n        [1, 0, 0, setDecimalPlaces(position[0], decimalPlaces)],\n        [0, 1, 0, setDecimalPlaces(position[1], decimalPlaces)],\n        [0, 0, 1, setDecimalPlaces(position[2], decimalPlaces)],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- ROTATION MATRICES -------------------------\n\n/**\n * Rotation of an angle about the origin.\n */\nexport const m2Rotation = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix2 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin],\n        [sin, cos],\n    ] :\n    [\n        [cos, sin],\n        [-sin, cos],\n    ];\n};\n\n/**\n * Rotation of an angle about the origin in homogeneous coordinates (clockwise).\n */\nexport const m2RotationH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ]:\n    [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation of an angle \"angleRad\" around the given point (transformOrigin) in homogeneous coordinates (clockwise).\n * result_vector = TranslationMatrix(x, y) * RotationMatrix() * TranslationMatrix(-x, -y) * position_vector\n */\nexport const m2RotationAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2RotationH(angleRad, isClockwise, decimalPlaces);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2RotateAroundPointH = (\n    angleRad: number,\n    transformOrigin: Vector3,\n    position: Vector3,\n    isClockwise = true,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2RotationAroundPointH(angleRad, transformOrigin, isClockwise, decimalPlaces);\n    return mMulVector(mat3h, position) as Vector3;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2Rotate = (angleRad: number, vector: Vector2, isClockwise = true, decimalPlaces = Infinity): Vector2 => {\n    const unitVector = v2Normalize(vector);\n    return mMulVector(m2Rotation(angleRad, isClockwise, decimalPlaces), unitVector) as Vector2;\n};\n\n/**\n * Rotate vector around the origin by angle \"angleRad\" (clockwise).\n */\nexport const v2RotateH = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m2RotationH(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the X axis (clockwise).\n */\nexport const m3RotationX = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [1, 0, 0],\n        [0, cos, -sin],\n        [0, sin, cos],\n    ] :\n    [\n        [1, 0, 0],\n        [0, cos, sin],\n        [0, -sin, cos],\n    ];\n};\n\n/**\n * Rotation around the X axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationXH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [1, 0, 0, 0],\n            [0, cos, -sin, 0],\n            [0, sin, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [1, 0, 0, 0],\n            [0, cos, sin, 0],\n            [0, -sin, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateX = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationX(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Y axis (clockwise).\n */\nexport const m3RotationY = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, 0, sin],\n        [0, 1, 0],\n        [-sin, 0, cos],\n    ] :\n    [\n        [cos, 0, -sin],\n        [0, 1, 0],\n        [sin, 0, cos],\n    ];\n};\n\n/**\n * Rotation around the Y axis (clockwise) - in homogeneous coordinates\n */\nexport const m3RotationYH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n            [cos, 0, sin, 0],\n            [0, 1, 0, 0],\n            [-sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ] :\n        [\n            [cos, 0, -sin, 0],\n            [0, 1, 0, 0],\n            [sin, 0, cos, 0],\n            [0, 0, 0, 1],\n        ];\n};\n\nexport const v3RotateY = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationY(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n/**\n * Rotation around the Z axis (clockwise).\n */\nexport const m3RotationZ = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix3 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0],\n        [sin, cos, 0],\n        [0, 0, 1],\n    ] : [\n        [cos, sin, 0],\n        [-sin, cos, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Rotation around the Z axis (clockwise)- in homogeneous coordinates\n */\nexport const m3RotationZH = (angleRad: number, isClockwise = true, decimalPlaces = Infinity): Matrix4 => {\n\n    const cos = setDecimalPlaces(Math.cos(angleRad), decimalPlaces);\n    const sin = setDecimalPlaces(Math.sin(angleRad), decimalPlaces);\n\n    return isClockwise ? [\n        [cos, -sin, 0, 0],\n        [sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ] : [\n        [cos, sin, 0, 0],\n        [-sin, cos, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\nexport const v3RotateZ = (angleRad: number, vector: Vector3, isClockwise = true, decimalPlaces = Infinity): Vector3 => {\n    const unitVector = v3Normalize(vector);\n    return mMulVector(m3RotationZ(angleRad, isClockwise, decimalPlaces), unitVector) as Vector3;\n};\n\n// ---------------- SCALE MATRICES -------------\n\n/**\n * Get matrix for arbitrary scaling pivot point.\n * result_vector = TranslationMatrix(x, y) * ScaleMatrix() * TranslationMatrix(-x, -y) * scale_vector\n */\nexport const m2ScaleAtPointHMatrix = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    decimalPlaces = Infinity): Matrix3 => {\n\n    const translation = m2TranslationH(transformOrigin, decimalPlaces);\n    const rotation = m2ScaleH(scaleVector);\n    const translationBack = m2TranslationH(v3MulScalar(transformOrigin, -1), decimalPlaces);\n    const temp1 = mMul(translation, rotation);\n    return mMul(temp1, translationBack) as Matrix3;\n};\n\nexport const m2ScaleAtPointH = (\n    scaleVector: Vector3,\n    transformOrigin: Vector3,\n    point: Vector3,\n    decimalPlaces = Infinity): Vector3 => {\n\n    const mat3h = m2ScaleAtPointHMatrix(scaleVector, transformOrigin, decimalPlaces);\n    return mMulVector(mat3h, point) as Vector3;\n};\n\nexport const m2Scale = (scaleVector: Vector2): Matrix2 => {\n    return [\n        [scaleVector[0], 0],\n        [0, scaleVector[1]],\n    ];\n};\n\nexport const v2Scale = (scaleVector: Vector2, vector: Vector2): Vector2 => {\n    return mMulVector(m2Scale(scaleVector), vector) as Vector2;\n};\n\n/**\n * homogeneous coordinates\n */\nexport const m2ScaleH = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, 1],\n    ];\n};\n\nexport const m3Scale = (scaleVector: Vector3): Matrix3 => {\n    return [\n        [scaleVector[0], 0, 0],\n        [0, scaleVector[1], 0],\n        [0, 0, scaleVector[2]],\n    ];\n};\n\nexport const m3ScaleH = (scaleVector: Vector4): Matrix4 => {\n    return [\n        [scaleVector[0], 0, 0, 0],\n        [0, scaleVector[1], 0, 0],\n        [0, 0, scaleVector[2], 0],\n        [0, 0, 0, 1]\n    ];\n};\n\nexport const v3Scale = (scaleVector: Vector3, vector: Vector3): Vector3 => {\n    return mMulVector(m3Scale(scaleVector), vector) as Vector3;\n};\n\n/**\n * Stretch, parallel to the x-axis.\n */\nexport const m2ScaleX = (scale: number): Matrix2 => {\n    return [\n        [scale, 0],\n        [0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the x-axis - homogeneous coordinates\n */\nexport const m2ScaleXH = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleX = (scale: number): Matrix3 => {\n    return [\n        [scale, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in x-direction\n */\nexport const m3ScaleXH = (scale: number): Matrix4 => {\n    return [\n        [scale, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleY = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in y-direction\n */\nexport const m3ScaleYH = (scale: number): Matrix => {\n    return [\n        [1, 0, 0, 0],\n        [0, scale, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZ = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, scale],\n    ];\n};\n\n/**\n * Stretch in z-direction\n */\nexport const m3ScaleZH = (scale: number): Matrix4 => {\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, scale, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis.\n */\nexport const m2ScaleY = (scale: number): Matrix2 => {\n    return [\n        [1, 0],\n        [0, scale],\n    ];\n};\n\n/**\n * Stretch, parallel to the y-axis - homogeneous coordinates\n */\nexport const m2ScaleYH = (scale: number): Matrix3 => {\n    return [\n        [1, 0, 0],\n        [0, scale, 0],\n        [0, 0, 1],\n    ];\n};\n\n// ---------------- REFLECTION MATRICES -------------------------\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOrigin = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin.\n */\nexport const m2ReflectionOriginH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about the origin in non-homogeneous coordinates\n */\nexport const m3ReflectionOrigin = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, -1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection about the origin in homogeneous coordinates\n */\nexport const m3ReflectionOriginH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection about y=-x\n */\nexport const m2ReflectionYmX = (): Matrix2 => {\n\n    return [\n        [0, -1],\n        [-1, 0],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionX = (): Matrix2 => {\n\n    return [\n        [1, 0],\n        [0, -1],\n    ];\n};\n\n/**\n * Reflection in the x-axis.\n */\nexport const m2ReflectionXH = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection in the y-axis.\n */\nexport const m2ReflectionY = (): Matrix2 => {\n\n    return [\n        [-1, 0],\n        [0, 1],\n    ];\n};\n\nexport const m2ReflectionYH = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionYZ = (): Matrix3 => {\n\n    return [\n        [-1, 0, 0],\n        [0, 1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to YZ plane in homogeneous coordinates\n */\nexport const m3ReflectionYZH = (): Matrix4 => {\n\n    return [\n        [-1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXZ = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, -1, 0],\n        [0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XZ plane in homogeneous coordinates\n */\nexport const m3ReflectionXZH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, -1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in non-homogeneous coordinates\n */\nexport const m3ReflectionXY = (): Matrix3 => {\n\n    return [\n        [1, 0, 0],\n        [0, 1, 0],\n        [0, 0, -1],\n    ];\n};\n\n/**\n * Reflection relative to XY plane in homogeneous coordinates\n */\nexport const m3ReflectionXYH = (): Matrix4 => {\n\n    return [\n        [1, 0, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, -1, 0],\n        [0, 0, 0, 1],\n    ];\n};\n\n// ---------------- SHEARING MATRICES -------------------------\n\n\n/**\n * Shearing in y-axis, with x-axis fixed with (0,1) moving to (factor, 1)\n */\nexport const m2ShearingY = (factor: number): Matrix2 => {\n\n    return [\n        [1, factor],\n        [0, 1],\n    ];\n};\n\n/**\n * Shearing in x-axis, with y-axis fixed with (1,0) moving to (1, factor)\n */\nexport const m2ShearingX = (factor: number): Matrix2 => {\n\n    return [\n        [1, 0],\n        [factor, 1],\n    ];\n};", "import { setDecimalPlaces } from './format';\n\n/**\n * Returns a random number in the [min,max] range.\n */\nexport const getRandom = (min: number, max: number, decimalPlaces = Infinity): number => {\n    return setDecimalPlaces(Math.random() * (max - min) + min, decimalPlaces);\n};\n\n/**\n * Returns a random integer number in the [min,max] range.\n */\nexport const getRandomInt = (min: number, max: number): number => {\n    return Math.floor(Math.random() * (max - min + 1) + min);\n};\n\nexport const getRandomBoolean = () => Math.random() < 0.5;\n\n/* eslint-disable  @typescript-eslint/no-explicit-any */\nexport const getRandomItemFromArray = (array: any[]) => {\n    const randomIndex = getRandomInt(0, array.length - 1);\n    return array[randomIndex];\n};", "export const mod = (n: number, m: number) => {\n    return ((n % m) + m) % m;\n};\n\n/**\n * Convert range [a, b] to [c, d].\n * f(x) = (d - c) * (x - a) / (b - a) + c\n */\nexport const convertRange = (x: number, a: number, b: number, c: number, d: number) => {\n    return (d - c) * (x - a) / (b - a) + c;\n};\n\n/**\n * Check if 2 ranges [a,b] and [c,d] overlap.\n */\nexport const doRangesOverlap = (a: number, b: number, c: number, d: number) => {\n    return Math.max(a, c) <= Math.min(b, d) ;\n};\n\n// eslint-disable-next-line\nexport const isNumber = (value: any) => {\n    return !isNaN(parseFloat(value)) && isFinite(value);\n};\n", "export const stringToNumber = (value: string|undefined|null|number, defaultNumber: number) => {\n    if(value === undefined || value === null) return defaultNumber;\n    const res = Number(value) ?? defaultNumber;\n    return isNaN(res) ? defaultNumber : res;\n};", "import { setDecimalPlaces } from './format';\nimport { Vector2, Vector3 } from '../types';\n\n/**\n * u(x) and v(x) are functions ---------->\n *\n * dx(u + v) = dx(u) + dx(v)\n * dx(u - v) = dx(u) - dx(v)\n * dx(u * v) = dx(u) * v + u * dx(v)\n * dx(u / v) = (dx(u) * v - u * dx(v)) / (v ^ 2), when v(x) != 0\n */\n\n// ------------------ Derivatives of Polynomial ---------------------------\n\n/**\n * y = 3x+2\n * dxPolynomial(10, [[3, 1], [2, 0]])\n */\nexport const dxPolynomial = (x: number, polynomial: number[][], decimalPlaces = Infinity) => {\n    let res = 0;\n\n    for(const part of polynomial){\n        if(part.length !== 2) return NaN;\n\n        const coeff = part[0];\n        const power = part[1];\n        res += coeff * power * Math.pow(x, power - 1);\n    }\n\n    return setDecimalPlaces(res, decimalPlaces);\n}\n\n// ---------------------- Bezier Curves ---------------------------\n\n/**\n * Derivative of Bezier Curve is another Bezier Curve.\n * t must min in range [0, 1]\n */\nexport const dxV2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    // The derivative: P1 * (2t-2) + (2*P3-4*P2) * t + 2 * P2\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -2 * (1 - t); // Math.pow(1 - t, 2)\n    const temp2 = 2 - 4 * t; // (1 - t) * 2 * t\n    const temp3 = 2 * t; //t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\nexport const dxV2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const dxV3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = -3 * Math.pow(1 - t, 2); //Math.pow(1 - t, 3);\n    const temp2 = 3 * (t - 1) * (3 * t - 1); //Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = 6 * t - 9 * t * t; // (1 - t) * 3 * t * t;\n    const temp4 = 3 * t * t; //t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n\n// ----------------- Derivatives of trigonometry functions ---------------------------\n\nexport const dxSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(Math.cos(x), decimalPlaces);\n};\n\nexport const dxCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-Math.sin(x), decimalPlaces);\n};\n\nexport const dxTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.cos(x) ** 2), decimalPlaces);\n};\n\n/**\n * x != Math.PI * n, where n is an integer\n */\nexport const dxCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sin(x) ** 2), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcSin = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\n/**\n * -1 < x < 1\n */\nexport const dxArcCos = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (Math.sqrt(1 - x ** 2)), decimalPlaces);\n};\n\nexport const dxArcTan = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(1 / (1 + x ** 2), decimalPlaces);\n};\n\nexport const dxArcCot = (x: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(-1 / (1 + x ** 2), decimalPlaces);\n};\n", "import { Matrix, Matrix2, Matrix3, Vector, Vector2, Vector3 } from '../../types';\nimport { m2Inverse, m3Inverse, mInverse, mMulVector, mDelLastColumn, mGetLastColumn } from '../linear-algebra/matrix';\nimport { setDecimalPlaces } from '../format';\n\n/**\n * Linear equation\n * ax + b = c\n * x = (c - b) / a; a != 0\n */\nexport const linearEquation = (equation: Vector3, decimalPlaces = Infinity) : number => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n\n    const diff = c - b;\n\n    if(a === 0 && diff === 0) return Infinity; // any number is a solution\n    if(a === 0) return NaN; // no solution\n\n    return setDecimalPlaces(diff / a, decimalPlaces);\n};\n\n/**\n * System of 2 linear equations.\n * [x, y] = inverse(Matrix of equation parameters) x (vector of equation results)\n * ---------------\n * 3x + 2y = 7\n * -6x + 6y = 6\n */\nexport const linearEquationSystem2 = (equation1: Vector3, equation2: Vector3, decimalPlaces = Infinity) : Vector2 | null => {\n    const equationParams: Matrix2 = [\n        [equation1[0], equation1[1]],\n        [equation2[0], equation2[1]],\n    ];\n\n    const inversed = m2Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector2 = [\n        equation1[2],\n        equation2[2]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector2;\n};\n\n/**\n * System of 3 linear equations.\n * ---------------------------------------\n * 3x + 2y + 5z = 7\n * -6x + 6y + 6z = 6\n * 2x + 7y - z = 4\n */\nexport const linearEquationSystem3 = (\n    equation1: Vector,\n    equation2: Vector,\n    equation3: Vector,\n    decimalPlaces = Infinity) : Vector3 | null => {\n    const equationParams: Matrix3 = [\n        [equation1[0], equation1[1], equation1[2]],\n        [equation2[0], equation2[1], equation2[2]],\n        [equation3[0], equation3[1], equation3[2]],\n    ];\n\n    const inversed = m3Inverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    const equationResults: Vector3 = [\n        equation1[3],\n        equation2[3],\n        equation3[3]\n    ];\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector3;\n};\n\n/**\n * System of N linear equations.\n */\nexport const linearEquationSystemN = (equations: Matrix, decimalPlaces = Infinity) : Vector | null => {\n    if(equations.length <= 0) return null;\n\n    const equationParams = mDelLastColumn(equations);\n\n    const inversed = mInverse(equationParams);\n    if(inversed === null) return null; // no results\n\n    // the last column of the equations matrix\n    const equationResults = mGetLastColumn(equations);\n\n    return mMulVector(inversed, equationResults, decimalPlaces) as Vector;\n};", "import { Vector } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport { linearEquation } from './linear-equations';\nimport { isNumber } from '../other';\n\n/**\n * Quadratic Equation.\n * ax^2 + bx + c = d\n */\nexport const quadraticEquation = (equation: Vector, decimalPlaces = Infinity) : Vector => {\n    const a = equation[0];\n    const b = equation[1];\n    const c = equation[2];\n    const d = equation[3];\n\n    if(a === 0){\n        // it's a linear equation -------------------------------------------\n        const res = linearEquation([b, c, d], decimalPlaces);\n        if(isNumber(res)) return [res];\n        return [];\n    }\n\n    const diff = c - d;\n\n    const discriminant = b * b - (4 * a * diff);\n\n    if(discriminant < 0){\n        return []; // no results\n    }\n\n    if(discriminant === 0){\n        return [ setDecimalPlaces(-b / (2 * a), decimalPlaces) ]; // 1 result\n    }\n\n    // if(determinant > 0) ---> 2 results\n    const t1 = 2 * a;\n    const t2 = Math.sqrt(discriminant);\n\n    return [\n        setDecimalPlaces((-b + t2) / t1, decimalPlaces),\n        setDecimalPlaces((-b - t2) / t1, decimalPlaces),\n    ];\n};", "import { IBBox, Vector, Vector2, Vector3 } from '../../types';\nimport { setDecimalPlaces } from '../format';\nimport {\n    dxV2CubicBezierCurve,\n    dxV2QuadraticBezierCurve,\n    dxV3CubicBezierCurve,\n    dxV3QuadraticBezierCurve\n} from '../derivative';\nimport { v2Normalize, v3Normalize } from '../linear-algebra/vector';\nimport { linearEquation } from '../equations/linear-equations';\nimport { quadraticEquation } from '../equations/quadratic-equations';\nimport { isNumber } from '../other';\n\n/**\n * B\u00E9zier Curves\n * quadratic: y = P1 * (1-t)\u00B2 + P2 * 2 * (1-t)t + P3 * t\u00B2\n * t in range [0, 1]\n */\n\n// -------------------- GET POINT ON CURVE --------------------------\n\n/**\n * Get a point on a quadratic B\u00E9zier curve as a function of time.\n */\nexport const v2QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3QuadraticBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 2);\n    const temp2 = (1 - t) * 2 * t;\n    const temp3 = t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * centerControlPoint[0] + temp3 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * centerControlPoint[1] + temp3 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * centerControlPoint[2] + temp3 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n/**\n * Get a point on a cubic B\u00E9zier curve as a function of time.\n */\nexport const v2CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n    ];\n};\n\nexport const v3CubicBezierCurve = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n\n    const temp1 = Math.pow(1 - t, 3);\n    const temp2 = Math.pow(1 - t, 2) * 3 * t;\n    const temp3 = (1 - t) * 3 * t * t;\n    const temp4 = t * t * t;\n\n    return [\n        setDecimalPlaces(temp1 * startControlPoint[0] + temp2 * center1ControlPoint[0] + temp3 * center2ControlPoint[0] + temp4 * endControlPoint[0], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[1] + temp2 * center1ControlPoint[1] + temp3 * center2ControlPoint[1] + temp4 * endControlPoint[1], decimalPlaces),\n        setDecimalPlaces(temp1 * startControlPoint[2] + temp2 * center1ControlPoint[2] + temp3 * center2ControlPoint[2] + temp4 * endControlPoint[2], decimalPlaces),\n    ];\n};\n\n// -------------------- TANGENT --------------------------\n\n/**\n * Tangent indicates the direction of travel at specific points along the B\u00E9zier curve,\n * and is literally just the first derivative of our curve.\n */\nexport const v2QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3QuadraticBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    centerControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3QuadraticBezierCurve(t, startControlPoint, centerControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\nexport const v2CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n    const dxVector = dxV2CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v2Normalize(dxVector, decimalPlaces);\n};\n\nexport const v3CubicBezierCurveTangent = (\n    t: number,\n    startControlPoint: Vector3,\n    center1ControlPoint: Vector3,\n    center2ControlPoint: Vector3,\n    endControlPoint: Vector3,\n    decimalPlaces = Infinity\n) : Vector3 => {\n    const dxVector = dxV3CubicBezierCurve(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n    return v3Normalize(dxVector, decimalPlaces);\n};\n\n// -------------------- NORMAL --------------------------\n\n/**\n * Normal is a vector that runs at a right angle to the direction of the curve, and is typically of length 1.\n * To find it, we take the normalised tangent vector, and then rotate it by a 90 degrees.\n */\nexport const v2QuadraticBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2QuadraticBezierCurveTangent(t, startControlPoint, centerControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\nexport const v2CubicBezierCurveNormal = (\n    t: number,\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2 => {\n\n    const tangent = v2CubicBezierCurveTangent(t, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint, decimalPlaces);\n    return [-tangent[1], tangent[0]];\n};\n\n// -------------------- EXTREMA --------------------------\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2QuadraticBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector => {\n\n   /*\n    (-2 * (1 - t)) * startControlPoint[0] + (2 - 4 * t) * centerControlPoint[0] + (2 * t) * endControlPoint[0]\n    2 * t * startControlPoint[0] - 4 * t * centerControlPoint[0] + 2 * t * endControlPoint[0] - 2 * startControlPoint[0] + 2 * centerControlPoint[0]\n    t * (2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0]) + (- 2 * startControlPoint[0] + 2 * centerControlPoint[0])\n    */\n\n    const a1 = 2  * startControlPoint[0] - 4 * centerControlPoint[0] + 2 * endControlPoint[0];\n    const b1 = -2 * startControlPoint[0] + 2 * centerControlPoint[0];\n    const equation1: Vector3 = [a1, b1, 0];\n    const res1 = linearEquation(equation1, decimalPlaces);\n\n    const a2 = 2  * startControlPoint[1] - 4 * centerControlPoint[1] + 2 * endControlPoint[1];\n    const b2 = -2 * startControlPoint[1] + 2 * centerControlPoint[1];\n    const equation2: Vector3 = [a2, b2, 0];\n    const res2 = linearEquation(equation2, decimalPlaces);\n\n    const res: Vector = [];\n\n    if(isNumber(res1)){\n        res.push(res1);\n    }\n\n    if(isNumber(res2)){\n        res.push(res2);\n    }\n\n    return res;\n};\n\n/**\n * Find maxima and minima by solving the equation B'(t) = 0\n * Returns result in [0, 1] range.\n */\nexport const v2CubicBezierCurveExtrema = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : Vector2|null => {\n\n    const a1 = -3  * startControlPoint[0] + 9 * center1ControlPoint[0] - 9 * center2ControlPoint[0] + 3 * endControlPoint[0];\n    const b1 = 6  * startControlPoint[0] - 12 * center1ControlPoint[0] + 6 * center2ControlPoint[0];\n    const c1 = -3  * startControlPoint[0] + 3 * center1ControlPoint[0];\n    const equation1: Vector = [a1, b1, c1, 0];\n\n    const a2 = -3  * startControlPoint[1] + 9 * center1ControlPoint[1] - 9 * center2ControlPoint[1] + 3 * endControlPoint[1];\n    const b2 = 6  * startControlPoint[1] - 12 * center1ControlPoint[1] + 6 * center2ControlPoint[1];\n    const c2 = -3  * startControlPoint[1] + 3 * center1ControlPoint[1];\n    const equation2: Vector = [a2, b2, c2, 0];\n\n    // Any value between 0 and 1 is a root that matters for B\u00E9zier curves, anything below or above that is irrelevant (because B\u00E9zier curves are only defined over the interval [0,1]).\n    const res1 = quadraticEquation(equation1, decimalPlaces).filter(num => num >= 0 && num <= 1);\n    const res2 = quadraticEquation(equation2, decimalPlaces).filter(num => num >= 0 && num <= 1);\n\n    const res = [...res1, ...res2];\n    if(res.length === 2){\n        return [...res1, ...res2] as Vector2;\n    }\n\n    return null;\n};\n\n// -------------------- BOUNDING BOX --------------------------\n\nexport const v2QuadraticBezierBBox = (\n    startControlPoint: Vector2,\n    centerControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2QuadraticBezierCurveExtrema(startControlPoint, centerControlPoint, endControlPoint);\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2QuadraticBezierCurve(percent, startControlPoint, centerControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x);\n        maxX = Math.max(maxX, x);\n\n        minY = Math.min(minY, y);\n        maxY = Math.max(maxY, y);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\nexport const v2CubicBezierBBox = (\n    startControlPoint: Vector2,\n    center1ControlPoint: Vector2,\n    center2ControlPoint: Vector2,\n    endControlPoint: Vector2,\n    decimalPlaces = Infinity\n) : IBBox => {\n\n    const extrema = v2CubicBezierCurveExtrema(startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint) || [];\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    for(const percent of extrema){\n        const point = v2CubicBezierCurve(percent, startControlPoint, center1ControlPoint, center2ControlPoint, endControlPoint);\n\n        const x = point[0];\n        const y = point[1];\n\n        minX = Math.min(minX, x ?? Infinity);\n        maxX = Math.max(maxX, x ?? -Infinity);\n\n        minY = Math.min(minY, y ?? Infinity);\n        maxY = Math.max(maxY, y ?? -Infinity);\n    }\n\n    minX = setDecimalPlaces(Math.min(minX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    maxX = setDecimalPlaces(Math.max(maxX, startControlPoint[0], endControlPoint[0]), decimalPlaces);\n    minY = setDecimalPlaces(Math.min(minY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n    maxY = setDecimalPlaces(Math.max(maxY, startControlPoint[1], endControlPoint[1]), decimalPlaces);\n\n    return {\n        x: minX,\n        y: minY,\n        w: Math.abs(maxX - minX),\n        h: Math.abs(maxY - minY),\n        x2: maxX,\n        y2: maxY,\n    }\n};\n\n\n", "import { Vector2 } from '../types';\nimport { v2Sub } from './linear-algebra/vector';\nimport { getV2Angle } from './angle';\nimport { convertRange } from './other';\n\n/**\n * Circle Equation\n * x^2 + y^2 = radius^2\n * ----------------------\n * Circle Parametric Equation\n * x(t) = radius * cos(t)\n * y(t) = radius * sin(t)\n * t is the parameter = angle\n */\nexport const circleMovement = (center: Vector2, angle: number, radius: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius,\n        center[1] + Math.sin(angle) * radius\n    ];\n};\n\n/**\n * Circle Movement After Mouse.\n * Mouse Positions:\n * - pageX/Y coordinates are relative to the top left corner of the whole rendered page (including parts hidden by scrolling),\n * - screenX and screenY: Relative to the top left of the physical screen/monitor, this reference point only moves if you increase or decrease the number of monitors or the monitor resolution.\n * - clientX/Y coordinates are relative to the top left corner of the visible part of the page, \"seen\" through browser window.\n * - offsetX and offsetY are relative to the parent container,\n */\nexport const circleMovementAfterMouse = (\n    mouse: Vector2,\n    center: Vector2,\n    radius: number\n): Vector2 => {\n\n    const vector = v2Sub(mouse, center);\n\n    let angle = getV2Angle(vector);\n\n    // convert the angle from the range [0, Math.PI*2] to the range [0, Math.PI]\n    angle = convertRange(angle, 0, Math.PI*2, 0, Math.PI);\n\n    return circleMovement(center, angle, radius);\n};\n\n/**\n * Ellipse Equation\n * (x - centerX)^2 / (radius1^2) + (y - centerY)^2 / (radius2^2) = 1\n * -----------------------------------------------------------------\n * Ellipse Parametric Equation\n * x(t) = radius1 * cos(t)\n * y(t) = radius2 * sin(t)\n * t is the parameter = angle\n */\nexport const ellipseMovement = (center: Vector2, angle: number, radius1: number, radius2: number): Vector2 => {\n    angle = angle % Math.PI * 2;\n\n    return [\n        center[0] + Math.cos(angle) * radius1,\n        center[1] + Math.sin(angle) * radius2\n    ];\n};\n\n/**\n * Sine Wave Equation (Sinusoid)\n * -----------------------------\n * const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n * amplitude = the peak deviation of the function from zero\n * frequency = number of cycles\n * phase = specifies (in radians) where in its cycle the oscillation is at t = 0.\n * think of it as \"shifting\" the starting point of the function to the right (positive p) or left (negative)\n */\nexport const sineWaveMovement = (x: number, amplitude: number, frequency: number, phase: number) : Vector2 => {\n    /*\n    example values:\n    const amplitude = 50;\n    const frequency = 0.005;\n    const phase = 0;\n    x: [0, 1000]\n     */\n    const y = amplitude * Math.sin(2 * Math.PI * frequency * x + phase);\n\n    return [x, y];\n};\n\n/**\n * Lissajous curve (Lissajous figure or Bowditch curve)\n * Parametric equation #1\n * f(t) = A * sin(k * t + m)\n * f(t) = B * sin(n * t)\n * 0 <= m <= PI/2\n * k, n >= 1\n * -----------------------\n * Parametric equation #2\n * f(t) = A * cos(k * t - m)\n * f(t) = B * cos(n * t - p)\n * -----------------------------\n * Shapes:\n * k = 1, n = 1, m = 0, p = 0 ---> line\n * A = B,  k = 1, n = 1, m = PI/2, p = PI/2 ----> circle\n * A != B, k = 1, n = 1, m = PI/2, p = PI/2 ----> ellipse\n * k = 2, n = 2, m = PI/2, p = PI/2 ----> section of a parabola\n */\nexport const lissajousCurve = (\n    width: number,\n    height: number,\n    t: number,\n    k: number,\n    n: number,\n    m: number,\n    p: number\n) :Vector2 => {\n    return [\n        width * Math.cos(k * t - m),\n        height * Math.cos(n * t - p),\n    ];\n};\n", "import { getRandom } from './random';\nimport { HSLColor, RGBColor } from '../types';\nimport { mod } from './other';\nimport { setDecimalPlaces } from './format';\n\n// ------------------------ RANDOM COLOR -------------------------------------\n\nexport const getRandomRGBColor = () : RGBColor => {\n    const hslColor = getRandomHSLColor();\n    return hslToRgb(hslColor);\n};\n\nexport const getRandomHexColor = () : string => {\n    const hslColor = getRandomHSLColor();\n    return hslToHex(hslColor);\n};\n\nexport const getRandomHSLColor = () : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given hue\n */\nexport const getRandomHSLColorWithHue = (h: number) : HSLColor => {\n    const s = getRandom(0, 100);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given saturation\n */\nexport const getRandomHSLColorWithSaturation = (s: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const l = getRandom(0, 100);\n    return [h, s, l];\n};\n\n/**\n * generate random color with the given lightness\n */\nexport const getRandomHSLColorWithLightness = (l: number) : HSLColor => {\n    const h = getRandom(1, 360);\n    const s = getRandom(0, 100);\n    return [h, s, l];\n};\n\nexport const getRandomGrayscaleHSLColor = () : HSLColor => {\n    const l = getRandom(0, 100);\n    return [0, 0, l];\n};\n\nexport const getRandomHSLColorWithinRanges = (\n    hueStart = 1, hueEnd = 360,\n    saturationStart = 0, saturationEnd = 100,\n    lightStart = 0, lightEnd = 100\n) : HSLColor => {\n    const h = getRandom(hueStart, hueEnd);\n    const s = getRandom(saturationStart, saturationEnd);\n    const l = getRandom(lightStart, lightEnd);\n    return [h, s, l];\n};\n\n// ----------------------- CONVERT COLORS --------------------------------------\n\n/**\n * helper: convert hue value to %\n * @param {number} h\n * @return {number} [0, 100] %\n */\nconst convertHueToPercent = (h : number) : number => {\n\n    // the hue value needs to be multiplied by 60 to convert it to degrees\n    h *= 60;\n\n    // if hue becomes negative, you need to add 360 to, because a circle has 360 degrees\n    if(h < 0){\n        h += 360;\n    }\n\n    // convert huw to %\n    return h * 100 / 360;\n};\n\n/**\n * get hue from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] % - we use here % instead of [0, 359] degrees\n */\nconst getHue = (r : number, g : number, b : number, min : number | undefined = undefined, max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no hue, as it's gray\n    if(min === max) return 0;\n\n    // if red is max\n    if(max === r){\n        return convertHueToPercent((g - b) / (max - min));\n    }\n\n    // if green is max\n    if(max === g){\n        return convertHueToPercent(2.0 + (b - r) / (max - min));\n    }\n\n    // if blue is max\n    if(max === b){\n        return convertHueToPercent(4.0 + (r - g) / (max - min));\n    }\n\n    return 0;\n};\n\n/**\n * get luminance from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @return {number} [0, 100] %\n */\nconst getLuminance = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // calculate the luminance value\n    // @ts-ignore\n    const l = (min + max) / 2; // [0, 1]\n\n    // return l value in %\n    return l * 100;\n};\n\n/**\n * get saturation from RGB\n * @param {number} r [0, 255]\n * @param {number} g [0, 255]\n * @param {number} b [0, 255]\n * @param {number|undefined=} min - min number of [r, g, b]\n * @param {number|undefined=} max - max number of [r, g, b]\n * @param {number|undefined=} l - luminance in [0, 100] %\n * @return {number} [0, 100] %\n */\nconst getSaturation = (\n    r : number,\n    g : number,\n    b : number,\n    min : number | undefined = undefined,\n    max : number | undefined = undefined,\n    l : number | undefined = undefined) : number => {\n\n    // find the minimum and maximum values of r, g, and b if they are not provided\n    min = (min === undefined) ? Math.min(r, g, b) : min;\n    max = (min === undefined) ? Math.max(r, g, b) : max;\n\n    // if the min and max value are the same -> no saturation, as it's gray\n    if(min === max) return 0;\n\n    // calculate luminance if it's not provided\n    l = (l === undefined) ? getLuminance(r, g, b) : l;\n\n    // check the level of luminance\n    const s = (l <= 50) ?\n        // @ts-ignore\n        ((max - min) / (max + min)) : // this formula is used when luminance <= 50%\n        // @ts-ignore\n        (max - min) / (2.0 - max - min);  // this formula is used when luminance > 50%\n\n    // return saturation in %\n    return s * 100;\n};\n\nexport const rgbToHsl = (rgb: RGBColor, decimalPlaces = Infinity): HSLColor => {\n\n    // convert rgb values to the range [0, 1]\n    const r = rgb[0] / 255;\n    const g = rgb[1] / 255;\n    const b = rgb[2] / 255;\n\n    // find the minimum and maximum values of r, g, and b\n    const min = Math.min(r, g, b);\n    const max = Math.max(r, g, b);\n\n    // calculate the luminance value in %\n    const l = getLuminance(r, g, b, min, max);\n\n    // calculate the saturation in %\n    const s = getSaturation(r, g, b, min, max, l);\n\n    // calculate the hue in % (not in degrees!)\n    const h = getHue(r, g, b, min, max);\n\n    if(h > 360 || s > 100 || l > 100){\n        return [0, 0, 100];\n    }\n\n    if(h < 0 || s < 0 || l < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(h, decimalPlaces),\n        setDecimalPlaces(s, decimalPlaces),\n        setDecimalPlaces(l, decimalPlaces),\n    ];\n};\n\n/**\n * helper: HSL to RGB\n */\nconst hslToRgbHelper = (helper1 : number, helper2 : number, colorHelper : number) : number => {\n\n    // all values need to be between 0 and 1\n    // if you get a negative value you need to add 1 to it\n    if(colorHelper < 0) colorHelper += 1;\n\n    // if you get a value above 1 you need to subtract 1 from it.\n    if(colorHelper > 1) colorHelper -= 1;\n\n    if(colorHelper * 6 < 1) return helper2 + (helper1 - helper2) * 6 * colorHelper;\n\n    if(colorHelper * 2 < 1) return helper1;\n\n    if(colorHelper * 3 < 2){\n        return helper2 + (helper1 - helper2) * (0.666 - colorHelper) * 6;\n    }\n    else{\n        return helper2;\n    }\n};\n\nexport const hslToRgb = (hsl: HSLColor, decimalPlaces = Infinity): RGBColor => {\n\n    // convert all values to [0, 1] from %\n    const h = hsl[0] / 100;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    // if there is no saturation -> it\u2019s grey\n    if(s === 0){\n        // convert the luminance from [0, 1] to [0, 255]\n        const gray = l * 255;\n        return [gray, gray, gray];\n    }\n\n    // check the level of luminance\n    const helper1 = (l < 0.5) ?\n        (l * (1.0 + s)) :\n        (l + s - l * s);\n\n    const helper2 = 2 * l - helper1;\n\n    const rHelper = h + 0.333;\n    const gHelper = h;\n    const bHelper = h - 0.333;\n\n    let r = hslToRgbHelper(helper1, helper2, rHelper);\n    let g = hslToRgbHelper(helper1, helper2, gHelper);\n    let b = hslToRgbHelper(helper1, helper2, bHelper);\n\n    // convert rgb to [0, 255]\n    r *= 255;\n    g *= 255;\n    b *= 255;\n\n    if(r > 255 || g > 255 || b > 255){\n        return [255, 255, 255];\n    }\n\n    if(r < 0 || g < 0 || b < 0){\n        return [0, 0, 0];\n    }\n\n    return [\n        setDecimalPlaces(r, decimalPlaces),\n        setDecimalPlaces(g, decimalPlaces),\n        setDecimalPlaces(b, decimalPlaces),\n    ];\n};\n\n/**\n * HSL to hex\n * hslToHex(360, 100, 50)  // [360, 100, 5] ==> \"#ff0000\" (red)\n */\nexport const hslToHex = (hsl: HSLColor) => {\n\n    if(hsl[0] > 360 || hsl[1] > 100 || hsl[2] > 100){\n        return '#ffffff';\n    }\n\n    if(hsl[0] < 0 || hsl[1] < 0 || hsl[2] < 0){\n        return '#000000';\n    }\n\n    const h = hsl[0] / 360;\n    const s = hsl[1] / 100;\n    const l = hsl[2] / 100;\n\n    let r, g, b;\n    if (s === 0) {\n        r = g = b = l; // achromatic\n    } else {\n        const hue2rgb = (p: number, q: number, t: number) => {\n            if (t < 0) t += 1;\n            if (t > 1) t -= 1;\n            if (t < 1 / 6) return p + (q - p) * 6 * t;\n            if (t < 1 / 2) return q;\n            if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n            return p;\n        };\n        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n        const p = 2 * l - q;\n        r = hue2rgb(p, q, h + 1 / 3);\n        g = hue2rgb(p, q, h);\n        b = hue2rgb(p, q, h - 1 / 3);\n    }\n    const toHex = (x: number) => {\n        const hex = Math.round(x * 255).toString(16);\n        return hex.length === 1 ? '0' + hex : hex;\n    };\n\n    return `#${toHex(r)}${toHex(g)}${toHex(b)}`;\n};\n\n// ----------------------- GET SHIFTED COLORS --------------------------------------\n\nexport const getShiftedHue = (color: HSLColor, shift = 180) : HSLColor => {\n    let hue = color[0];\n    hue += shift;\n\n    if (hue > 360 || hue < 0) {\n        hue = mod(hue, 360);\n    }\n\n    return [hue, color[1], color[2]];\n};\n\nexport const getShiftedLightness = (color: HSLColor, shift = 10) : HSLColor => {\n    let lightness = color[2];\n    lightness += shift;\n\n    if (lightness > 100 || lightness < 0) {\n        lightness = mod(lightness, 100);\n    }\n\n    return [color[0], color[1], lightness];\n};\n\nexport const getShiftedSaturation = (color: HSLColor, shift = 10) : HSLColor => {\n    let saturation = color[1];\n    saturation += shift;\n\n    if (saturation > 100) {\n        saturation -= 100;\n    }\n\n    if(saturation < 0){\n        saturation += 100;\n    }\n\n    return [color[0], saturation, color[2]];\n};\n", "/**\n * guid like '932ade5e-c515-4807-ac01-73b20ab3fb66'\n */\nexport const guid = () => {\n    return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g,  (c) => {\n        const r = Math.random() * 16 | 0;\n        return (c == 'x' ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\n\n/**\n * id like 'df4unio1opulby2uqh4'\n */\nexport const newId = () => {\n  return Math.random().toString(36).substring(2) + (new Date()).getTime().toString(36);\n};\n", "import { setDecimalPlaces } from './format';\n\n/**\n * get the side of a square inscribed in a circle\n */\nexport const getSquareInCircleSide = (radius: number, decimalPlaces = Infinity) => {\n    return setDecimalPlaces(radius * 2 / Math.sqrt(2), decimalPlaces);\n};\n", "import { EPathDataCommand, IPathDataScanResult } from './interfaces';\n\nconst NUMBER_REGEX = /^[+-]?(?=\\.\\d|\\d)(?:0|[1-9]\\d*)?(?:\\.\\d+)?(?:(?<=\\d)(?:[eE][+-]?\\d+))?/;\n\n/**\n * Path Data Scanner.\n */\nexport const scan = (pathData?: string) : IPathDataScanResult => {\n\n    const result: IPathDataScanResult = {\n        tokens: [],\n        errors: [],\n    };\n\n    if(!pathData || pathData.trim() === '') return result;\n\n    let current = 0;\n    let line = 0;\n    let col = 0;\n\n    const isEnd = () => {\n        return current >= pathData.length;\n    };\n\n    const addKeywordToken = (tokenType: EPathDataCommand) => {\n        result.tokens.push({\n            tokenType,\n            line,\n            col,\n        });\n    };\n\n    const addNumberToken = (num: number|string) => {\n        result.tokens.push({\n            tokenType: 'num',\n            value: num,\n            line,\n            col,\n        });\n    };\n\n    const addError = (msg: string) => {\n        result.errors.push({\n            line,\n            col,\n            msg,\n        });\n    };\n\n    const matchNumber = () : boolean => {\n        if(isEnd()) return false;\n        return NUMBER_REGEX.test(pathData.substring(current));\n    };\n\n    /**\n     * Scan a single token.\n     */\n    const scanToken = () => {\n        const char = pathData[current];\n\n        // Path data can contain newline characters and\n        // thus can be broken up into multiple lines to improve readability.\n        // If a newline character ---> update line and col params.\n        if(char.charAt(0) === '\\n' || char.charAt(0) === '\\r'){\n            current++;\n            col = 0;\n            line++;\n            return;\n        }\n\n        // Superfluous white space and separators such as commas can be eliminated.\n        // \"M 100 100 L 200 200\" contains unnecessary spaces and could be expressed more compactly as \"M100 100L200 200\".\n        if(/\\s/.test(char) || char === ','){\n            current++;\n            col++;\n            return;\n        }\n\n        // try to match a number\n        if(matchNumber()){\n            const matchRes = pathData.substring(current).match(NUMBER_REGEX);\n\n            if(matchRes && matchRes.length > 0){\n                const num = matchRes[0];\n                addNumberToken(num);\n\n                current += num.length;\n                col += num.length;\n                return;\n            }\n        }\n\n        switch(char){\n            case 'M': addKeywordToken(EPathDataCommand.MoveToAbs); break;\n            case 'm': addKeywordToken(EPathDataCommand.MoveToRel); break;\n            case 'Z': addKeywordToken(EPathDataCommand.ClosePathAbs); break;\n            case 'z': addKeywordToken(EPathDataCommand.ClosePathRel); break;\n            case 'L': addKeywordToken(EPathDataCommand.LineToAbs); break;\n            case 'l': addKeywordToken(EPathDataCommand.LineToRel); break;\n            case 'H': addKeywordToken(EPathDataCommand.LineToHorizontalAbs); break;\n            case 'h': addKeywordToken(EPathDataCommand.LineToHorizontalRel); break;\n            case 'V': addKeywordToken(EPathDataCommand.LineToVerticalAbs); break;\n            case 'v': addKeywordToken(EPathDataCommand.LineToVerticalRel); break;\n            case 'C': addKeywordToken(EPathDataCommand.CubicCurveToAbs); break;\n            case 'c': addKeywordToken(EPathDataCommand.CubicCurveToRel); break;\n            case 'S': addKeywordToken(EPathDataCommand.CubicCurveToSmoothAbs); break;\n            case 's': addKeywordToken(EPathDataCommand.CubicCurveToSmoothRel); break;\n            case 'Q': addKeywordToken(EPathDataCommand.QuadraticCurveToAbs); break;\n            case 'q': addKeywordToken(EPathDataCommand.QuadraticCurveToRel); break;\n            case 'T': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothAbs); break;\n            case 't': addKeywordToken(EPathDataCommand.QuadraticCurveToSmoothRel); break;\n            case 'A': addKeywordToken(EPathDataCommand.ArcAbs); break;\n            case 'a': addKeywordToken(EPathDataCommand.ArcRel); break;\n\n            default: {\n                addError(`Unexpected character ${ char }`);\n                break;\n            }\n        }\n\n        current++;\n        col++;\n    };\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        scanToken();\n    }\n\n    return result;\n};", "import { EPathDataCommand, IPathData, IPathDataScanResult, IPathDataToken } from './interfaces';\n\n/**\n * All path data instructions are expressed as one character (e.g., a moveto is expressed as an M).\n * Relative versions of all commands are available (uppercase means absolute coordinates, lowercase means relative coordinates).\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n */\nexport const parse = (scanResult: IPathDataScanResult) : IPathData => {\n\n    const pathData: IPathData = {\n        commands: [],\n        errors: scanResult.errors || [],\n    };\n\n    if(scanResult.errors.length > 0 ||\n        scanResult.tokens.length === 0) return pathData;\n\n    const { tokens, errors } = scanResult;\n\n    const error = (token: IPathDataToken, msg: string) => {\n        errors.push({\n            line: token?.line,\n            col: token?.col,\n            msg,\n        });\n    };\n\n    // https://www.w3.org/TR/SVG11/paths.html#PathDataMovetoCommands\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    if(tokens[0].tokenType !== EPathDataCommand.MoveToAbs &&\n        tokens[0].tokenType !== EPathDataCommand.MoveToRel) {\n        error(tokens[0], `A path data segment must begin with a 'moveto' command 'M' or 'm'.`);\n        return pathData;\n    }\n\n    let current = 0;\n\n    const isEnd = () => {\n        return current >= tokens.length;\n    };\n\n    const areArcFlagsValid = (tokenType: string): boolean => {\n\n        // we are checking only 'A/a' type\n        if(!tokenType || tokenType.toLowerCase() !== 'a') return true;\n\n        // 4th and 5th param should be 0 or 1\n        const val4 = (tokens[current + 4]?.value || '').toString();\n        const val5 = (tokens[current + 5]?.value || '').toString();\n\n        return (val4 === '0' || val4 === '1') && (val5 === '0' || val5 === '1');\n    };\n\n    /**\n     * https://www.w3.org/TR/SVG11/paths.html#PathData\n     */\n    const parseCommand = (paramsCount: number, nextParamsTokenType: EPathDataCommand, isRelative: boolean) => {\n\n        const tokenType = tokens[current].tokenType;\n        const params: number[] = [];\n\n        if(paramsCount > 0){\n\n            // Validate the parameters count, and add them to the params list.\n            for(let i= 1; i <= paramsCount; i++){\n                if(!tokens[current + i] || tokens[current + i].tokenType !== 'num'){\n                    error(tokens[current], `Expected number(s) after command ${ tokenType }.`);\n                    current += paramsCount;\n                    return;\n                }\n\n                params.push(Number(tokens[current + i].value));\n            }\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        // validate arc flags ------\n        if(!areArcFlagsValid(tokenType)){\n            error(tokens[current], `Arc flags must be 0 or 1.`);\n            current += paramsCount + 1;\n            return;\n        }\n\n        pathData.commands.push({\n            command: tokens[current].tokenType as EPathDataCommand,\n            params,\n        });\n\n        current += paramsCount + 1;\n\n        if(paramsCount <= 0) return;\n\n        // If the command is followed by multiple sets of coordinates, the subsequent pairs are treated as implicit commands.\n        const nextTokens: IPathDataToken[] = [];\n\n        // Add all 'next params' to the list.\n        while(tokens[current]?.tokenType === 'num'){\n            nextTokens.push(tokens[current]);\n            current++;\n        }\n\n        // Validate next params count.\n        if(nextTokens.length % paramsCount !== 0){\n            error(nextTokens[nextTokens.length - 1], `Expected a number.`);\n            return;\n        }\n\n        const nextCommand = (isRelative ? nextParamsTokenType.toLowerCase() : nextParamsTokenType.toUpperCase()) as EPathDataCommand;\n\n        // Add them to the commands list.\n        for(let i= 0; i < nextTokens.length; i += paramsCount){\n            const nextParams: number[] = [];\n            for(let j = 0; j < paramsCount; j++){\n                nextParams.push(Number(nextTokens[i + j].value));\n            }\n            pathData.commands.push({\n                command: nextCommand,\n                params: nextParams,\n            });\n        }\n    };\n\n    const parseNext = () => {\n        const token = tokens[current];\n\n        const isRelative = token.tokenType.toLowerCase() === token.tokenType;\n\n        switch (token.tokenType){\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.LineToRel:{\n                parseCommand(2, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                parseCommand(0, EPathDataCommand.LineToAbs, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:\n            case EPathDataCommand.LineToHorizontalRel:\n            case EPathDataCommand.LineToVerticalAbs:\n            case EPathDataCommand.LineToVerticalRel:{\n                parseCommand(1, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:\n            case EPathDataCommand.CubicCurveToRel:{\n                parseCommand(6, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToAbs:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                parseCommand(4, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                parseCommand(2, token.tokenType, isRelative);\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:\n            case EPathDataCommand.ArcRel:{\n                parseCommand(7, token.tokenType, isRelative);\n                break;\n            }\n\n            default: {\n                error(tokens[current], `Wrong path command.`);\n                current++;\n                break;\n            }\n        }\n    };\n\n    // A path data segment (if there is one) must begin with a \"moveto\" command.\n    parseCommand(2, EPathDataCommand.LineToAbs, tokens[0].tokenType === EPathDataCommand.MoveToRel);\n\n    /**\n     * The loop.\n     */\n    while(!isEnd()){\n        parseNext();\n    }\n\n    return pathData;\n};", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\n\nconst numberToString = (num: number, decimalPlaces = 2) : string => {\n\n    if(Number.isInteger(num)) return num.toString();\n\n    const _num = setDecimalPlaces(num, decimalPlaces).toString();\n    const parts = _num.split('.');\n    const intPart = parts[0];\n    const decimalPart = parts[1];\n\n    if(intPart === '0') return `.${ decimalPart }`;\n    if(intPart === '-0') return `-.${ decimalPart }`;\n\n    return _num;\n};\n\nconst combineParams = (params: number[], decimalPlaces: number) => {\n    if(!params || params.length <= 0) return '';\n\n    let combined = numberToString(params[0], decimalPlaces);\n\n    for(let i= 1; i<params.length; i++){\n        const param = params[i];\n        const str = numberToString(param, decimalPlaces);\n        if(param < 0){\n            combined +=  str;\n        }\n        else{\n            combined += ` ${ str }`;\n        }\n    }\n\n    return combined;\n};\n\nexport const pathDataMinify = (pathData: IPathData, decimalPlaces = 2) : string => {\n\n    let d = '';\n    let lastCommand: EPathDataCommand|null = null;\n\n    for(const item of pathData.commands){\n\n        // handle cases like 'L80 0' ----> 'H80', 'L0 80' ----> 'V80'\n        if(item.command === EPathDataCommand.LineToAbs){\n            if(item.params[0] === 0){\n                d += `V${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalAbs;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `H${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalAbs;\n                continue;\n            }\n        }\n\n        // handle cases like 'l80 0' ----> 'h80' & 'l0 80' ----> 'v80'\n        if(item.command === EPathDataCommand.LineToRel){\n            if(item.params[0] === 0){\n                d += `v${ numberToString(item.params[1], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToVerticalRel;\n                continue;\n            }\n\n            if(item.params[1] === 0){\n                d += `h${ numberToString(item.params[0], decimalPlaces) }`;\n                lastCommand = EPathDataCommand.LineToHorizontalRel;\n                continue;\n            }\n        }\n\n        // handle cases like 'c0 0 10 0 10 10' ---> 's10 0 10 10'\n        if(item.command === EPathDataCommand.CubicCurveToRel &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToAbs.toLowerCase() &&\n            lastCommand?.toLowerCase() !== EPathDataCommand.CubicCurveToSmoothAbs.toLowerCase()){\n            if(item.params[0] === 0 && item.params[1] === 0){\n\n                const params = combineParams([\n                    item.params[2],\n                    item.params[3],\n                    item.params[4],\n                    item.params[5],\n                ], decimalPlaces);\n\n                d += `s${ params }`;\n                lastCommand = EPathDataCommand.CubicCurveToSmoothRel;\n                continue;\n            }\n        }\n\n        const canSkipCommand =\n            (lastCommand === item.command) ||\n            (lastCommand === EPathDataCommand.MoveToAbs && item.command === EPathDataCommand.LineToAbs) ||\n            (lastCommand === EPathDataCommand.MoveToRel && item.command === EPathDataCommand.LineToRel);\n\n        if(canSkipCommand){\n            if(item.params.length > 0 && item.params[0] >= 0){\n                d += ' ';\n            }\n        }\n        else{\n            d += item.command;\n        }\n\n        d += combineParams(item.params, decimalPlaces);\n\n        lastCommand = item.command;\n    }\n\n    return d.trim();\n};\n", "import { EPathDataCommand, IPathData } from './interfaces';\nimport { setDecimalPlaces } from 'mz-math';\nimport { pathDataMinify } from './minify';\n\nexport const pathDataToRelative = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToAbs:{\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToRel:\n            case EPathDataCommand.LineToRel:{\n                x += commands[i].params[0];\n                y += commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] -= x;\n                x = savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                x += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] -= y;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                y += commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] -= x;\n                commands[i].params[5] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                x += commands[i].params[4];\n                y += commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] -= x;\n                commands[i].params[1] -= y;\n\n                commands[i].params[2] -= x;\n                commands[i].params[3] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                x += commands[i].params[2];\n                y += commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] -= x;\n                commands[i].params[6] -= y;\n\n                x = savedX;\n                y = savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                x += commands[i].params[5];\n                y += commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command lowercase\n        commands[i].command = commands[i].command.toLowerCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToAbsolute = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // current (x, y) pair\n    let x = commands[0].params[0];\n    let y = commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i]\n\n        switch (item.command) {\n            case EPathDataCommand.MoveToRel:{\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                mx = commands[i].params[0];\n                my = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:\n            case EPathDataCommand.ClosePathRel:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToRel:\n            case EPathDataCommand.QuadraticCurveToSmoothRel:{\n                const savedX = commands[i].params[0];\n                const savedY = commands[i].params[1];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                x = commands[i].params[0];\n                y = commands[i].params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalRel:{\n                const savedX = commands[i].params[0];\n                commands[i].params[0] += x;\n                x += savedX;\n                break;\n            }\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                x = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalRel:{\n                const savedY = commands[i].params[0];\n                commands[i].params[0] += y;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                y = commands[i].params[0];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToRel:{\n                const savedX = commands[i].params[4];\n                const savedY = commands[i].params[5];\n\n                // x1 y1 - control point at the beginning of the curve\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                // x2 y2 - control point at the end of the curve\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                // At the end of the command, the new current point becomes the final (x,y) coordinate pair used in the poly-b\u00E9zier.\n                commands[i].params[4] += x;\n                commands[i].params[5] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                x = commands[i].params[4];\n                y = commands[i].params[5];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothRel:\n            case EPathDataCommand.QuadraticCurveToRel:{\n                const savedX = commands[i].params[2];\n                const savedY = commands[i].params[3];\n\n                commands[i].params[0] += x;\n                commands[i].params[1] += y;\n\n                commands[i].params[2] += x;\n                commands[i].params[3] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                x = commands[i].params[2];\n                y = commands[i].params[3];\n                break;\n            }\n\n            case EPathDataCommand.ArcRel:{\n                // (rx ry x-axis-rotation large-arc-flag sweep-flag x y)+\n                const savedX = commands[i].params[5];\n                const savedY = commands[i].params[6];\n\n                // x y\n                commands[i].params[5] += x;\n                commands[i].params[6] += y;\n\n                x += savedX;\n                y += savedY;\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                x = commands[i].params[5];\n                y = commands[i].params[6];\n                break;\n            }\n        }\n\n        // make the command uppercase\n        commands[i].command = commands[i].command.toUpperCase() as EPathDataCommand;\n    }\n\n    return pathData;\n};\n\nexport const pathDataToString = (pathData: IPathData, minify?: boolean, decimalPlaces = 2) : string => {\n    if(!pathData || pathData.commands.length <= 0) return '';\n\n    let d = '';\n\n    if(minify){\n        return pathDataMinify(pathData, decimalPlaces);\n    }\n\n    for(const item of pathData.commands){\n        d += item.command;\n        if(item.params.length > 0){\n            d += ` ${ item.params.map(param => Number.isInteger(param) ? param : setDecimalPlaces(param, decimalPlaces)).join(' ')} `\n        }\n        else{\n            d += ' ';\n        }\n    }\n\n    return d.trim();\n};\n\nexport const maximizeAbsolutePath = (pathData: IPathData): IPathData => {\n\n    const { commands } = pathData;\n\n    if(commands.length <= 0) return pathData;\n\n    // Make first M to be absolute\n    commands[0].command = EPathDataCommand.MoveToAbs;\n\n    for(let i = 1; i<commands.length; i++){\n        const item = commands[i];\n\n        switch (item.command) {\n\n            case EPathDataCommand.LineToHorizontalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n\n                // update y to be the same as in previous command\n                commands[i].params[1] = prev.params[1];\n                break;\n            }\n\n            case EPathDataCommand.LineToVerticalAbs:{\n                // prev should be line abs\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                commands[i].command = EPathDataCommand.LineToAbs;\n                const y = commands[i].params[0];\n\n                // update x to be the same as in previous command\n                commands[i].params[0] = prev.params[0];\n                commands[i].params.push(y);\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToSmoothAbs:{\n                // prev should be Cubic B\u00E9zier Curve Abs (C)\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (C): x1,y1, x2,y2, x,y\n                commands[i].command = EPathDataCommand.CubicCurveToAbs;\n\n                // For S: (x2 y2 x y)\n                // The first control point is assumed to be the reflection\n                // of the second control point on the previous command\n                // relative to the current point.\n                // (If there is no previous command or if the previous command was not an C, c, S or s,\n                // assume the first control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[3]); // prev y2\n                commands[i].params.unshift(prev.params[2]); // prev x2\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToSmoothAbs:{\n                // prev should be Quadratic B\u00E9zier Curve Abs (Q)\n\n                const prev = commands[i - 1];\n                if(!prev) continue;\n\n                // Structure for CubicCurveToAbs (Q): x1 y1 x y\n                commands[i].command = EPathDataCommand.QuadraticCurveToAbs;\n\n                // For T: (x y)\n                // The control point is assumed to be the reflection of the control point on the previous command relative to the current point.\n                // (If there is no previous command or if the previous command was not a Q, q, T or t,\n                // assume the control point is coincident with the current point.)\n                commands[i].params.unshift(prev.params[1]); // prev y2\n                commands[i].params.unshift(prev.params[0]); // prev x2\n                break;\n            }\n        }\n    }\n\n    return pathData;\n};", "import { IPathData } from './interfaces';\nimport { scan } from './scanner';\nimport { parse } from './parser';\nimport { pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { pathDataMinify } from './minify';\n\nexport const isPathValid = (d?: string): boolean => {\n    const parsed = parsePath(d);\n    return parsed.errors.length <= 0;\n};\n\n/**\n * https://www.w3.org/TR/SVG11/paths.html#PathData\n * \u2018d\u2019 attribute contains the moveto, line, curve (both cubic and quadratic B\u00E9ziers), arc and closepath instructions.\n */\nexport const parsePath = (d?: string): IPathData => {\n    const scanResult = scan(d);\n    return parse(scanResult);\n};\n\n/**\n * Converts all path commands to relative.\n */\nexport const pathToRel = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToRelative(parsed), !beautify, decimalPlaces);\n};\n\n/**\n * Converts all path commands to absolute.\n */\nexport const pathToAbs = (d?: string, beautify = false, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(pathDataToAbsolute(parsed), !beautify, decimalPlaces);\n};\n\nexport const minifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataMinify(parsed, decimalPlaces);\n};\n\nexport const beautifyPath = (d?: string, decimalPlaces = 2): string|undefined => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    return pathDataToString(parsed, false, decimalPlaces);\n};\n", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\n\nexport interface ICreateStarProps extends IPrimitiveShapeProps{\n    raysNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n    type?: number;\n}\n\nexport const createStar = (props: ICreateStarProps) : SVGPathElement => {\n\n    switch (props.type){\n        case 2: {\n            return createStar2(props);\n        }\n        case 3: {\n            return createStar3(props);\n        }\n    }\n\n    return createStar1(props);\n};\n\nexport const createStar1 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<raysNumber; i++, angle += angleDiff){\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * innerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n    d += dots.map(dot => `L ${ dot[0] } ${ dot[1] }`).join(' ');\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar2 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};\n\nexport const createStar3 = (props: ICreateStarProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_RAYS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const raysNumber = Math.max(MIN_RAYS_NUMBER, Number(props.raysNumber) || MIN_RAYS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / raysNumber;\n    const halfAngle = angleDiff / 2;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<=raysNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle + halfAngle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle + halfAngle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i = 0; i < dots.length; i += 2){\n        const dot1 = dots[i];\n        const dot2 = dots[i + 1];\n        d += `S${ dot1[0] } ${ dot1[1] } ${ dot2[0] } ${ dot2[1] } L ${ dot2[0] } ${ dot2[1] }`;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { DEFAULT_DECIMAL_PLACES } from '../core';\nimport { setDecimalPlaces } from 'mz-math';\nimport { IPrimitiveShapeProps } from '../../interfaces';\nimport { pathToRel } from '../path';\nimport { mod } from 'mz-math';\n\nexport interface ICreateFlowerProps extends IPrimitiveShapeProps{\n    petalsNumber: number;\n    centerX: number;\n    centerY: number;\n    outerRadius: number;\n    innerRadius: number;\n    decimalPlaces?: number;\n    pathLength?: string|number;\n}\n\nexport const createFlower = (props: ICreateFlowerProps) : SVGPathElement => {\n\n    const {\n        centerX, centerY,\n        outerRadius, innerRadius,\n    } = props;\n\n    const MIN_PETALS_NUMBER = 3;\n    const dots: [number, number][] = [];\n\n    const petalsNumber = Math.max(MIN_PETALS_NUMBER, Number(props.petalsNumber) || MIN_PETALS_NUMBER);\n    const decimalPlaces = (props.decimalPlaces === null || props.decimalPlaces === undefined) ? DEFAULT_DECIMAL_PLACES : props.decimalPlaces;\n\n    const angleDiff = 2 * Math.PI / petalsNumber;\n\n    for(let i= 0, angle= 1.5 * Math.PI; i<petalsNumber; i++, angle += angleDiff){\n\n        // inner circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * innerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * innerRadius, decimalPlaces),\n        ]);\n\n        // outer circle\n        dots.push([\n            setDecimalPlaces(centerX + Math.cos(angle) * outerRadius, decimalPlaces),\n            setDecimalPlaces(centerY + Math.sin(angle) * outerRadius, decimalPlaces),\n        ]);\n    }\n\n    let d = `M ${ dots[0][0] } ${ dots[0][1] } `;\n\n    for(let i= 0; i < dots.length; i += 2){\n        const outerDot = dots[mod(i + 1, dots.length)];\n        const innerDot2 = dots[mod(i + 2, dots.length)];\n        const outerDot2 = dots[mod(i + 3, dots.length)];\n\n        d += `C ${ outerDot[0] } ${ outerDot[1] } ${ outerDot2[0] } ${ outerDot2[1] } ${ innerDot2[0] } ${ innerDot2[1] } `;\n    }\n\n    d += 'Z';\n    d = pathToRel(d) || d;\n\n    const pathProps = {\n        ...props,\n        d,\n    };\n\n    return createPath(pathProps);\n};", "import { createPath } from './primitive-shapes';\nimport { IPrimitiveShapeProps } from '../../interfaces';\n\nexport const getRectPathD = (props: {\n    x: number,\n    y: number,\n    width: number,\n    height: number,\n    rx?: number,\n    ry?: number,\n}) => {\n    const {\n        x, y,\n        width, height,\n        rx: _rx,\n        ry: _ry,\n    } = props;\n\n    const rx = _rx || 0;\n    const ry = _ry || 0;\n\n    if (rx || ry){\n\n        const w = width - 2 * rx;\n        const h = height - 2 * ry;\n\n        return `M${ x + rx } ${ y }h${ w }s${ rx } 0 ${ rx } ${ ry }v${ h }s0 ${ ry } ${ -rx } ${ ry }h${ -w }s${ -rx } 0 ${ -rx } ${ -ry }v${ -h }s0 ${ -ry } ${ rx } ${ -ry }z`;\n    }\n\n    return `M${ x } ${ y }h${ width }v${ height }h${ -width }z`;\n};\n\nexport interface ICreateRectPathProps extends IPrimitiveShapeProps{\n    x: number;\n    y: number;\n    width: number;\n    height: number;\n    rx?: number;\n    ry?: number;\n}\n\nexport const createRectPath = (props: ICreateRectPathProps) : SVGPathElement => {\n\n    const pathProps = {\n        ...props,\n        d: getRectPathD({\n            x: props.x,\n            y: props.y,\n            width: props.width,\n            height: props.height,\n            rx: props.rx,\n            ry: props.ry,\n        }),\n    };\n\n    return createPath(pathProps);\n};", "import { createSVGFromString, getSVGAsString } from './core';\n\nconst MISSING_SVG_ERR = 'Either an SVG element or an SVG string must be provided.';\n\nconst formatExt = (ext?: string) : string => {\n    if(!ext || !ext.trim()) return 'svg';\n\n    return ext.trim().toLowerCase();\n};\n\n/**\n * Download file in browser environment.\n */\nexport const download = (props: {\n    $svg?: SVGSVGElement,\n    svgString?: string;\n    outfileName?: string;\n    ext?: string; // svg, png, jpg, jpeg\n}) => {\n    return new Promise<{\n        isError: boolean;\n        msg?: string;\n    }>((resolve, reject) => {\n        if(!props.$svg && !props.svgString){\n            reject({\n                isError: true,\n                msg: MISSING_SVG_ERR,\n            });\n            return;\n        }\n\n        const _svgString = props.$svg ? getSVGAsString(props.$svg) : props.svgString;\n        const svgString = `<?xml version=\"1.0\" encoding=\"UTF-8\"?>${ _svgString }`;\n\n        const formattedExt = formatExt(props.ext);\n        const formattedFileName = `${ props.outfileName || 'out'}.${ formattedExt }`;\n\n        if(formattedExt === 'svg'){\n\n            const blob = new Blob([svgString], {type : 'text/plain'});\n            const url = URL.createObjectURL(blob);\n\n            const link = document.createElement('a');\n            link.href = url;\n            link.title = '';\n            link.download = formattedFileName;\n            link.click();\n\n            URL.revokeObjectURL(url);\n            resolve({\n                isError: false,\n            });\n        }\n        else{\n            const $svg = props.$svg || createSVGFromString({\n                svg: props.svgString || '',\n            });\n\n            const $canvas = document.createElement('canvas');\n            $canvas.width = $svg.width.baseVal.value;\n            $canvas.height = $svg.height.baseVal.value;\n\n            const ctx = $canvas.getContext('2d');\n            if(!ctx){\n                reject({\n                    isError: true,\n                });\n                return;\n            }\n\n            const data = (new XMLSerializer()).serializeToString($svg);\n            const blob = new Blob([data], {type: 'image/svg+xml;charset=utf-8'});\n            const url = URL.createObjectURL(blob);\n\n            const $img = new Image();\n            $img.onload = () => {\n                ctx.clearRect(0, 0, $canvas.width, $canvas.height);\n                ctx.drawImage($img, 0, 0);\n\n                URL.revokeObjectURL(url);\n\n                $canvas.toBlob(cBlob => {\n\n                    if(!cBlob){\n                        resolve({\n                            isError: true,\n                        });\n                        return;\n                    }\n\n                    const cUrl = URL.createObjectURL(cBlob);\n                    const link = document.createElement('a');\n                    link.href = cUrl;\n                    link.title = '';\n                    link.download = formattedFileName;\n                    link.click();\n\n                    URL.revokeObjectURL(cUrl);\n\n                    resolve({\n                        isError: false,\n                    });\n                });\n            };\n\n            $img.onerror = () => {\n                resolve({\n                    isError: true,\n                });\n            };\n\n            $img.src = url;\n        }\n    });\n};", "import { getCommonAttributes, setAttributes, SVG_NAMESPACE } from './core';\nimport { IPrimitiveShapeProps } from '../interfaces';\n\nexport interface ICreateGroupProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n}\n\nexport const createGroup = (props?: ICreateGroupProps) : SVGGElement => {\n    const doc = props?.document || window.document;\n    const $g = doc.createElementNS(SVG_NAMESPACE, 'g');\n\n    setAttributes($g, [\n        ...getCommonAttributes(props),\n    ]);\n\n    return $g;\n};\n\nexport const createDefs = (props?: {\n    document?: Document;\n    id?: string;\n    classes?: string;\n}) : SVGDefsElement => {\n    const doc = props?.document || window.document;\n    const $defs = doc.createElementNS(SVG_NAMESPACE, 'defs');\n\n    setAttributes($defs, [\n        ['id', props?.id],\n        ['class', props?.classes],\n    ]);\n\n    return $defs;\n};\n\nexport interface ICreateUseProps extends IPrimitiveShapeProps{\n    href?: string;\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n}\n\nexport const createUse = (props?: ICreateUseProps) : SVGUseElement => {\n\n    const doc = props?.document || window.document;\n    const $use = doc.createElementNS(SVG_NAMESPACE, 'use');\n\n    setAttributes($use, [\n        ['href', props?.href],\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $use;\n};\n\nexport interface ICreatePatternProps extends IPrimitiveShapeProps{\n    x?: string|number;\n    y?: string|number;\n    width?: string|number;\n    height?: string|number;\n\n    href?: string;\n    patternContentUnits?: string|number;\n    patternTransform?: string;\n    patternUnits?: string;\n    preserveAspectRatio?: string;\n    viewBox?: string;\n}\n\nexport const createPattern = (props?: ICreatePatternProps) : SVGPatternElement => {\n    const doc = props?.document || window.document;\n    const $pattern = doc.createElementNS(SVG_NAMESPACE, 'pattern');\n\n    setAttributes($pattern, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['href', props?.href],\n        ['patternContentUnits', props?.patternContentUnits],\n        ['patternTransform', props?.patternTransform],\n        ['patternUnits', props?.patternUnits],\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $pattern;\n};\n\nexport interface ICreateClipPathProps extends IPrimitiveShapeProps{\n    clipPathUnits?: string;\n}\n\nexport const createClipPath = (props?: ICreateClipPathProps) : SVGClipPathElement => {\n\n    const doc = props?.document || window.document;\n    const $clipPath = doc.createElementNS(SVG_NAMESPACE, 'clipPath');\n\n    setAttributes($clipPath, [\n        ['clipPathUnits', props?.clipPathUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $clipPath;\n};\n\nexport interface ICreateMaskProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    maskContentUnits?: string;\n    maskUnits?: string;\n}\n\nexport const createMask = (props?: ICreateMaskProps) : SVGMaskElement => {\n\n    const doc = props?.document || window.document;\n    const $mask = doc.createElementNS(SVG_NAMESPACE, 'mask');\n\n    setAttributes($mask, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n        ['maskContentUnits', props?.maskContentUnits],\n        ['maskUnits', props?.maskUnits],\n        ...getCommonAttributes(props),\n    ]);\n\n    return $mask;\n};\n\nexport interface ICreateSymbolProps extends IPrimitiveShapeProps{\n    x?: number|string;\n    y?: number|string;\n    width?: number|string;\n    height?: number|string;\n    preserveAspectRatio?: string;\n    refX?: number|string;\n    refY?: number|string;\n    viewBox?: string;\n}\n\nexport const createSymbol = (props?: ICreateSymbolProps) : SVGSymbolElement => {\n\n    const doc = props?.document || window.document;\n    const $symbol = doc.createElementNS(SVG_NAMESPACE, 'symbol');\n\n    setAttributes($symbol, [\n        ['x', props?.x],\n        ['y', props?.y],\n        ['width', props?.width],\n        ['height', props?.height],\n\n        ['preserveAspectRatio', props?.preserveAspectRatio],\n        ['refX', props?.refX],\n        ['refY', props?.refY],\n        ['viewBox', props?.viewBox],\n\n        ...getCommonAttributes(props),\n    ]);\n\n    return $symbol;\n};", "export const appendOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.append($el);\n};\n\nexport const prependOnce = ($parent: SVGSVGElement|SVGElement, $el: SVGElement) => {\n    const tagName = $el.tagName.toLowerCase().trim();\n    if($parent.querySelector(tagName)) return;\n\n    $parent.prepend($el);\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute } from './convert';\nimport { EPathDataCommand } from './interfaces';\nimport {\n    degreesToRadians,\n    Matrix2, mMulVector,\n    setDecimalPlaces,\n    v2CubicBezierBBox, v2MulScalar,\n    v2QuadraticBezierBBox, v2Sum,\n    Vector2\n} from 'mz-math';\n\nexport interface IBBox {\n    x: number;\n    y: number;\n    w: number;\n    h: number;\n    x2: number;\n    y2: number;\n}\n\n/**\n * https://www.w3.org/TR/SVG11/implnote.html#ArcConversionEndpointToCenter\n */\nexport const getSVGArcCenter = (\n    startX: number,\n    startY: number,\n    rx: number,\n    ry: number,\n    angleRad: number,\n    largeArcFlag: number,\n    sweepFlag: number,\n    endX: number,\n    endY: number\n) : Vector2 | null => {\n    // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n\n    // F.6.5: Step 1 ---------------------------------------\n    const cos = Math.cos(angleRad);\n    const sin = Math.sin(angleRad);\n\n    const rotationMatrix: Matrix2 = [\n        [cos, -sin],\n        [sin, cos],\n    ];\n    const posVector1: Vector2 = [\n        (startX - endX) / 2,\n        (startY - endY) / 2,\n    ];\n\n    // Compute (x1\u2032, y1\u2032)\n    const posVector2 = mMulVector(rotationMatrix, posVector1);\n\n    // F.6.5: Step 2 ---------------------------------------\n    const rx2 = rx ** 2;\n    const ry2 = ry ** 2;\n    const posx2 = posVector2[0] ** 2;\n    const posy2 = posVector2[1] ** 2;\n\n    const t1 = rx2 * ry2 - rx2 * posy2 - ry2 * posx2;\n    const t2 = rx2 * posy2 + ry2 * posx2;\n    if(t2 === 0) return null;\n\n    const t3 = t1 / t2;\n    if(t3 < 0) return null;\n\n    let t4 = Math.sqrt(t3);\n\n    const posVector3: Vector2 = [\n        rx * posVector2[1] / ry,\n        -ry *  posVector2[0] / rx,\n    ];\n\n    if(largeArcFlag === sweepFlag){\n        t4 = -t4;\n    }\n\n    const centerVector1: Vector2 = v2MulScalar(posVector3, t4);\n\n    // F.6.5: Step 3 ---------------------------------------\n    const rotationMatrix2: Matrix2 = [\n        [cos, sin],\n        [-sin, cos],\n    ];\n\n    const centerVector2: Vector2 = mMulVector(rotationMatrix2, centerVector1) as Vector2;\n    const posVector4: Vector2 = [\n        (startX + endX) / 2,\n        (startY + endY) / 2,\n    ];\n\n    return v2Sum(centerVector2, posVector4);\n};\n\nconst getAngle = (bx: number, by: number): number => {\n    const PI2 = 2 * Math.PI;\n    const t1 = by > 0 ? 1 : -1;\n    return ((PI2 + t1 * Math.acos(bx / Math.sqrt(bx * bx + by * by))) % PI2);\n};\n\nconst formatBBox = (xmin: number, xmax: number, ymin: number, ymax: number) : IBBox => {\n    return {\n        x: xmin,\n        y: ymin,\n        w: Math.abs(ymax - ymin),\n        h: Math.abs(xmax - xmin),\n        x2: xmax,\n        y2: ymax,\n    };\n};\n\nconst getArcBoundingBox = (\n    x1: number, y1: number,\n    rx: number, ry: number,\n    angleRad: number, largeArc: boolean,\n    sweep: boolean,\n    x2: number, y2: number\n) : IBBox => {\n\n    let xmin, xmax, ymin, ymax;\n\n    /*const center = getSVGArcCenter(\n        x1,\n        y1,\n        rx,\n        ry,\n        angleRad,\nlargeArc ? 1 : 0,\nsweep ? 1 : 0,\n        x2,\n        y2\n    );\n    if(!center) return formatBBox(0, 0, 0, 0);\n\n    const cx = center[0];\n    const cy = center[1];\n    */\n\n    if (rx < 0) {\n        rx *= -1;\n    }\n\n    if (ry < 0) {\n        ry *= -1;\n    }\n\n    if (rx === 0 || ry === 0) {\n        xmin = x1 < x2 ? x1 : x2;\n        xmax = x1 > x2 ? x1 : x2;\n        ymin = y1 < y2 ? y1 : y2;\n        ymax = y1 > y2 ? y1 : y2;\n\n        return formatBBox(xmin, xmax, ymin, ymax);\n    }\n\n    const x1prime: number = Math.cos(angleRad) * (x1 - x2) / 2 + Math.sin(angleRad) * (y1 - y2) / 2;\n    const y1prime: number = -Math.sin(angleRad) * (x1 - x2) / 2 + Math.cos(angleRad) * (y1 - y2) / 2;\n\n    let radicant: number = (rx * rx * ry * ry - rx * rx * y1prime * y1prime - ry * ry * x1prime * x1prime);\n    radicant /= (rx * rx * y1prime * y1prime + ry * ry * x1prime * x1prime);\n\n    let cxPrime = 0;\n    let cyPrime = 0;\n\n    if (radicant < 0) {\n        const ratio: number = rx / ry;\n        radicant = y1prime * y1prime + x1prime * x1prime / (ratio * ratio);\n        if (radicant < 0) {\n            xmin = (x1 < x2 ? x1 : x2);\n            xmax = (x1 > x2 ? x1 : x2);\n            ymin = (y1 < y2 ? y1 : y2);\n            ymax = (y1 > y2 ? y1 : y2);\n\n            return formatBBox(xmin, xmax, ymin, ymax);\n        }\n        ry = Math.sqrt(radicant);\n        rx = ratio * ry;\n    }\n    else {\n        const factor = (largeArc == sweep ? -1 : 1) * Math.sqrt(radicant);\n        cxPrime = factor * rx * y1prime / ry;\n        cyPrime = -factor * ry * x1prime / rx;\n    }\n\n    const cx = cxPrime * Math.cos(angleRad) - cyPrime * Math.sin(angleRad) + (x1 + x2) / 2;\n    const cy = cxPrime * Math.sin(angleRad) + cyPrime * Math.cos(angleRad) + (y1 + y2) / 2;\n\n\n\n    let txMin: number, txMax: number, tyMin: number, tyMax: number;\n\n    if (angleRad === 0 || angleRad === Math.PI) {\n        xmin = cx - rx;\n        txMin = getAngle(-rx, 0);\n        xmax = cx + rx;\n        txMax = getAngle(rx, 0);\n        ymin = cy - ry;\n        tyMin = getAngle(0, -ry);\n        ymax = cy + ry;\n        tyMax = getAngle(0, ry);\n    }\n    else if (angleRad === Math.PI / 2 || angleRad === 3.0 * Math.PI / 2) {\n        xmin = cx - ry;\n        txMin = getAngle(-ry, 0);\n        xmax = cx + ry;\n        txMax = getAngle(ry, 0);\n        ymin = cy - rx;\n        tyMin = getAngle(0, -rx);\n        ymax = cy + rx;\n        tyMax = getAngle(0, rx);\n    }\n    else {\n        txMin = -Math.atan(ry * Math.tan(angleRad) / rx);\n        txMax = Math.PI - Math.atan(ry * Math.tan(angleRad) / rx);\n\n        xmin = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMin) * Math.sin(angleRad);\n        xmax = cx + rx * Math.cos(txMax) * Math.cos(angleRad) - ry * Math.sin(txMax) * Math.sin(angleRad);\n\n        // swap ------------------------\n        if (xmin > xmax) {\n            [xmin, xmax] = [xmax, xmin];\n            [txMin, txMax] = [txMax, txMin];\n        }\n\n        let tmpY = cy + rx * Math.cos(txMin) * Math.sin(angleRad) + ry * Math.sin(txMin) * Math.cos(angleRad);\n        txMin = getAngle(xmin - cx, tmpY - cy);\n        tmpY = cy + rx * Math.cos(txMax) * Math.sin(angleRad) + ry * Math.sin(txMax) * Math.cos(angleRad);\n        txMax = getAngle(xmax - cx, tmpY - cy);\n\n        tyMin = Math.atan(ry / (Math.tan(angleRad) * rx));\n        tyMax = Math.atan(ry / (Math.tan(angleRad) * rx)) + Math.PI;\n        ymin = cy + rx * Math.cos(tyMin) * Math.sin(angleRad) + ry * Math.sin(tyMin) * Math.cos(angleRad);\n        ymax = cy + rx * Math.cos(tyMax) * Math.sin(angleRad) + ry * Math.sin(tyMax) * Math.cos(angleRad);\n\n        // swap ------------------------\n        if (ymin > ymax) {\n            [ymin, ymax] = [ymax, ymin];\n            [tyMin, tyMax] = [tyMax, tyMin];\n        }\n\n        let tmpX = cx + rx * Math.cos(tyMin) * Math.cos(angleRad) - ry * Math.sin(tyMin) * Math.sin(angleRad);\n        tyMin = getAngle(tmpX - cx, ymin - cy);\n        tmpX = cx + rx * Math.cos(tyMax) * Math.cos(angleRad) - ry * Math.sin(tyMax) * Math.sin(angleRad);\n        tyMax = getAngle(tmpX - cx, ymax - cy);\n    }\n\n    let angle1 = getAngle(x1 - cx, y1 - cy);\n    let angle2 = getAngle(x2 - cx, y2 - cy);\n\n    if (!sweep){\n        [angle1, angle2] = [angle2, angle1];\n    }\n\n    let otherArc = false;\n\n    if (angle1 > angle2) {\n        // swap ------------------------\n        [angle1, angle2] = [angle2, angle1];\n        otherArc = true;\n    }\n\n    if ((!otherArc && (angle1 > txMin || angle2 < txMin)) || (otherArc && !(angle1 > txMin || angle2 < txMin))) {\n        xmin = Math.min(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > txMax || angle2 < txMax)) || (otherArc && !(angle1 > txMax || angle2 < txMax))) {\n        xmax = Math.max(x1, x2);\n    }\n\n    if ((!otherArc && (angle1 > tyMin || angle2 < tyMin)) || (otherArc && !(angle1 > tyMin || angle2 < tyMin))) {\n        ymin = Math.min(y1, y2);\n    }\n\n    if ((!otherArc && (angle1 > tyMax || angle2 < tyMax)) || (otherArc && !(angle1 > tyMax || angle2 < tyMax))) {\n        ymax = Math.max(y1, y2);\n    }\n\n    return formatBBox(xmin, xmax, ymin, ymax);\n}\n\n/**\n * Determine the coordinates of the smallest rectangle in which the path fits.\n */\nexport const getPathBBox = (d?: string, decimalPlaces = 2) : IBBox|null => {\n    if(!d || d.trim() === '') return null;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return null;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return null;\n\n    let minX = Infinity;\n    let minY = Infinity;\n    let maxX = -Infinity;\n    let maxY = -Infinity;\n\n    const max = maximizeAbsolutePath(abs);\n\n    // current (x, y) pair\n    let x = max.commands[0].params[0];\n    let y = max.commands[0].params[1];\n\n    // the latest 'M' coordinates\n    let mx = x;\n    let my = y;\n\n    for(const item of max.commands) {\n\n        switch (item.command){\n            case EPathDataCommand.MoveToAbs: {\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                mx = item.params[0];\n                my = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.ClosePathAbs:{\n                x = mx;\n                y = my;\n                break;\n            }\n\n            case EPathDataCommand.LineToAbs:{\n                minX = Math.min(minX, item.params[0]);\n                minY = Math.min(minY, item.params[1]);\n\n                maxX = Math.max(maxX, item.params[0]);\n                maxY = Math.max(maxY, item.params[1]);\n\n                x = item.params[0];\n                y = item.params[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint1: Vector2 = [item.params[0], item.params[1]];\n                const centerControlPoint2: Vector2 = [item.params[2], item.params[3]];\n                const endControlPoint: Vector2 = [item.params[4], item.params[5]];\n                const bbox = v2CubicBezierBBox(startControlPoint, centerControlPoint1, centerControlPoint2, endControlPoint);\n\n                minX = Math.min(minX, bbox.x);\n                minY = Math.min(minY, bbox.y);\n\n                maxX = Math.max(maxX, bbox.x2);\n                maxY = Math.max(maxY, bbox.y2);\n\n                x = item.params[4];\n                y = item.params[5];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                const startControlPoint: Vector2 = [x, y];\n                const centerControlPoint: Vector2 = [item.params[0], item.params[1]];\n                const endControlPoint: Vector2 = [item.params[2], item.params[3]];\n\n                const bbox = v2QuadraticBezierBBox(startControlPoint, centerControlPoint, endControlPoint);\n\n                minX = Math.min(minX, bbox.x);\n                minY = Math.min(minY, bbox.y);\n\n                maxX = Math.max(maxX, bbox.x2);\n                maxY = Math.max(maxY, bbox.y2);\n\n                x = item.params[2];\n                y = item.params[3];\n\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                const rx = item.params[0];\n                const ry = item.params[1];\n                const angleDeg = item.params[2];\n                const largeArcFlag = item.params[3];\n                const sweepFlag = item.params[4];\n                const endX = item.params[5];\n                const endY = item.params[6];\n\n                //const arcCenter = getSVGArcCenter(x, y, rx, ry, angleDeg, largeArcFlag, sweepFlag, endX, endY);\n                //console.log('arcCenter', arcCenter)\n\n                const bbox = getArcBoundingBox(x, y, rx, ry, degreesToRadians(angleDeg), largeArcFlag === 1, sweepFlag === 1, endX, endY);\n\n                minX = Math.min(minX, bbox?.x ?? 0);\n                minY = Math.min(minY, bbox?.y ?? 0);\n\n                maxX = Math.max(maxX, bbox?.x2 ?? 0);\n                maxY = Math.max(maxY, bbox?.y2 ?? 0);\n\n                x = item.params[5];\n                y = item.params[6];\n                break;\n            }\n        }\n    }\n\n    return {\n        x: setDecimalPlaces(minX, decimalPlaces),\n        y: setDecimalPlaces(minY, decimalPlaces),\n        w: setDecimalPlaces(Math.abs(maxX - minX), decimalPlaces),\n        h: setDecimalPlaces(Math.abs(maxY - minY), decimalPlaces),\n        x2: setDecimalPlaces(maxX, decimalPlaces),\n        y2: setDecimalPlaces(maxY, decimalPlaces),\n    };\n};", "import { parsePath } from './index';\nimport { maximizeAbsolutePath, pathDataToAbsolute, pathDataToRelative, pathDataToString } from './convert';\nimport { Vector3, m2RotateAroundPointH, degreesToRadians, Vector2, m2ScaleAtPointH } from 'mz-math';\nimport { EPathDataCommand } from './interfaces';\nimport { getPathBBox } from './bbox';\n\n// ---------------------- TRANSLATE ----------------------\n\nexport const translatePath = (d: string, x: number, y: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const relative = pathDataToRelative(parsed);\n    if(!relative || relative.commands.length <= 0) return d;\n\n    const mCommand = relative.commands[0];\n    mCommand.params[0] = x;\n    mCommand.params[1] = y;\n\n    return pathDataToString(relative, true, decimalPlaces);\n};\n\n// ---------------------- ROTATE -------------------------\n\nconst rotateDot = (point: Vector2, transformOrigin: Vector2, angleRad: number, decimalPlaces = 2) => {\n    return m2RotateAroundPointH(\n        angleRad,\n        [transformOrigin[0], transformOrigin[1], 1],\n        [point[0], point[1], 1],\n        true,\n        decimalPlaces\n    );\n};\n\nexport const rotatePathAroundPoint = (d: string, transformOrigin: Vector2, angleDegrees: number, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return d;\n\n    const angleRad = degreesToRadians(angleDegrees, decimalPlaces);\n\n    const max = maximizeAbsolutePath(abs);\n    for(const item of max.commands){\n\n        switch(item.command){\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                // 2 params (x, y)\n\n                // get the new position after rotation\n                const pos: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos[0];\n                item.params[1] = pos[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                // 6 parameters\n                const pos1: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot([item.params[2], item.params[3]], transformOrigin, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n\n                const pos3: Vector3 = rotateDot([item.params[4], item.params[5]], transformOrigin, angleRad, decimalPlaces);\n                item.params[4] = pos3[0];\n                item.params[5] = pos3[1];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                // 4 parameters\n                const pos1: Vector3 = rotateDot([item.params[0], item.params[1]], transformOrigin, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = rotateDot([item.params[2], item.params[3]], transformOrigin, angleRad, decimalPlaces);\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                /*const pos1: Vector3 = rotateDot(item.params[0], item.params[1], cx, cy, angleRad, decimalPlaces);\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];*/\n\n                const pos2: Vector3 = rotateDot([item.params[5], item.params[6]], transformOrigin, angleRad, decimalPlaces);\n                item.params[5] = pos2[0];\n                item.params[6] = pos2[1];\n                break;\n            }\n        }\n    }\n\n    const rel = pathDataToRelative(abs);\n    return pathDataToString(rel, true, decimalPlaces);\n};\n\nexport const rotatePath = (d: string, angleDegrees: number, decimalPlaces = 2) => {\n\n    const bbox = getPathBBox(d);\n\n    const x = bbox?.x ?? 0;\n    const y = bbox?.y ?? 0;\n    const w = bbox?.w ?? 0;\n    const h = bbox?.h ?? 0;\n\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n\n    return rotatePathAroundPoint(d, [cx, cy], angleDegrees, decimalPlaces);\n};\n\n// ---------------------- SCALE --------------------------\n\nconst scaleDot = (point: Vector2, scaleVector: Vector2, transformOrigin: Vector2, decimalPlaces = 2) => {\n    return m2ScaleAtPointH(\n        [scaleVector[0], scaleVector[1], 1],\n        [transformOrigin[0], transformOrigin[1], 1],\n        [point[0], point[1], 1],\n        decimalPlaces\n    );\n};\n\nexport const scalePathAroundPoint = (d: string, scaleVector: Vector2, transformOrigin: Vector2, decimalPlaces = 2) => {\n    if(!d) return d;\n\n    const parsed = parsePath(d);\n    if(parsed.errors.length > 0) return d;\n\n    const abs = pathDataToAbsolute(parsed);\n    if(!abs || abs.commands.length <= 0) return d;\n\n    const max = maximizeAbsolutePath(abs);\n    for(const item of max.commands){\n\n        switch(item.command){\n\n            case EPathDataCommand.MoveToAbs:\n            case EPathDataCommand.LineToAbs:{\n                // 2 params (x, y)\n\n                const pos: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n\n                item.params[0] = pos[0];\n                item.params[1] = pos[1];\n                break;\n            }\n\n            case EPathDataCommand.CubicCurveToAbs:{\n                // 6 parameters\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[2], item.params[3]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n\n                const pos3: Vector3 = scaleDot(\n                    [item.params[4], item.params[5]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[4] = pos3[0];\n                item.params[5] = pos3[1];\n                break;\n            }\n\n            case EPathDataCommand.QuadraticCurveToAbs:{\n                // 4 parameters\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[2], item.params[3]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[2] = pos2[0];\n                item.params[3] = pos2[1];\n                break;\n            }\n\n            case EPathDataCommand.ArcAbs:{\n                // rx ry x-axis-rotation large-arc-flag sweep-flag x y\n                /*\n                const pos1: Vector3 = scaleDot(\n                    [item.params[0], item.params[1]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[0] = pos1[0];\n                item.params[1] = pos1[1];*/\n\n                const pos2: Vector3 = scaleDot(\n                    [item.params[5], item.params[6]],\n                    scaleVector,\n                    transformOrigin,\n                    decimalPlaces\n                );\n                item.params[5] = pos2[0];\n                item.params[6] = pos2[1];\n                break;\n            }\n        }\n    }\n\n    //const rel = pathDataToRelative(abs);\n    return pathDataToString(abs, false, decimalPlaces);\n};\n\nexport const scalePath = (d: string, scaleVector: Vector2, decimalPlaces = 2) => {\n\n    const bbox = getPathBBox(d);\n\n    const x = bbox?.x ?? 0;\n    const y = bbox?.y ?? 0;\n    const w = bbox?.w ?? 0;\n    const h = bbox?.h ?? 0;\n\n    const cx = x + w / 2;\n    const cy = y + h / 2;\n\n    return scalePathAroundPoint(d, scaleVector, [cx, cy], decimalPlaces);\n};", "import { setAttributes, SVG_NAMESPACE } from '../core';\n\nexport interface IAnimationProps{\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    style?: string;\n\n    // Animation timing attributes\n    begin?: string;\n    dur?: string;\n    end?: string;\n    min?: string;\n    max?: string;\n    restart?: string;\n    repeatCount?: number|string;\n    repeatDur?: string;\n    fill?: string;\n\n    // Animation value attributes\n    calcMode?: string;\n    values?: string;\n    keyTimes?: string;\n    keySplines?: string;\n    from?: number|string;\n    to?: number|string;\n    by?: number|string;\n\n    // Other Animation attributes\n    attributeName?: string;\n    additive?: string;\n    accumulate?: string;\n}\n\nexport const getCommonAnimationAttributes = (props?: IAnimationProps) : [string, string|number|undefined][] => {\n\n    if(!props) return [];\n\n    return [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['style', props?.style],\n\n        // Animation timing attributes\n        ['begin', props?.begin],\n        ['dur', props?.dur],\n        ['end', props?.end],\n        ['min', props?.min],\n        ['max', props?.max],\n        ['restart', props?.restart],\n        ['repeatCount', props?.repeatCount],\n        ['repeatDur', props?.repeatDur],\n        ['fill', props?.fill],\n\n        // Animation value attributes\n        ['calcMode', props?.calcMode],\n        ['values', props?.values],\n        ['keyTimes', props?.keyTimes],\n        ['keySplines', props?.keySplines],\n        ['from', props?.from],\n        ['to', props?.to],\n        ['by', props?.by],\n\n        // Other Animation attributes\n        ['attributeName', props?.attributeName],\n        ['additive', props?.additive],\n        ['accumulate', props?.accumulate],\n    ];\n};\n\n/**\n * Create <animate> element.\n */\nexport const createAnimate = (props?: IAnimationProps) : SVGAnimateElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animate = doc.createElementNS(SVG_NAMESPACE, 'animate');\n\n    setAttributes($animate, [\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animate;\n};\n\nexport interface ICreateAnimateMotionProps extends IAnimationProps{\n    keyPoints?: string;\n    path?: string|number;\n    rotate?: string|number;\n}\n\n/**\n * Create <animateMotion> element.\n */\nexport const createAnimateMotion = (props?: ICreateAnimateMotionProps) : SVGAnimateMotionElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animateMotion = doc.createElementNS(SVG_NAMESPACE, 'animateMotion');\n\n    setAttributes($animateMotion, [\n        ['keyPoints', props?.keyPoints],\n        ['path', props?.path],\n        ['rotate', props?.rotate],\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animateMotion;\n};\n\nexport interface ICreateAnimateTransformProps extends IAnimationProps{\n    type?: string;\n    attributeType?: string;\n}\n\n/**\n * Create <animateTransform> element.\n */\nexport const createAnimateTransform = (props?: ICreateAnimateTransformProps) : SVGAnimateTransformElement => {\n\n    const doc = props?.document || window.document;\n\n    const $animateTransform = doc.createElementNS(SVG_NAMESPACE, 'animateTransform');\n\n    setAttributes($animateTransform, [\n        ['type', props?.type],\n        ['attributeType', props?.attributeType],\n        ...getCommonAnimationAttributes(props),\n    ]);\n\n    return $animateTransform;\n};\n\nexport interface ICreateMPathProps{\n    document?: Document;\n\n    id?: string;\n    classes?: string;\n    xlinkHref?: string\n}\n\n/**\n * Create <mpath> element.\n */\nexport const createMPath = (props?: ICreateMPathProps) : SVGMPathElement => {\n\n    const doc = props?.document || window.document;\n\n    const $mpath = doc.createElementNS(SVG_NAMESPACE, 'mpath');\n\n    setAttributes($mpath, [\n        ['id', props?.id],\n        ['class', props?.classes],\n        ['xlink:href', props?.xlinkHref],\n    ]);\n\n    return $mpath;\n};", "// This file is autogenerated. It's used to publish ESM to npm.\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) {\n    return typeof obj;\n  } : function (obj) {\n    return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n  }, _typeof(obj);\n}\n\n// https://github.com/bgrins/TinyColor\n// Brian Grinstead, MIT License\n\nvar trimLeft = /^\\s+/;\nvar trimRight = /\\s+$/;\nfunction tinycolor(color, opts) {\n  color = color ? color : \"\";\n  opts = opts || {};\n\n  // If input is already a tinycolor, return itself\n  if (color instanceof tinycolor) {\n    return color;\n  }\n  // If we are called as a function, call using new instead\n  if (!(this instanceof tinycolor)) {\n    return new tinycolor(color, opts);\n  }\n  var rgb = inputToRGB(color);\n  this._originalInput = color, this._r = rgb.r, this._g = rgb.g, this._b = rgb.b, this._a = rgb.a, this._roundA = Math.round(100 * this._a) / 100, this._format = opts.format || rgb.format;\n  this._gradientType = opts.gradientType;\n\n  // Don't let the range of [0,255] come back in [0,1].\n  // Potentially lose a little bit of precision here, but will fix issues where\n  // .5 gets interpreted as half of the total, instead of half of 1\n  // If it was supposed to be 128, this was already taken care of by `inputToRgb`\n  if (this._r < 1) this._r = Math.round(this._r);\n  if (this._g < 1) this._g = Math.round(this._g);\n  if (this._b < 1) this._b = Math.round(this._b);\n  this._ok = rgb.ok;\n}\ntinycolor.prototype = {\n  isDark: function isDark() {\n    return this.getBrightness() < 128;\n  },\n  isLight: function isLight() {\n    return !this.isDark();\n  },\n  isValid: function isValid() {\n    return this._ok;\n  },\n  getOriginalInput: function getOriginalInput() {\n    return this._originalInput;\n  },\n  getFormat: function getFormat() {\n    return this._format;\n  },\n  getAlpha: function getAlpha() {\n    return this._a;\n  },\n  getBrightness: function getBrightness() {\n    //http://www.w3.org/TR/AERT#color-contrast\n    var rgb = this.toRgb();\n    return (rgb.r * 299 + rgb.g * 587 + rgb.b * 114) / 1000;\n  },\n  getLuminance: function getLuminance() {\n    //http://www.w3.org/TR/2008/REC-WCAG20-20081211/#relativeluminancedef\n    var rgb = this.toRgb();\n    var RsRGB, GsRGB, BsRGB, R, G, B;\n    RsRGB = rgb.r / 255;\n    GsRGB = rgb.g / 255;\n    BsRGB = rgb.b / 255;\n    if (RsRGB <= 0.03928) R = RsRGB / 12.92;else R = Math.pow((RsRGB + 0.055) / 1.055, 2.4);\n    if (GsRGB <= 0.03928) G = GsRGB / 12.92;else G = Math.pow((GsRGB + 0.055) / 1.055, 2.4);\n    if (BsRGB <= 0.03928) B = BsRGB / 12.92;else B = Math.pow((BsRGB + 0.055) / 1.055, 2.4);\n    return 0.2126 * R + 0.7152 * G + 0.0722 * B;\n  },\n  setAlpha: function setAlpha(value) {\n    this._a = boundAlpha(value);\n    this._roundA = Math.round(100 * this._a) / 100;\n    return this;\n  },\n  toHsv: function toHsv() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    return {\n      h: hsv.h * 360,\n      s: hsv.s,\n      v: hsv.v,\n      a: this._a\n    };\n  },\n  toHsvString: function toHsvString() {\n    var hsv = rgbToHsv(this._r, this._g, this._b);\n    var h = Math.round(hsv.h * 360),\n      s = Math.round(hsv.s * 100),\n      v = Math.round(hsv.v * 100);\n    return this._a == 1 ? \"hsv(\" + h + \", \" + s + \"%, \" + v + \"%)\" : \"hsva(\" + h + \", \" + s + \"%, \" + v + \"%, \" + this._roundA + \")\";\n  },\n  toHsl: function toHsl() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    return {\n      h: hsl.h * 360,\n      s: hsl.s,\n      l: hsl.l,\n      a: this._a\n    };\n  },\n  toHslString: function toHslString() {\n    var hsl = rgbToHsl(this._r, this._g, this._b);\n    var h = Math.round(hsl.h * 360),\n      s = Math.round(hsl.s * 100),\n      l = Math.round(hsl.l * 100);\n    return this._a == 1 ? \"hsl(\" + h + \", \" + s + \"%, \" + l + \"%)\" : \"hsla(\" + h + \", \" + s + \"%, \" + l + \"%, \" + this._roundA + \")\";\n  },\n  toHex: function toHex(allow3Char) {\n    return rgbToHex(this._r, this._g, this._b, allow3Char);\n  },\n  toHexString: function toHexString(allow3Char) {\n    return \"#\" + this.toHex(allow3Char);\n  },\n  toHex8: function toHex8(allow4Char) {\n    return rgbaToHex(this._r, this._g, this._b, this._a, allow4Char);\n  },\n  toHex8String: function toHex8String(allow4Char) {\n    return \"#\" + this.toHex8(allow4Char);\n  },\n  toRgb: function toRgb() {\n    return {\n      r: Math.round(this._r),\n      g: Math.round(this._g),\n      b: Math.round(this._b),\n      a: this._a\n    };\n  },\n  toRgbString: function toRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \")\" : \"rgba(\" + Math.round(this._r) + \", \" + Math.round(this._g) + \", \" + Math.round(this._b) + \", \" + this._roundA + \")\";\n  },\n  toPercentageRgb: function toPercentageRgb() {\n    return {\n      r: Math.round(bound01(this._r, 255) * 100) + \"%\",\n      g: Math.round(bound01(this._g, 255) * 100) + \"%\",\n      b: Math.round(bound01(this._b, 255) * 100) + \"%\",\n      a: this._a\n    };\n  },\n  toPercentageRgbString: function toPercentageRgbString() {\n    return this._a == 1 ? \"rgb(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%)\" : \"rgba(\" + Math.round(bound01(this._r, 255) * 100) + \"%, \" + Math.round(bound01(this._g, 255) * 100) + \"%, \" + Math.round(bound01(this._b, 255) * 100) + \"%, \" + this._roundA + \")\";\n  },\n  toName: function toName() {\n    if (this._a === 0) {\n      return \"transparent\";\n    }\n    if (this._a < 1) {\n      return false;\n    }\n    return hexNames[rgbToHex(this._r, this._g, this._b, true)] || false;\n  },\n  toFilter: function toFilter(secondColor) {\n    var hex8String = \"#\" + rgbaToArgbHex(this._r, this._g, this._b, this._a);\n    var secondHex8String = hex8String;\n    var gradientType = this._gradientType ? \"GradientType = 1, \" : \"\";\n    if (secondColor) {\n      var s = tinycolor(secondColor);\n      secondHex8String = \"#\" + rgbaToArgbHex(s._r, s._g, s._b, s._a);\n    }\n    return \"progid:DXImageTransform.Microsoft.gradient(\" + gradientType + \"startColorstr=\" + hex8String + \",endColorstr=\" + secondHex8String + \")\";\n  },\n  toString: function toString(format) {\n    var formatSet = !!format;\n    format = format || this._format;\n    var formattedString = false;\n    var hasAlpha = this._a < 1 && this._a >= 0;\n    var needsAlphaFormat = !formatSet && hasAlpha && (format === \"hex\" || format === \"hex6\" || format === \"hex3\" || format === \"hex4\" || format === \"hex8\" || format === \"name\");\n    if (needsAlphaFormat) {\n      // Special case for \"transparent\", all other non-alpha formats\n      // will return rgba when there is transparency.\n      if (format === \"name\" && this._a === 0) {\n        return this.toName();\n      }\n      return this.toRgbString();\n    }\n    if (format === \"rgb\") {\n      formattedString = this.toRgbString();\n    }\n    if (format === \"prgb\") {\n      formattedString = this.toPercentageRgbString();\n    }\n    if (format === \"hex\" || format === \"hex6\") {\n      formattedString = this.toHexString();\n    }\n    if (format === \"hex3\") {\n      formattedString = this.toHexString(true);\n    }\n    if (format === \"hex4\") {\n      formattedString = this.toHex8String(true);\n    }\n    if (format === \"hex8\") {\n      formattedString = this.toHex8String();\n    }\n    if (format === \"name\") {\n      formattedString = this.toName();\n    }\n    if (format === \"hsl\") {\n      formattedString = this.toHslString();\n    }\n    if (format === \"hsv\") {\n      formattedString = this.toHsvString();\n    }\n    return formattedString || this.toHexString();\n  },\n  clone: function clone() {\n    return tinycolor(this.toString());\n  },\n  _applyModification: function _applyModification(fn, args) {\n    var color = fn.apply(null, [this].concat([].slice.call(args)));\n    this._r = color._r;\n    this._g = color._g;\n    this._b = color._b;\n    this.setAlpha(color._a);\n    return this;\n  },\n  lighten: function lighten() {\n    return this._applyModification(_lighten, arguments);\n  },\n  brighten: function brighten() {\n    return this._applyModification(_brighten, arguments);\n  },\n  darken: function darken() {\n    return this._applyModification(_darken, arguments);\n  },\n  desaturate: function desaturate() {\n    return this._applyModification(_desaturate, arguments);\n  },\n  saturate: function saturate() {\n    return this._applyModification(_saturate, arguments);\n  },\n  greyscale: function greyscale() {\n    return this._applyModification(_greyscale, arguments);\n  },\n  spin: function spin() {\n    return this._applyModification(_spin, arguments);\n  },\n  _applyCombination: function _applyCombination(fn, args) {\n    return fn.apply(null, [this].concat([].slice.call(args)));\n  },\n  analogous: function analogous() {\n    return this._applyCombination(_analogous, arguments);\n  },\n  complement: function complement() {\n    return this._applyCombination(_complement, arguments);\n  },\n  monochromatic: function monochromatic() {\n    return this._applyCombination(_monochromatic, arguments);\n  },\n  splitcomplement: function splitcomplement() {\n    return this._applyCombination(_splitcomplement, arguments);\n  },\n  // Disabled until https://github.com/bgrins/TinyColor/issues/254\n  // polyad: function (number) {\n  //   return this._applyCombination(polyad, [number]);\n  // },\n  triad: function triad() {\n    return this._applyCombination(polyad, [3]);\n  },\n  tetrad: function tetrad() {\n    return this._applyCombination(polyad, [4]);\n  }\n};\n\n// If input is an object, force 1 into \"1.0\" to handle ratios properly\n// String input requires \"1.0\" as input, so 1 will be treated as 1\ntinycolor.fromRatio = function (color, opts) {\n  if (_typeof(color) == \"object\") {\n    var newColor = {};\n    for (var i in color) {\n      if (color.hasOwnProperty(i)) {\n        if (i === \"a\") {\n          newColor[i] = color[i];\n        } else {\n          newColor[i] = convertToPercentage(color[i]);\n        }\n      }\n    }\n    color = newColor;\n  }\n  return tinycolor(color, opts);\n};\n\n// Given a string or object, convert that input to RGB\n// Possible string inputs:\n//\n//     \"red\"\n//     \"#f00\" or \"f00\"\n//     \"#ff0000\" or \"ff0000\"\n//     \"#ff000000\" or \"ff000000\"\n//     \"rgb 255 0 0\" or \"rgb (255, 0, 0)\"\n//     \"rgb 1.0 0 0\" or \"rgb (1, 0, 0)\"\n//     \"rgba (255, 0, 0, 1)\" or \"rgba 255, 0, 0, 1\"\n//     \"rgba (1.0, 0, 0, 1)\" or \"rgba 1.0, 0, 0, 1\"\n//     \"hsl(0, 100%, 50%)\" or \"hsl 0 100% 50%\"\n//     \"hsla(0, 100%, 50%, 1)\" or \"hsla 0 100% 50%, 1\"\n//     \"hsv(0, 100%, 100%)\" or \"hsv 0 100% 100%\"\n//\nfunction inputToRGB(color) {\n  var rgb = {\n    r: 0,\n    g: 0,\n    b: 0\n  };\n  var a = 1;\n  var s = null;\n  var v = null;\n  var l = null;\n  var ok = false;\n  var format = false;\n  if (typeof color == \"string\") {\n    color = stringInputToObject(color);\n  }\n  if (_typeof(color) == \"object\") {\n    if (isValidCSSUnit(color.r) && isValidCSSUnit(color.g) && isValidCSSUnit(color.b)) {\n      rgb = rgbToRgb(color.r, color.g, color.b);\n      ok = true;\n      format = String(color.r).substr(-1) === \"%\" ? \"prgb\" : \"rgb\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.v)) {\n      s = convertToPercentage(color.s);\n      v = convertToPercentage(color.v);\n      rgb = hsvToRgb(color.h, s, v);\n      ok = true;\n      format = \"hsv\";\n    } else if (isValidCSSUnit(color.h) && isValidCSSUnit(color.s) && isValidCSSUnit(color.l)) {\n      s = convertToPercentage(color.s);\n      l = convertToPercentage(color.l);\n      rgb = hslToRgb(color.h, s, l);\n      ok = true;\n      format = \"hsl\";\n    }\n    if (color.hasOwnProperty(\"a\")) {\n      a = color.a;\n    }\n  }\n  a = boundAlpha(a);\n  return {\n    ok: ok,\n    format: color.format || format,\n    r: Math.min(255, Math.max(rgb.r, 0)),\n    g: Math.min(255, Math.max(rgb.g, 0)),\n    b: Math.min(255, Math.max(rgb.b, 0)),\n    a: a\n  };\n}\n\n// Conversion Functions\n// --------------------\n\n// `rgbToHsl`, `rgbToHsv`, `hslToRgb`, `hsvToRgb` modified from:\n// <http://mjijackson.com/2008/02/rgb-to-hsl-and-rgb-to-hsv-color-model-conversion-algorithms-in-javascript>\n\n// `rgbToRgb`\n// Handle bounds / percentage checking to conform to CSS color spec\n// <http://www.w3.org/TR/css3-color/>\n// *Assumes:* r, g, b in [0, 255] or [0, 1]\n// *Returns:* { r, g, b } in [0, 255]\nfunction rgbToRgb(r, g, b) {\n  return {\n    r: bound01(r, 255) * 255,\n    g: bound01(g, 255) * 255,\n    b: bound01(b, 255) * 255\n  };\n}\n\n// `rgbToHsl`\n// Converts an RGB color value to HSL.\n// *Assumes:* r, g, and b are contained in [0, 255] or [0, 1]\n// *Returns:* { h, s, l } in [0,1]\nfunction rgbToHsl(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    l = (max + min) / 2;\n  if (max == min) {\n    h = s = 0; // achromatic\n  } else {\n    var d = max - min;\n    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    l: l\n  };\n}\n\n// `hslToRgb`\n// Converts an HSL color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and l are contained [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hslToRgb(h, s, l) {\n  var r, g, b;\n  h = bound01(h, 360);\n  s = bound01(s, 100);\n  l = bound01(l, 100);\n  function hue2rgb(p, q, t) {\n    if (t < 0) t += 1;\n    if (t > 1) t -= 1;\n    if (t < 1 / 6) return p + (q - p) * 6 * t;\n    if (t < 1 / 2) return q;\n    if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;\n    return p;\n  }\n  if (s === 0) {\n    r = g = b = l; // achromatic\n  } else {\n    var q = l < 0.5 ? l * (1 + s) : l + s - l * s;\n    var p = 2 * l - q;\n    r = hue2rgb(p, q, h + 1 / 3);\n    g = hue2rgb(p, q, h);\n    b = hue2rgb(p, q, h - 1 / 3);\n  }\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHsv`\n// Converts an RGB color value to HSV\n// *Assumes:* r, g, and b are contained in the set [0, 255] or [0, 1]\n// *Returns:* { h, s, v } in [0,1]\nfunction rgbToHsv(r, g, b) {\n  r = bound01(r, 255);\n  g = bound01(g, 255);\n  b = bound01(b, 255);\n  var max = Math.max(r, g, b),\n    min = Math.min(r, g, b);\n  var h,\n    s,\n    v = max;\n  var d = max - min;\n  s = max === 0 ? 0 : d / max;\n  if (max == min) {\n    h = 0; // achromatic\n  } else {\n    switch (max) {\n      case r:\n        h = (g - b) / d + (g < b ? 6 : 0);\n        break;\n      case g:\n        h = (b - r) / d + 2;\n        break;\n      case b:\n        h = (r - g) / d + 4;\n        break;\n    }\n    h /= 6;\n  }\n  return {\n    h: h,\n    s: s,\n    v: v\n  };\n}\n\n// `hsvToRgb`\n// Converts an HSV color value to RGB.\n// *Assumes:* h is contained in [0, 1] or [0, 360] and s and v are contained in [0, 1] or [0, 100]\n// *Returns:* { r, g, b } in the set [0, 255]\nfunction hsvToRgb(h, s, v) {\n  h = bound01(h, 360) * 6;\n  s = bound01(s, 100);\n  v = bound01(v, 100);\n  var i = Math.floor(h),\n    f = h - i,\n    p = v * (1 - s),\n    q = v * (1 - f * s),\n    t = v * (1 - (1 - f) * s),\n    mod = i % 6,\n    r = [v, q, p, p, t, v][mod],\n    g = [t, v, v, q, p, p][mod],\n    b = [p, p, t, v, v, q][mod];\n  return {\n    r: r * 255,\n    g: g * 255,\n    b: b * 255\n  };\n}\n\n// `rgbToHex`\n// Converts an RGB color to hex\n// Assumes r, g, and b are contained in the set [0, 255]\n// Returns a 3 or 6 character hex\nfunction rgbToHex(r, g, b, allow3Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n\n  // Return a 3 character hex if possible\n  if (allow3Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToHex`\n// Converts an RGBA color plus alpha transparency to hex\n// Assumes r, g, b are contained in the set [0, 255] and\n// a in [0, 1]. Returns a 4 or 8 character rgba hex\nfunction rgbaToHex(r, g, b, a, allow4Char) {\n  var hex = [pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16)), pad2(convertDecimalToHex(a))];\n\n  // Return a 4 character hex if possible\n  if (allow4Char && hex[0].charAt(0) == hex[0].charAt(1) && hex[1].charAt(0) == hex[1].charAt(1) && hex[2].charAt(0) == hex[2].charAt(1) && hex[3].charAt(0) == hex[3].charAt(1)) {\n    return hex[0].charAt(0) + hex[1].charAt(0) + hex[2].charAt(0) + hex[3].charAt(0);\n  }\n  return hex.join(\"\");\n}\n\n// `rgbaToArgbHex`\n// Converts an RGBA color to an ARGB Hex8 string\n// Rarely used, but required for \"toFilter()\"\nfunction rgbaToArgbHex(r, g, b, a) {\n  var hex = [pad2(convertDecimalToHex(a)), pad2(Math.round(r).toString(16)), pad2(Math.round(g).toString(16)), pad2(Math.round(b).toString(16))];\n  return hex.join(\"\");\n}\n\n// `equals`\n// Can be called with any tinycolor input\ntinycolor.equals = function (color1, color2) {\n  if (!color1 || !color2) return false;\n  return tinycolor(color1).toRgbString() == tinycolor(color2).toRgbString();\n};\ntinycolor.random = function () {\n  return tinycolor.fromRatio({\n    r: Math.random(),\n    g: Math.random(),\n    b: Math.random()\n  });\n};\n\n// Modification Functions\n// ----------------------\n// Thanks to less.js for some of the basics here\n// <https://github.com/cloudhead/less.js/blob/master/lib/less/functions.js>\n\nfunction _desaturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s -= amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _saturate(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.s += amount / 100;\n  hsl.s = clamp01(hsl.s);\n  return tinycolor(hsl);\n}\nfunction _greyscale(color) {\n  return tinycolor(color).desaturate(100);\n}\nfunction _lighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l += amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\nfunction _brighten(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var rgb = tinycolor(color).toRgb();\n  rgb.r = Math.max(0, Math.min(255, rgb.r - Math.round(255 * -(amount / 100))));\n  rgb.g = Math.max(0, Math.min(255, rgb.g - Math.round(255 * -(amount / 100))));\n  rgb.b = Math.max(0, Math.min(255, rgb.b - Math.round(255 * -(amount / 100))));\n  return tinycolor(rgb);\n}\nfunction _darken(color, amount) {\n  amount = amount === 0 ? 0 : amount || 10;\n  var hsl = tinycolor(color).toHsl();\n  hsl.l -= amount / 100;\n  hsl.l = clamp01(hsl.l);\n  return tinycolor(hsl);\n}\n\n// Spin takes a positive or negative amount within [-360, 360] indicating the change of hue.\n// Values outside of this range will be wrapped into this range.\nfunction _spin(color, amount) {\n  var hsl = tinycolor(color).toHsl();\n  var hue = (hsl.h + amount) % 360;\n  hsl.h = hue < 0 ? 360 + hue : hue;\n  return tinycolor(hsl);\n}\n\n// Combination Functions\n// ---------------------\n// Thanks to jQuery xColor for some of the ideas behind these\n// <https://github.com/infusion/jQuery-xcolor/blob/master/jquery.xcolor.js>\n\nfunction _complement(color) {\n  var hsl = tinycolor(color).toHsl();\n  hsl.h = (hsl.h + 180) % 360;\n  return tinycolor(hsl);\n}\nfunction polyad(color, number) {\n  if (isNaN(number) || number <= 0) {\n    throw new Error(\"Argument to polyad must be a positive number\");\n  }\n  var hsl = tinycolor(color).toHsl();\n  var result = [tinycolor(color)];\n  var step = 360 / number;\n  for (var i = 1; i < number; i++) {\n    result.push(tinycolor({\n      h: (hsl.h + i * step) % 360,\n      s: hsl.s,\n      l: hsl.l\n    }));\n  }\n  return result;\n}\nfunction _splitcomplement(color) {\n  var hsl = tinycolor(color).toHsl();\n  var h = hsl.h;\n  return [tinycolor(color), tinycolor({\n    h: (h + 72) % 360,\n    s: hsl.s,\n    l: hsl.l\n  }), tinycolor({\n    h: (h + 216) % 360,\n    s: hsl.s,\n    l: hsl.l\n  })];\n}\nfunction _analogous(color, results, slices) {\n  results = results || 6;\n  slices = slices || 30;\n  var hsl = tinycolor(color).toHsl();\n  var part = 360 / slices;\n  var ret = [tinycolor(color)];\n  for (hsl.h = (hsl.h - (part * results >> 1) + 720) % 360; --results;) {\n    hsl.h = (hsl.h + part) % 360;\n    ret.push(tinycolor(hsl));\n  }\n  return ret;\n}\nfunction _monochromatic(color, results) {\n  results = results || 6;\n  var hsv = tinycolor(color).toHsv();\n  var h = hsv.h,\n    s = hsv.s,\n    v = hsv.v;\n  var ret = [];\n  var modification = 1 / results;\n  while (results--) {\n    ret.push(tinycolor({\n      h: h,\n      s: s,\n      v: v\n    }));\n    v = (v + modification) % 1;\n  }\n  return ret;\n}\n\n// Utility Functions\n// ---------------------\n\ntinycolor.mix = function (color1, color2, amount) {\n  amount = amount === 0 ? 0 : amount || 50;\n  var rgb1 = tinycolor(color1).toRgb();\n  var rgb2 = tinycolor(color2).toRgb();\n  var p = amount / 100;\n  var rgba = {\n    r: (rgb2.r - rgb1.r) * p + rgb1.r,\n    g: (rgb2.g - rgb1.g) * p + rgb1.g,\n    b: (rgb2.b - rgb1.b) * p + rgb1.b,\n    a: (rgb2.a - rgb1.a) * p + rgb1.a\n  };\n  return tinycolor(rgba);\n};\n\n// Readability Functions\n// ---------------------\n// <http://www.w3.org/TR/2008/REC-WCAG20-20081211/#contrast-ratiodef (WCAG Version 2)\n\n// `contrast`\n// Analyze the 2 colors and returns the color contrast defined by (WCAG Version 2)\ntinycolor.readability = function (color1, color2) {\n  var c1 = tinycolor(color1);\n  var c2 = tinycolor(color2);\n  return (Math.max(c1.getLuminance(), c2.getLuminance()) + 0.05) / (Math.min(c1.getLuminance(), c2.getLuminance()) + 0.05);\n};\n\n// `isReadable`\n// Ensure that foreground and background color combinations meet WCAG2 guidelines.\n// The third argument is an optional Object.\n//      the 'level' property states 'AA' or 'AAA' - if missing or invalid, it defaults to 'AA';\n//      the 'size' property states 'large' or 'small' - if missing or invalid, it defaults to 'small'.\n// If the entire object is absent, isReadable defaults to {level:\"AA\",size:\"small\"}.\n\n// *Example*\n//    tinycolor.isReadable(\"#000\", \"#111\") => false\n//    tinycolor.isReadable(\"#000\", \"#111\",{level:\"AA\",size:\"large\"}) => false\ntinycolor.isReadable = function (color1, color2, wcag2) {\n  var readability = tinycolor.readability(color1, color2);\n  var wcag2Parms, out;\n  out = false;\n  wcag2Parms = validateWCAG2Parms(wcag2);\n  switch (wcag2Parms.level + wcag2Parms.size) {\n    case \"AAsmall\":\n    case \"AAAlarge\":\n      out = readability >= 4.5;\n      break;\n    case \"AAlarge\":\n      out = readability >= 3;\n      break;\n    case \"AAAsmall\":\n      out = readability >= 7;\n      break;\n  }\n  return out;\n};\n\n// `mostReadable`\n// Given a base color and a list of possible foreground or background\n// colors for that base, returns the most readable color.\n// Optionally returns Black or White if the most readable color is unreadable.\n// *Example*\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:false}).toHexString(); // \"#112255\"\n//    tinycolor.mostReadable(tinycolor.mostReadable(\"#123\", [\"#124\", \"#125\"],{includeFallbackColors:true}).toHexString();  // \"#ffffff\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"large\"}).toHexString(); // \"#faf3f3\"\n//    tinycolor.mostReadable(\"#a8015a\", [\"#faf3f3\"],{includeFallbackColors:true,level:\"AAA\",size:\"small\"}).toHexString(); // \"#ffffff\"\ntinycolor.mostReadable = function (baseColor, colorList, args) {\n  var bestColor = null;\n  var bestScore = 0;\n  var readability;\n  var includeFallbackColors, level, size;\n  args = args || {};\n  includeFallbackColors = args.includeFallbackColors;\n  level = args.level;\n  size = args.size;\n  for (var i = 0; i < colorList.length; i++) {\n    readability = tinycolor.readability(baseColor, colorList[i]);\n    if (readability > bestScore) {\n      bestScore = readability;\n      bestColor = tinycolor(colorList[i]);\n    }\n  }\n  if (tinycolor.isReadable(baseColor, bestColor, {\n    level: level,\n    size: size\n  }) || !includeFallbackColors) {\n    return bestColor;\n  } else {\n    args.includeFallbackColors = false;\n    return tinycolor.mostReadable(baseColor, [\"#fff\", \"#000\"], args);\n  }\n};\n\n// Big List of Colors\n// ------------------\n// <https://www.w3.org/TR/css-color-4/#named-colors>\nvar names = tinycolor.names = {\n  aliceblue: \"f0f8ff\",\n  antiquewhite: \"faebd7\",\n  aqua: \"0ff\",\n  aquamarine: \"7fffd4\",\n  azure: \"f0ffff\",\n  beige: \"f5f5dc\",\n  bisque: \"ffe4c4\",\n  black: \"000\",\n  blanchedalmond: \"ffebcd\",\n  blue: \"00f\",\n  blueviolet: \"8a2be2\",\n  brown: \"a52a2a\",\n  burlywood: \"deb887\",\n  burntsienna: \"ea7e5d\",\n  cadetblue: \"5f9ea0\",\n  chartreuse: \"7fff00\",\n  chocolate: \"d2691e\",\n  coral: \"ff7f50\",\n  cornflowerblue: \"6495ed\",\n  cornsilk: \"fff8dc\",\n  crimson: \"dc143c\",\n  cyan: \"0ff\",\n  darkblue: \"00008b\",\n  darkcyan: \"008b8b\",\n  darkgoldenrod: \"b8860b\",\n  darkgray: \"a9a9a9\",\n  darkgreen: \"006400\",\n  darkgrey: \"a9a9a9\",\n  darkkhaki: \"bdb76b\",\n  darkmagenta: \"8b008b\",\n  darkolivegreen: \"556b2f\",\n  darkorange: \"ff8c00\",\n  darkorchid: \"9932cc\",\n  darkred: \"8b0000\",\n  darksalmon: \"e9967a\",\n  darkseagreen: \"8fbc8f\",\n  darkslateblue: \"483d8b\",\n  darkslategray: \"2f4f4f\",\n  darkslategrey: \"2f4f4f\",\n  darkturquoise: \"00ced1\",\n  darkviolet: \"9400d3\",\n  deeppink: \"ff1493\",\n  deepskyblue: \"00bfff\",\n  dimgray: \"696969\",\n  dimgrey: \"696969\",\n  dodgerblue: \"1e90ff\",\n  firebrick: \"b22222\",\n  floralwhite: \"fffaf0\",\n  forestgreen: \"228b22\",\n  fuchsia: \"f0f\",\n  gainsboro: \"dcdcdc\",\n  ghostwhite: \"f8f8ff\",\n  gold: \"ffd700\",\n  goldenrod: \"daa520\",\n  gray: \"808080\",\n  green: \"008000\",\n  greenyellow: \"adff2f\",\n  grey: \"808080\",\n  honeydew: \"f0fff0\",\n  hotpink: \"ff69b4\",\n  indianred: \"cd5c5c\",\n  indigo: \"4b0082\",\n  ivory: \"fffff0\",\n  khaki: \"f0e68c\",\n  lavender: \"e6e6fa\",\n  lavenderblush: \"fff0f5\",\n  lawngreen: \"7cfc00\",\n  lemonchiffon: \"fffacd\",\n  lightblue: \"add8e6\",\n  lightcoral: \"f08080\",\n  lightcyan: \"e0ffff\",\n  lightgoldenrodyellow: \"fafad2\",\n  lightgray: \"d3d3d3\",\n  lightgreen: \"90ee90\",\n  lightgrey: \"d3d3d3\",\n  lightpink: \"ffb6c1\",\n  lightsalmon: \"ffa07a\",\n  lightseagreen: \"20b2aa\",\n  lightskyblue: \"87cefa\",\n  lightslategray: \"789\",\n  lightslategrey: \"789\",\n  lightsteelblue: \"b0c4de\",\n  lightyellow: \"ffffe0\",\n  lime: \"0f0\",\n  limegreen: \"32cd32\",\n  linen: \"faf0e6\",\n  magenta: \"f0f\",\n  maroon: \"800000\",\n  mediumaquamarine: \"66cdaa\",\n  mediumblue: \"0000cd\",\n  mediumorchid: \"ba55d3\",\n  mediumpurple: \"9370db\",\n  mediumseagreen: \"3cb371\",\n  mediumslateblue: \"7b68ee\",\n  mediumspringgreen: \"00fa9a\",\n  mediumturquoise: \"48d1cc\",\n  mediumvioletred: \"c71585\",\n  midnightblue: \"191970\",\n  mintcream: \"f5fffa\",\n  mistyrose: \"ffe4e1\",\n  moccasin: \"ffe4b5\",\n  navajowhite: \"ffdead\",\n  navy: \"000080\",\n  oldlace: \"fdf5e6\",\n  olive: \"808000\",\n  olivedrab: \"6b8e23\",\n  orange: \"ffa500\",\n  orangered: \"ff4500\",\n  orchid: \"da70d6\",\n  palegoldenrod: \"eee8aa\",\n  palegreen: \"98fb98\",\n  paleturquoise: \"afeeee\",\n  palevioletred: \"db7093\",\n  papayawhip: \"ffefd5\",\n  peachpuff: \"ffdab9\",\n  peru: \"cd853f\",\n  pink: \"ffc0cb\",\n  plum: \"dda0dd\",\n  powderblue: \"b0e0e6\",\n  purple: \"800080\",\n  rebeccapurple: \"663399\",\n  red: \"f00\",\n  rosybrown: \"bc8f8f\",\n  royalblue: \"4169e1\",\n  saddlebrown: \"8b4513\",\n  salmon: \"fa8072\",\n  sandybrown: \"f4a460\",\n  seagreen: \"2e8b57\",\n  seashell: \"fff5ee\",\n  sienna: \"a0522d\",\n  silver: \"c0c0c0\",\n  skyblue: \"87ceeb\",\n  slateblue: \"6a5acd\",\n  slategray: \"708090\",\n  slategrey: \"708090\",\n  snow: \"fffafa\",\n  springgreen: \"00ff7f\",\n  steelblue: \"4682b4\",\n  tan: \"d2b48c\",\n  teal: \"008080\",\n  thistle: \"d8bfd8\",\n  tomato: \"ff6347\",\n  turquoise: \"40e0d0\",\n  violet: \"ee82ee\",\n  wheat: \"f5deb3\",\n  white: \"fff\",\n  whitesmoke: \"f5f5f5\",\n  yellow: \"ff0\",\n  yellowgreen: \"9acd32\"\n};\n\n// Make it easy to access colors via `hexNames[hex]`\nvar hexNames = tinycolor.hexNames = flip(names);\n\n// Utilities\n// ---------\n\n// `{ 'name1': 'val1' }` becomes `{ 'val1': 'name1' }`\nfunction flip(o) {\n  var flipped = {};\n  for (var i in o) {\n    if (o.hasOwnProperty(i)) {\n      flipped[o[i]] = i;\n    }\n  }\n  return flipped;\n}\n\n// Return a valid alpha value [0,1] with all invalid values being set to 1\nfunction boundAlpha(a) {\n  a = parseFloat(a);\n  if (isNaN(a) || a < 0 || a > 1) {\n    a = 1;\n  }\n  return a;\n}\n\n// Take input from [0, n] and return it as [0, 1]\nfunction bound01(n, max) {\n  if (isOnePointZero(n)) n = \"100%\";\n  var processPercent = isPercentage(n);\n  n = Math.min(max, Math.max(0, parseFloat(n)));\n\n  // Automatically convert percentage into number\n  if (processPercent) {\n    n = parseInt(n * max, 10) / 100;\n  }\n\n  // Handle floating point rounding errors\n  if (Math.abs(n - max) < 0.000001) {\n    return 1;\n  }\n\n  // Convert into [0, 1] range if it isn't already\n  return n % max / parseFloat(max);\n}\n\n// Force a number between 0 and 1\nfunction clamp01(val) {\n  return Math.min(1, Math.max(0, val));\n}\n\n// Parse a base-16 hex value into a base-10 integer\nfunction parseIntFromHex(val) {\n  return parseInt(val, 16);\n}\n\n// Need to handle 1.0 as 100%, since once it is a number, there is no difference between it and 1\n// <http://stackoverflow.com/questions/7422072/javascript-how-to-detect-number-as-a-decimal-including-1-0>\nfunction isOnePointZero(n) {\n  return typeof n == \"string\" && n.indexOf(\".\") != -1 && parseFloat(n) === 1;\n}\n\n// Check to see if string passed in is a percentage\nfunction isPercentage(n) {\n  return typeof n === \"string\" && n.indexOf(\"%\") != -1;\n}\n\n// Force a hex value to have 2 characters\nfunction pad2(c) {\n  return c.length == 1 ? \"0\" + c : \"\" + c;\n}\n\n// Replace a decimal with it's percentage value\nfunction convertToPercentage(n) {\n  if (n <= 1) {\n    n = n * 100 + \"%\";\n  }\n  return n;\n}\n\n// Converts a decimal to a hex value\nfunction convertDecimalToHex(d) {\n  return Math.round(parseFloat(d) * 255).toString(16);\n}\n// Converts a hex value to a decimal\nfunction convertHexToDecimal(h) {\n  return parseIntFromHex(h) / 255;\n}\nvar matchers = function () {\n  // <http://www.w3.org/TR/css3-values/#integers>\n  var CSS_INTEGER = \"[-\\\\+]?\\\\d+%?\";\n\n  // <http://www.w3.org/TR/css3-values/#number-value>\n  var CSS_NUMBER = \"[-\\\\+]?\\\\d*\\\\.\\\\d+%?\";\n\n  // Allow positive/negative integer/number.  Don't capture the either/or, just the entire outcome.\n  var CSS_UNIT = \"(?:\" + CSS_NUMBER + \")|(?:\" + CSS_INTEGER + \")\";\n\n  // Actual matching.\n  // Parentheses and commas are optional, but not required.\n  // Whitespace can take the place of commas or opening paren\n  var PERMISSIVE_MATCH3 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  var PERMISSIVE_MATCH4 = \"[\\\\s|\\\\(]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")[,|\\\\s]+(\" + CSS_UNIT + \")\\\\s*\\\\)?\";\n  return {\n    CSS_UNIT: new RegExp(CSS_UNIT),\n    rgb: new RegExp(\"rgb\" + PERMISSIVE_MATCH3),\n    rgba: new RegExp(\"rgba\" + PERMISSIVE_MATCH4),\n    hsl: new RegExp(\"hsl\" + PERMISSIVE_MATCH3),\n    hsla: new RegExp(\"hsla\" + PERMISSIVE_MATCH4),\n    hsv: new RegExp(\"hsv\" + PERMISSIVE_MATCH3),\n    hsva: new RegExp(\"hsva\" + PERMISSIVE_MATCH4),\n    hex3: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex6: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/,\n    hex4: /^#?([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})([0-9a-fA-F]{1})$/,\n    hex8: /^#?([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})([0-9a-fA-F]{2})$/\n  };\n}();\n\n// `isValidCSSUnit`\n// Take in a single string / number and check to see if it looks like a CSS unit\n// (see `matchers` above for definition).\nfunction isValidCSSUnit(color) {\n  return !!matchers.CSS_UNIT.exec(color);\n}\n\n// `stringInputToObject`\n// Permissive string parsing.  Take in a number of formats, and output an object\n// based on detected format.  Returns `{ r, g, b }` or `{ h, s, l }` or `{ h, s, v}`\nfunction stringInputToObject(color) {\n  color = color.replace(trimLeft, \"\").replace(trimRight, \"\").toLowerCase();\n  var named = false;\n  if (names[color]) {\n    color = names[color];\n    named = true;\n  } else if (color == \"transparent\") {\n    return {\n      r: 0,\n      g: 0,\n      b: 0,\n      a: 0,\n      format: \"name\"\n    };\n  }\n\n  // Try to match string input using regular expressions.\n  // Keep most of the number bounding out of this function - don't worry about [0,1] or [0,100] or [0,360]\n  // Just return an object and let the conversion functions handle that.\n  // This way the result will be the same whether the tinycolor is initialized with string or object.\n  var match;\n  if (match = matchers.rgb.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3]\n    };\n  }\n  if (match = matchers.rgba.exec(color)) {\n    return {\n      r: match[1],\n      g: match[2],\n      b: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsl.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3]\n    };\n  }\n  if (match = matchers.hsla.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      l: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hsv.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3]\n    };\n  }\n  if (match = matchers.hsva.exec(color)) {\n    return {\n      h: match[1],\n      s: match[2],\n      v: match[3],\n      a: match[4]\n    };\n  }\n  if (match = matchers.hex8.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      a: convertHexToDecimal(match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex6.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1]),\n      g: parseIntFromHex(match[2]),\n      b: parseIntFromHex(match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  if (match = matchers.hex4.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      a: convertHexToDecimal(match[4] + \"\" + match[4]),\n      format: named ? \"name\" : \"hex8\"\n    };\n  }\n  if (match = matchers.hex3.exec(color)) {\n    return {\n      r: parseIntFromHex(match[1] + \"\" + match[1]),\n      g: parseIntFromHex(match[2] + \"\" + match[2]),\n      b: parseIntFromHex(match[3] + \"\" + match[3]),\n      format: named ? \"name\" : \"hex\"\n    };\n  }\n  return false;\n}\nfunction validateWCAG2Parms(parms) {\n  // return valid WCAG2 parms for isReadable.\n  // If input parms are invalid, return {\"level\":\"AA\", \"size\":\"small\"}\n  var level, size;\n  parms = parms || {\n    level: \"AA\",\n    size: \"small\"\n  };\n  level = (parms.level || \"AA\").toUpperCase();\n  size = (parms.size || \"small\").toLowerCase();\n  if (level !== \"AA\" && level !== \"AAA\") {\n    level = \"AA\";\n  }\n  if (size !== \"small\" && size !== \"large\") {\n    size = \"small\";\n  }\n  return {\n    level: level,\n    size: size\n  };\n}\n\nexport { tinycolor as default };\n", "import { IParticle, ISettings, IState } from '../interfaces';\nimport { circle } from 'mz-canvas';\nimport { getRandom, getRandomBoolean, getRandomHexColor, getRandomItemFromArray, Vector2 } from 'mz-math';\nimport { getPathBBox } from 'mz-svg';\nimport tinycolor from 'tinycolor2';\nimport { rgbaToString } from './colors-provider';\n\n/**\n * This method is called once on the particles' initialization.\n */\nexport const createParticles = (options: ISettings, state: IState) : IParticle[] => {\n\n    const { $canvas } = state;\n\n    const particles: IParticle[] = [];\n\n    let svgPathData: string|undefined = undefined;\n    let svgSize: Vector2|undefined = undefined;\n    let scaleSize: Vector2|undefined = undefined;\n\n    const minSize = options.minSize as number;\n    const maxSize = options.maxSize as number;\n    const minSpeed = options.minSpeed as number;\n    const maxSpeed = options.maxSpeed as number;\n    const maxScale = options.maxScale as number;\n\n    const minScale = options.minScale as number;\n\n    for(let i= 0; i< state.vpParticlesNumber; i++) {\n\n        const rnd = getRandom(minSize, maxSize);\n        const particleSize: Vector2 = [rnd, rnd];\n\n        // handle case when provided SVG path data -------------\n        if(options.svgPathData && options.svgPathData.length > 0){\n\n            // get random SVG shape from the provided list, and calculate it's size\n            svgPathData = getRandomItemFromArray(options.svgPathData);\n            const bbox = getPathBBox(svgPathData);\n\n            if(bbox){\n                svgSize = [\n                    bbox.w,\n                    bbox.h,\n                ];\n                scaleSize = [\n                    particleSize[0] / bbox.w,\n                    particleSize[1] / bbox.h,\n                ];\n            }\n        }\n\n        let color;\n\n        if(options.particlesColors && options.particlesColors.length > 0){\n            color = getRandomItemFromArray(options.particlesColors);\n        }\n        else{\n            // when no color is provided ---> get random color\n            color = getRandomHexColor();\n        }\n\n        const tColor = tinycolor(color);\n        const tColorRGB = tColor.toRgb();\n\n        particles.push({\n            center: [\n                getRandom(0, $canvas.width),\n                getRandom(0, $canvas.height),\n            ],\n            speed: [\n                getRandom(minSpeed, maxSpeed),\n                getRandom(minSpeed, maxSpeed),\n            ],\n            size: particleSize,\n\n            color,\n            rgbaColor: [tColorRGB.r, tColorRGB.g, tColorRGB.b, tColorRGB.a],\n\n            // SVG path props ----------\n            svgPathData,\n            svgSize,\n            scaleSize,\n\n            // rotation effect ------------\n            angleRad: 0,\n            rotateCounterClockwise: getRandomBoolean(),\n\n            // scale effect ---------------\n            scale: (minScale + maxScale) / 2,\n            scaleDirection: getRandomItemFromArray([-1, 1]),\n\n            // fade in/out effect ---------\n            opacity: getRandom(0, 1),\n            opacityDirection: getRandomItemFromArray([-1, 1]),\n        });\n    }\n\n    return particles;\n};\n\nexport const moveParticle = (particle: IParticle, options: ISettings, state: IState) : IParticle => {\n\n    const { $canvas } = state;\n\n    const copy = { ...particle };\n\n    const [cx, cy]: Vector2 = particle.center;\n    const speed: Vector2 = [...particle.speed] as Vector2;\n\n    if(cx > $canvas.width || cx < 0) {\n        speed[0] = -speed[0];\n    }\n\n    if(cy > $canvas.height || cy < 0) {\n        speed[1] = -speed[1];\n    }\n\n    copy.speed = speed;\n    copy.center = [cx + copy.speed[0], cy + copy.speed[1]];\n\n    if(options.rotate) {\n        if(particle.rotateCounterClockwise){\n            copy.angleRad += Math.PI / 180;\n        }\n        else{\n            copy.angleRad -= Math.PI / 180;\n        }\n    }\n\n    if(options.scaleInOut){\n        const scaleStep = options.scaleStep as number;\n        const maxScale = options.maxScale as number;\n        const minScale = options.minScale as number;\n\n        if(copy.scaleDirection > 0){\n            copy.scale += scaleStep;\n        }\n        else{\n            copy.scale -= scaleStep;\n        }\n\n        if(copy.scale > maxScale){\n            copy.scale = maxScale;\n            copy.scaleDirection = -1;\n        }\n\n        if(copy.scale < minScale){\n            copy.scale = minScale;\n            copy.scaleDirection = 1;\n        }\n    }\n\n    if(options.fadeInOut){\n        const opacityStep = options.opacityStep as number;\n\n        if(copy.opacityDirection > 0){\n            copy.opacity += opacityStep;\n        }\n        else{\n            copy.opacity -= opacityStep;\n        }\n\n        if(copy.opacity > 1){\n            copy.scale = 1;\n            copy.opacityDirection = -1;\n        }\n\n        if(copy.opacity < 0){\n            copy.opacity = 0;\n            copy.opacityDirection = 1;\n        }\n    }\n\n    return copy;\n};\n\nexport const drawParticle = (particle: IParticle, options: ISettings, state: IState) => {\n\n    const { ctx } = state;\n\n    if(!options.svgPathData){\n\n        ctx.save();\n\n        const { size } = particle;\n        let r = size[0];\n\n        if(options.scaleInOut){\n            r *= particle.scale;\n        }\n\n        const fillStyle = options.fadeInOut ?\n            rgbaToString(\n                particle.rgbaColor[0],\n                particle.rgbaColor[1],\n                particle.rgbaColor[2],\n                particle.opacity\n            ) :\n            particle.color;\n\n        circle({\n            cx: particle.center[0],\n            cy: particle.center[1],\n            r,\n            fillStyle,\n        }, ctx);\n\n        ctx.restore();\n        return;\n    }\n\n    const [w, h] = particle.svgSize ? particle.svgSize : particle.size;\n\n    const path = new Path2D(particle.svgPathData);\n    ctx.save();\n\n    const halfWidth = w/2;\n    const halfHeight = h/2;\n\n    const [cx, cy] = [particle.center[0] - halfWidth, particle.center[1] - halfHeight];\n    ctx.translate(cx, cy);\n\n    if(particle.scaleSize){\n        // scale the path -------------------------------\n        ctx.translate(halfWidth, halfHeight);\n        ctx.scale(...particle.scaleSize);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.rotate) {\n        ctx.translate(halfWidth, halfHeight);\n        ctx.rotate(particle.angleRad);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.scaleInOut){\n        ctx.translate(halfWidth, halfHeight);\n        ctx.scale(particle.scale, particle.scale);\n        ctx.translate(-halfWidth, -halfHeight);\n    }\n\n    if(options.fadeInOut){\n        ctx.fillStyle = rgbaToString(\n            particle.rgbaColor[0],\n            particle.rgbaColor[1],\n            particle.rgbaColor[2],\n            particle.opacity,\n        );\n    }\n    else{\n        ctx.fillStyle = particle.color;\n    }\n\n    ctx.fill(path);\n    ctx.restore();\n};\n\n\n", "import { ISettings } from '../interfaces';\n\nexport const DEFAULTS: ISettings = {\n    particlesNumber: 70,\n    lgParticlesNumber: 60,\n    mdParticlesNumber: 50,\n    smParticlesNumber: 30,\n    resizeDebounceTime: 1000,\n\n    particlesColors: [],\n\n    minSpeed: -2,\n    maxSpeed: 2,\n\n    minSize: 5,\n    maxSize: 10,\n\n    // connection lines ------------\n    connected: true,\n    connectionColor: 'rgb(70,126,150)',\n    connectionSize: 0.09,\n    lgConnectionSize: 0.15,\n    mdConnectionSize: 0.2,\n    smConnectionSize: 0.2,\n\n    // scale effect\n    maxScale: 2,\n    minScale: 0.5,\n    scaleStep: 0.01,\n\n    // fade in/out effect ---------\n    opacityStep: 0.001,\n};\n\n/**\n * Merge settings with the defaults\n */\nexport const mergeSettings = (defaults: ISettings, settings?: ISettings) : ISettings => {\n    if(!settings) return { ...defaults };\n    return { ...defaults, ...settings };\n};\n", "/**\n * Checks if `value` is the\n * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)\n * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is an object, else `false`.\n * @example\n *\n * _.isObject({});\n * // => true\n *\n * _.isObject([1, 2, 3]);\n * // => true\n *\n * _.isObject(_.noop);\n * // => true\n *\n * _.isObject(null);\n * // => false\n */\nfunction isObject(value) {\n  var type = typeof value;\n  return value != null && (type == 'object' || type == 'function');\n}\n\nexport default isObject;\n", "/** Detect free variable `global` from Node.js. */\nvar freeGlobal = typeof global == 'object' && global && global.Object === Object && global;\n\nexport default freeGlobal;\n", "import freeGlobal from './_freeGlobal.js';\n\n/** Detect free variable `self`. */\nvar freeSelf = typeof self == 'object' && self && self.Object === Object && self;\n\n/** Used as a reference to the global object. */\nvar root = freeGlobal || freeSelf || Function('return this')();\n\nexport default root;\n", "import root from './_root.js';\n\n/**\n * Gets the timestamp of the number of milliseconds that have elapsed since\n * the Unix epoch (1 January 1970 00:00:00 UTC).\n *\n * @static\n * @memberOf _\n * @since 2.4.0\n * @category Date\n * @returns {number} Returns the timestamp.\n * @example\n *\n * _.defer(function(stamp) {\n *   console.log(_.now() - stamp);\n * }, _.now());\n * // => Logs the number of milliseconds it took for the deferred invocation.\n */\nvar now = function() {\n  return root.Date.now();\n};\n\nexport default now;\n", "/** Used to match a single whitespace character. */\nvar reWhitespace = /\\s/;\n\n/**\n * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace\n * character of `string`.\n *\n * @private\n * @param {string} string The string to inspect.\n * @returns {number} Returns the index of the last non-whitespace character.\n */\nfunction trimmedEndIndex(string) {\n  var index = string.length;\n\n  while (index-- && reWhitespace.test(string.charAt(index))) {}\n  return index;\n}\n\nexport default trimmedEndIndex;\n", "import trimmedEndIndex from './_trimmedEndIndex.js';\n\n/** Used to match leading whitespace. */\nvar reTrimStart = /^\\s+/;\n\n/**\n * The base implementation of `_.trim`.\n *\n * @private\n * @param {string} string The string to trim.\n * @returns {string} Returns the trimmed string.\n */\nfunction baseTrim(string) {\n  return string\n    ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')\n    : string;\n}\n\nexport default baseTrim;\n", "import root from './_root.js';\n\n/** Built-in value references. */\nvar Symbol = root.Symbol;\n\nexport default Symbol;\n", "import Symbol from './_Symbol.js';\n\n/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/** Used to check objects for own properties. */\nvar hasOwnProperty = objectProto.hasOwnProperty;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the raw `toStringTag`.\n */\nfunction getRawTag(value) {\n  var isOwn = hasOwnProperty.call(value, symToStringTag),\n      tag = value[symToStringTag];\n\n  try {\n    value[symToStringTag] = undefined;\n    var unmasked = true;\n  } catch (e) {}\n\n  var result = nativeObjectToString.call(value);\n  if (unmasked) {\n    if (isOwn) {\n      value[symToStringTag] = tag;\n    } else {\n      delete value[symToStringTag];\n    }\n  }\n  return result;\n}\n\nexport default getRawTag;\n", "/** Used for built-in method references. */\nvar objectProto = Object.prototype;\n\n/**\n * Used to resolve the\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\n * of values.\n */\nvar nativeObjectToString = objectProto.toString;\n\n/**\n * Converts `value` to a string using `Object.prototype.toString`.\n *\n * @private\n * @param {*} value The value to convert.\n * @returns {string} Returns the converted string.\n */\nfunction objectToString(value) {\n  return nativeObjectToString.call(value);\n}\n\nexport default objectToString;\n", "import Symbol from './_Symbol.js';\nimport getRawTag from './_getRawTag.js';\nimport objectToString from './_objectToString.js';\n\n/** `Object#toString` result references. */\nvar nullTag = '[object Null]',\n    undefinedTag = '[object Undefined]';\n\n/** Built-in value references. */\nvar symToStringTag = Symbol ? Symbol.toStringTag : undefined;\n\n/**\n * The base implementation of `getTag` without fallbacks for buggy environments.\n *\n * @private\n * @param {*} value The value to query.\n * @returns {string} Returns the `toStringTag`.\n */\nfunction baseGetTag(value) {\n  if (value == null) {\n    return value === undefined ? undefinedTag : nullTag;\n  }\n  return (symToStringTag && symToStringTag in Object(value))\n    ? getRawTag(value)\n    : objectToString(value);\n}\n\nexport default baseGetTag;\n", "/**\n * Checks if `value` is object-like. A value is object-like if it's not `null`\n * and has a `typeof` result of \"object\".\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\n * @example\n *\n * _.isObjectLike({});\n * // => true\n *\n * _.isObjectLike([1, 2, 3]);\n * // => true\n *\n * _.isObjectLike(_.noop);\n * // => false\n *\n * _.isObjectLike(null);\n * // => false\n */\nfunction isObjectLike(value) {\n  return value != null && typeof value == 'object';\n}\n\nexport default isObjectLike;\n", "import baseGetTag from './_baseGetTag.js';\nimport isObjectLike from './isObjectLike.js';\n\n/** `Object#toString` result references. */\nvar symbolTag = '[object Symbol]';\n\n/**\n * Checks if `value` is classified as a `Symbol` primitive or object.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to check.\n * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.\n * @example\n *\n * _.isSymbol(Symbol.iterator);\n * // => true\n *\n * _.isSymbol('abc');\n * // => false\n */\nfunction isSymbol(value) {\n  return typeof value == 'symbol' ||\n    (isObjectLike(value) && baseGetTag(value) == symbolTag);\n}\n\nexport default isSymbol;\n", "import baseTrim from './_baseTrim.js';\nimport isObject from './isObject.js';\nimport isSymbol from './isSymbol.js';\n\n/** Used as references for various `Number` constants. */\nvar NAN = 0 / 0;\n\n/** Used to detect bad signed hexadecimal string values. */\nvar reIsBadHex = /^[-+]0x[0-9a-f]+$/i;\n\n/** Used to detect binary string values. */\nvar reIsBinary = /^0b[01]+$/i;\n\n/** Used to detect octal string values. */\nvar reIsOctal = /^0o[0-7]+$/i;\n\n/** Built-in method references without a dependency on `root`. */\nvar freeParseInt = parseInt;\n\n/**\n * Converts `value` to a number.\n *\n * @static\n * @memberOf _\n * @since 4.0.0\n * @category Lang\n * @param {*} value The value to process.\n * @returns {number} Returns the number.\n * @example\n *\n * _.toNumber(3.2);\n * // => 3.2\n *\n * _.toNumber(Number.MIN_VALUE);\n * // => 5e-324\n *\n * _.toNumber(Infinity);\n * // => Infinity\n *\n * _.toNumber('3.2');\n * // => 3.2\n */\nfunction toNumber(value) {\n  if (typeof value == 'number') {\n    return value;\n  }\n  if (isSymbol(value)) {\n    return NAN;\n  }\n  if (isObject(value)) {\n    var other = typeof value.valueOf == 'function' ? value.valueOf() : value;\n    value = isObject(other) ? (other + '') : other;\n  }\n  if (typeof value != 'string') {\n    return value === 0 ? value : +value;\n  }\n  value = baseTrim(value);\n  var isBinary = reIsBinary.test(value);\n  return (isBinary || reIsOctal.test(value))\n    ? freeParseInt(value.slice(2), isBinary ? 2 : 8)\n    : (reIsBadHex.test(value) ? NAN : +value);\n}\n\nexport default toNumber;\n", "import isObject from './isObject.js';\nimport now from './now.js';\nimport toNumber from './toNumber.js';\n\n/** Error message constants. */\nvar FUNC_ERROR_TEXT = 'Expected a function';\n\n/* Built-in method references for those with the same name as other `lodash` methods. */\nvar nativeMax = Math.max,\n    nativeMin = Math.min;\n\n/**\n * Creates a debounced function that delays invoking `func` until after `wait`\n * milliseconds have elapsed since the last time the debounced function was\n * invoked. The debounced function comes with a `cancel` method to cancel\n * delayed `func` invocations and a `flush` method to immediately invoke them.\n * Provide `options` to indicate whether `func` should be invoked on the\n * leading and/or trailing edge of the `wait` timeout. The `func` is invoked\n * with the last arguments provided to the debounced function. Subsequent\n * calls to the debounced function return the result of the last `func`\n * invocation.\n *\n * **Note:** If `leading` and `trailing` options are `true`, `func` is\n * invoked on the trailing edge of the timeout only if the debounced function\n * is invoked more than once during the `wait` timeout.\n *\n * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred\n * until to the next tick, similar to `setTimeout` with a timeout of `0`.\n *\n * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)\n * for details over the differences between `_.debounce` and `_.throttle`.\n *\n * @static\n * @memberOf _\n * @since 0.1.0\n * @category Function\n * @param {Function} func The function to debounce.\n * @param {number} [wait=0] The number of milliseconds to delay.\n * @param {Object} [options={}] The options object.\n * @param {boolean} [options.leading=false]\n *  Specify invoking on the leading edge of the timeout.\n * @param {number} [options.maxWait]\n *  The maximum time `func` is allowed to be delayed before it's invoked.\n * @param {boolean} [options.trailing=true]\n *  Specify invoking on the trailing edge of the timeout.\n * @returns {Function} Returns the new debounced function.\n * @example\n *\n * // Avoid costly calculations while the window size is in flux.\n * jQuery(window).on('resize', _.debounce(calculateLayout, 150));\n *\n * // Invoke `sendMail` when clicked, debouncing subsequent calls.\n * jQuery(element).on('click', _.debounce(sendMail, 300, {\n *   'leading': true,\n *   'trailing': false\n * }));\n *\n * // Ensure `batchLog` is invoked once after 1 second of debounced calls.\n * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });\n * var source = new EventSource('/stream');\n * jQuery(source).on('message', debounced);\n *\n * // Cancel the trailing debounced invocation.\n * jQuery(window).on('popstate', debounced.cancel);\n */\nfunction debounce(func, wait, options) {\n  var lastArgs,\n      lastThis,\n      maxWait,\n      result,\n      timerId,\n      lastCallTime,\n      lastInvokeTime = 0,\n      leading = false,\n      maxing = false,\n      trailing = true;\n\n  if (typeof func != 'function') {\n    throw new TypeError(FUNC_ERROR_TEXT);\n  }\n  wait = toNumber(wait) || 0;\n  if (isObject(options)) {\n    leading = !!options.leading;\n    maxing = 'maxWait' in options;\n    maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;\n    trailing = 'trailing' in options ? !!options.trailing : trailing;\n  }\n\n  function invokeFunc(time) {\n    var args = lastArgs,\n        thisArg = lastThis;\n\n    lastArgs = lastThis = undefined;\n    lastInvokeTime = time;\n    result = func.apply(thisArg, args);\n    return result;\n  }\n\n  function leadingEdge(time) {\n    // Reset any `maxWait` timer.\n    lastInvokeTime = time;\n    // Start the timer for the trailing edge.\n    timerId = setTimeout(timerExpired, wait);\n    // Invoke the leading edge.\n    return leading ? invokeFunc(time) : result;\n  }\n\n  function remainingWait(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime,\n        timeWaiting = wait - timeSinceLastCall;\n\n    return maxing\n      ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)\n      : timeWaiting;\n  }\n\n  function shouldInvoke(time) {\n    var timeSinceLastCall = time - lastCallTime,\n        timeSinceLastInvoke = time - lastInvokeTime;\n\n    // Either this is the first call, activity has stopped and we're at the\n    // trailing edge, the system time has gone backwards and we're treating\n    // it as the trailing edge, or we've hit the `maxWait` limit.\n    return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||\n      (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));\n  }\n\n  function timerExpired() {\n    var time = now();\n    if (shouldInvoke(time)) {\n      return trailingEdge(time);\n    }\n    // Restart the timer.\n    timerId = setTimeout(timerExpired, remainingWait(time));\n  }\n\n  function trailingEdge(time) {\n    timerId = undefined;\n\n    // Only invoke if we have `lastArgs` which means `func` has been\n    // debounced at least once.\n    if (trailing && lastArgs) {\n      return invokeFunc(time);\n    }\n    lastArgs = lastThis = undefined;\n    return result;\n  }\n\n  function cancel() {\n    if (timerId !== undefined) {\n      clearTimeout(timerId);\n    }\n    lastInvokeTime = 0;\n    lastArgs = lastCallTime = lastThis = timerId = undefined;\n  }\n\n  function flush() {\n    return timerId === undefined ? result : trailingEdge(now());\n  }\n\n  function debounced() {\n    var time = now(),\n        isInvoking = shouldInvoke(time);\n\n    lastArgs = arguments;\n    lastThis = this;\n    lastCallTime = time;\n\n    if (isInvoking) {\n      if (timerId === undefined) {\n        return leadingEdge(lastCallTime);\n      }\n      if (maxing) {\n        // Handle invocations in a tight loop.\n        clearTimeout(timerId);\n        timerId = setTimeout(timerExpired, wait);\n        return invokeFunc(lastCallTime);\n      }\n    }\n    if (timerId === undefined) {\n      timerId = setTimeout(timerExpired, wait);\n    }\n    return result;\n  }\n  debounced.cancel = cancel;\n  debounced.flush = flush;\n  return debounced;\n}\n\nexport default debounce;\n", "import { ISettings, IState } from './interfaces';\nimport { drawConnections } from './domain/connections-provider';\nimport { createParticles, drawParticle, moveParticle } from './domain/particles-provider';\nimport { DEFAULTS, mergeSettings } from './domain/settings-provider';\nimport { canvas, IRectProps, rect } from 'mz-canvas';\nimport { animate } from 'mz-math';\nimport tinycolor from 'tinycolor2';\nimport { getParticlesNumberPerViewport } from './domain/viewport-provider';\nimport debounce from 'lodash-es/debounce'\n\nconst redraw = (options: ISettings, state: IState) => {\n\n    const { $canvas, ctx } = state;\n\n    // set bg color or clear the canvas ---------------------------\n    const rectProps: IRectProps = {\n        x: 0,\n        y: 0,\n        w: $canvas.width,\n        h: $canvas.height,\n    };\n\n    if(options.canvasColor){\n        rectProps.fillStyle = options.canvasColor;\n    }\n    else{\n        rectProps.clear = true;\n    }\n\n    rect(rectProps, ctx);\n\n    // draw the particle connections -------------------------------\n    if(options.connected){\n        drawConnections(options, state);\n    }\n\n    // draw the updated particles ------------------\n    for(let i= 0; i<state.particles.length; i++){\n        const particle = state.particles[i];\n        drawParticle(particle, options, state);\n        state.particles[i] = moveParticle(particle, options, state);\n    }\n};\n\n/**\n * Entry point.\n */\nexport const init = (settings?: ISettings) => {\n\n    const options = mergeSettings(DEFAULTS, settings);\n    if(!options.$placeholder) return;\n\n    const rect = options.$placeholder.getBoundingClientRect();\n\n    const canvasProps = {\n        width: rect.width,\n        height: rect.height,\n    };\n\n    const { ctx, $canvas } = canvas(canvasProps);\n    if(!ctx) return;\n\n    options.$placeholder.append($canvas);\n\n    // parse connection lines color ----------\n    const connectionsColor = tinycolor(options.connectionColor);\n    const tConnectionsRGB = connectionsColor.toRgb();\n\n    const state: IState = {\n        connectionRgbColor: [tConnectionsRGB.r, tConnectionsRGB.g, tConnectionsRGB.b, tConnectionsRGB.a],\n        particles: [],\n        ctx,\n        $canvas,\n        vpParticlesNumber: getParticlesNumberPerViewport(options),\n    };\n\n    // create random particles -----------------------------\n    state.particles = createParticles(options, state);\n\n    const _debounce = debounce( () => {\n        const newParticlesNumber = getParticlesNumberPerViewport(options);\n        if(state.vpParticlesNumber === newParticlesNumber) return;\n\n        // reset particles list using current viewport settings\n        state.vpParticlesNumber = newParticlesNumber;\n        state.particles = createParticles(options, state);\n    }, options.resizeDebounceTime);\n\n    const api = animate({\n\n        // A function to be called on each animation frame.\n        // It receives an object of type IAnimationResult.\n        callback: () => {\n            if(!ctx) return;\n            redraw(options, state);\n        },\n        restartOnResize: true,\n        resizeCallback: () => {\n            if(!options.$placeholder) return;\n\n            // reset canvas size according to the current viewport\n            const rect = options.$placeholder.getBoundingClientRect();\n            $canvas.width = rect.width;\n            $canvas.height = rect.height;\n\n            redraw(options, state);\n            _debounce();\n        },\n    });\n\n    // Starts the animation.\n    api.start();\n\n    // document.body.append($canvas);\n    return $canvas;\n};", "import { init as particles } from './app';\n\ndeclare global {\n    interface Window {\n        particles: typeof particles,\n    }\n}\n\nwindow.particles = particles;\n\nexport default particles;\n", "import {\n  flowerExamples,\n  starExamples,\n} from './examples';\nimport { initMobileMenu } from './menu/mobile-menu';\nimport { initMenuCollapsible, initMenuScroll } from './menu/side-menu';\nimport { handleDarkLightModes } from './dark-mode';\nimport particles from 'mz-particles';\n\nconst initAnimation = () => {\n  const $placeholder = document.getElementById('hp-animation');\n  if(!$placeholder) return;\n\n  particles({\n    $placeholder,\n    particlesNumber: 100,\n\n    minSize: 10,\n    maxSize: 30,\n\n    particlesColors: [\n      '#fffc00', '#B22B05', '#DEA12E',\n        '#B4BF0B', '#E38458', '#935412',\n        '#47da87'\n    ],\n    connectionColor: '#b2af24',\n\n    // stars -------------\n    svgPathData: [\n        'M58.67332 0c7.45433 10.43536 13.25172 19.52497 17.39217 27.26882 6.56698-2.996 14.30486-6.011 23.21231-9.04482.41164 14.68843.00671 26.69722-1.2148 36.02635 6.76344.84207 14.39137 2.18699 22.88277 4.03331-6.18796 11.0145-11.87514 20.01691-17.06154 27.00725 5.25822 1.7666 10.96362 3.91142 17.11577 6.43313-21.76577 26.57549-37.30383 39.13443-46.61418 37.67683-3.74365-.5861-7.26574-3.51633-10.17905-7.68338.472-5.52076.73228-10.97514.78228-16.36371 2.70058-5.95622 6.0788-11.03431 10.13468-15.2343 4.37592-4.5314 9.35987-7.85341 14.95183-9.96604a.931.931 0 0 0 .34058-.22415c.35708-.36977.3468-.959-.02297-1.31609-.6694-.64643-1.65487-.84193-2.52035-.5C82.13252 80.38116 77.17492 83.67676 73 88c-2.9904 3.09666-5.67606 6.82081-8.05584 11.17315-.15778-6.03152-.64987-12.24859-1.47628-18.6512l.14968-.61248c1.3851-5.51866 3.49158-10.37423 6.31944-14.5667 2.91171-4.3168 6.46768-7.7519 10.66792-10.3053a.75484.75484 0 0 0 .2337-.22292c.23313-.34563.14193-.81482-.2037-1.04795-.61627-.41568-1.41972-.4287-2.04913-.0332-4.30025 2.702-7.83962 6.11265-10.6181 10.23192-2.13597 3.1667-3.89664 6.86245-5.27992 11.08801-1.28178-8.21598-3.0965-16.72775-5.44412-25.5353-3.096-11.61516-2.40154-19.12183 2.0834-22.51998a.86327.86327 0 0 0 .28435-.37808c.1712-.44498-.05074-.94449-.49572-1.11568-.44497-.1712-.94448.05074-1.11568.49571l-.03201.0781c-1.11313 2.55823-7.77942 3.2974-2.99156 23.17734 2.2421 9.30957 3.96449 18.18312 5.16734 26.61949-.97124-2.14063-2.06362-4.1105-3.27713-5.9096-2.77848-4.11928-6.31785-7.52992-10.6181-10.23194-.62941-.39549-1.43287-.38247-2.04913.0332-.34563.23314-.43684.70233-.2037 1.04796a.75484.75484 0 0 0 .2337.22292c4.20023 2.5534 7.7562 5.9885 10.66792 10.3053 2.95081 4.37475 5.11615 9.47152 6.49601 15.29029.0085.03582.01922.07054.03377.1047.48568 5.24206.75122 10.29944.79606 15.17097-2.4781-4.66924-5.296-8.63882-8.45371-11.90873-4.17492-4.32325-9.13253-7.61885-14.87282-9.8868-.86548-.34193-1.85095-.14643-2.52035.5-.36977.35709-.38005.94632-.02297 1.31609a.931.931 0 0 0 .34058.22415c5.59196 2.11263 10.5759 5.43464 14.95183 9.96604 4.25585 4.40706 7.76558 9.78096 10.53093 16.12217-.069 3.1028-.20402 6.24951-.40504 9.44014.74946 1.43664 1.56516 2.79132 2.43515 4.0357-1.00333 11.78917-2.96704 23.8792-5.88906 36.26984-.13993.5934-.66957 1.01267-1.27925 1.01267-.46692 0-.84543-.37851-.84543-.84543a.8466.8466 0 0 1 .0173-.17023c2.90522-14.13383 4.75898-27.56802 5.56129-40.30255-.01196-.01857-.02228-.03833-.03258-.0581-2.93804 7.2666-7.50555 13.06029-12.7642 14.16895-9.2215 1.94413-25.39386-9.7823-48.51707-35.17928 5.85574-2.7672 11.3069-5.1551 16.3535-7.16369C11.69197 82.50978 6.08838 73.62038 0 62.78315c7.95005-1.72862 15.14322-3.01773 21.57951-3.86732-1.70229-8.73061-2.94071-19.65126-3.71542-32.76124 7.58997 1.86395 14.37489 3.78547 20.35474 5.76455C42.37833 23.14063 49.19681 12.50056 58.67333 0Z',\n      'M87.83013 0c-14 14-14 29.33333 0 46 21 25-32.43145 60-49 60-.19935 0-.39869-.0042-.59797-.01255 7.08619-6.21018 11.67362-14.22984 13.76303-24.05977 4.5614-21.4597.56555-33.54498-11.98755-36.25582L39.943 45.658l.22215.0701c9.81728 3.21101 12.55675 15.02165 8.21842 35.4319-2.12755 10.00933-6.56305 18.12634-13.3065 24.35103 1.04573.2715 2.09961.43219 3.1551.47641-8.57298 7.51287-20.80434 12.3759-36.69332 14.5883l-1.35436-.28787a.23289.23289 0 0 1-.1825-.19756c-.0167-.12753.07315-.24445.20068-.26118 15.04296-1.9701 26.66776-6.7428 34.8744-14.3181C19.89489 101.5944 6.20894 74.65142 10.83013 46c3.33334-20.66667 29-36 77-46Z',\n        'M32.64324 5.29856c2.59029-16.28774 1.63084 10.0274 5.03065 11.60571 2.26654 1.05222 5.50004-.2345 9.70048-3.86014-1.07502 7.90547-.63924 12.88644 1.30734 14.94292 1.3677 1.44492 4.26912.18726 8.70428-3.77298-3.93673 7.89951-4.80016 13.32876-2.59029 16.28773 1.87068 2.5048 6.43243 1.10188 13.68526-4.20876-1.12472 10.18734-2.92624 16.36787-5.40456 18.5416-1.70034 1.49135 2.3716 2.13893 12.2158 1.9427-5.58476 7.87184-9.07566 13.86557-10.47268 17.98119-.99577 2.93352 4.13046 4.15807 15.3787 3.67364L66.73695 96.6748l12.30295 2.93891c-14.36758 17.01214-25.45219 26.60399-33.25381 28.77553 12.96769 10.97549 31.47137 18.39846 55.51063 22.26853a.52936.52936 0 0 1 .34424.21152c.1719.2366.11945.56775-.11715.73965l-1.03508.75203-.95963-.12093c-25.44269-3.27218-44.86332-11.04652-58.26188-23.32302-11.00026-.05391-21.42406-7.75649-29.06976-20.13316C5.90336 98.59515 1.49196 85.23883.1915 70.37455c-2.98436-34.11136 29.86146-48.78825 32.45174-65.076ZM23.93616 44.8187l-1.03508.75203c-6.6714 31.01498-3.4286 55.57703 9.72845 73.68614 2.52947 3.48153 5.4087 6.70158 8.6377 9.66015a23.81493 23.81493 0 0 0 2.18333-.09033c.74274-.06498 1.52125-.2108 2.33553-.43745-3.98953-3.37666-7.45484-7.08912-10.39636-11.13778-12.50078-17.20584-16.04875-41.18155-10.6439-71.92711.04922-.28005-.13789-.54697-.41793-.5962a.51483.51483 0 0 0-.39174.09055Z',\n        'M56.72612 0c1.76197 9.54577 1.8297 18.5861.2032 27.12098-1.62649 8.5349-4.8722 16.1707-9.73712 22.90742 4.33393-2.252 8.4744-3.5008 12.4214-3.74636 3.94701-.24556 9.07581.42653 15.3864 2.01627-9.08505 18.11728-15.91566 29.94085-20.49182 35.47072-15.6462 18.907-29.6972 23.22423-38.58333 20.50278-.28836-1.32611-.50289-2.65412-.64304-3.98574-1.37074-13.0236 4.3172-26.92098 17.0638-41.69214.11537-.13362.10052-.33546-.03313-.4508a.31964.31964 0 0 0-.24224-.07589l-.80662.08478c-13.53152 14.52997-19.5758 28.6499-18.13283 42.35982a38.10111 38.10111 0 0 0 .39956 2.79574c.30065.1536.60307.29479.90797.42403.47785.20255.97359.3831 1.48653.5402 2.53794 11.63025 10.8125 22.98369 24.82425 34.05861a.3291.3291 0 0 1 .12309.22364c.01898.18061-.11205.34241-.29265.3614l-.80662.08477-.58659-.43227c-14.8429-11.00877-23.39489-22.76223-25.65598-35.26037C5.03057 98.9635-1.27051 84.98683.21865 60.75646c.39413-6.41305 2.7909-17.71297 7.19028-33.89976 4.87926.86806 9.21223 2.70475 12.9989 5.51005 3.78667 2.8053 6.0879 5.88347 6.9037 9.23451 2.06274-9.0081 5.30845-16.6439 9.73713-22.90741C42.42484 11.09027 48.98399 4.85899 56.72612 0Z',\n        'M37.6926 4.00663C56.78216-3.89666 77.25714 1.2936 89 7.53739c3.54229 1.88347 6.82105 4.5256 9.49805 7.88841C78.69208 16.79103 62.8596 20.49463 51 26.5374 27.88266 38.31626 16.762 59.7586 17.63803 90.86436l.68098 1.33651a.37197.37197 0 0 0 .32369.20302c.20538.00427.37535-.15876.37964-.36414.6272-30.13266 11.89173-50.77877 33.79362-61.93834 11.68636-5.9545 27.72596-9.66177 48.11878-11.12182-.73939-1.26166-1.55543-2.44678-2.43669-3.5538 18.41365-1.26779 40.26227-.51428 65.54527 2.26133l1.5947.17724.681 1.33651c.2076.40745.0456.90605-.36185 1.11366a.82775.82775 0 0 1-.45005.08689c-24.95206-2.24351-46.47618-2.71745-64.57238-1.42183 3.44886 5.89216 5.21358 13.45732 4.06526 22.5578-1.86958 14.81648-11.5583 35.79674-33 33-5.23337-.68262-12.82815 16.75836-12.82815 23.75836 0 .91152-.81695-.50066-2.03696-2.92679l-.25804-.516c-.79053-1.5888-1.72535-3.53344-2.70549-5.52071l-.32825-.66358C51.15087 83.24362 48.20432 77.7605 47 78.5374c-6.8913 4.44548-14.59055 21.02808-23.09775 49.7478C1.1145 86.039-4.18625 53.4564 8 30.5374c.97-1.8243-1.69667-5.15763-8-10 11.4965-1.944 18.06396-3.66905 19.70238-5.17516C21.1238 14.0556 20.55634 10.114 18 3.5374c10.53177 1.38786 17.09597 1.54427 19.6926.46924Z'\n    ],\n\n    // effects ------------\n    rotate: true,\n    // fadeInOut: true,\n\n    // scale effect -------\n    scaleInOut: true,\n    maxScale: 1.75,\n    minScale: 1,\n    scaleStep: 0.005,\n  });\n};\n\nconst init = () => {\n  const $special = document.getElementById('special-page');\n  if($special){\n    initAnimation();\n    return;\n  }\n\n  initMobileMenu();\n  initMenuScroll();\n  initMenuCollapsible();\n  handleDarkLightModes();\n};\n\n\ndocument.addEventListener('DOMContentLoaded', () => {\n  init();\n  starExamples();\n  flowerExamples();\n});\n\nexport {};\n"],
  "mappings": "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",
  "names": ["SVG_NAMESPACE", "XMLNS_NAMESPACE", "DEFAULT_DECIMAL_PLACES", "createSVG", "props", "$svg", "viewBox", "setAttributes", "getCommonAttributes", "setAttributes", "$svgElement", "attr", "pair", "prop", "value", "getCommonAttributes", "props", "createPath", "props", "$path", "SVG_NAMESPACE", "setAttributes", "getCommonAttributes", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "getRandom", "min", "max", "decimalPlaces", "setDecimalPlaces", "getRandomInt", "mod", "n", "m", "getRandomHSLColorWithinRanges", "hueStart", "hueEnd", "saturationStart", "saturationEnd", "lightStart", "lightEnd", "h", "getRandom", "s", "l", "hslToHex", "hsl", "h", "s", "l", "r", "g", "b", "hue2rgb", "p", "q", "t", "toHex", "x", "hex", "NUMBER_REGEX", "scan", "pathData", "result", "current", "line", "col", "isEnd", "addKeywordToken", "tokenType", "addNumberToken", "num", "addError", "msg", "matchNumber", "scanToken", "char", "matchRes", "parse", "scanResult", "pathData", "tokens", "errors", "error", "token", "msg", "current", "isEnd", "areArcFlagsValid", "tokenType", "_a", "_b", "val4", "val5", "parseCommand", "paramsCount", "nextParamsTokenType", "isRelative", "params", "i", "nextTokens", "nextCommand", "nextParams", "j", "parseNext", "numberToString", "num", "decimalPlaces", "_num", "i", "parts", "intPart", "decimalPart", "combineParams", "params", "combined", "param", "str", "pathDataMinify", "pathData", "d", "lastCommand", "item", "pathDataToRelative", "pathData", "commands", "x", "y", "mx", "my", "i", "savedX", "savedY", "pathDataToString", "pathData", "minify", "decimalPlaces", "d", "pathDataMinify", "item", "param", "i", "parsePath", "d", "scanResult", "scan", "parse", "pathToRel", "beautify", "decimalPlaces", "parsed", "pathDataToString", "pathDataToRelative", "createStar", "props", "createStar2", "createStar3", "createStar1", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_RAYS_NUMBER", "dots", "raysNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "halfAngle", "i", "angle", "d", "dot", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "dot1", "dot2", "createFlower", "props", "centerX", "centerY", "outerRadius", "innerRadius", "MIN_PETALS_NUMBER", "dots", "petalsNumber", "decimalPlaces", "DEFAULT_DECIMAL_PLACES", "angleDiff", "i", "angle", "d", "outerDot", "Y", "innerDot2", "outerDot2", "pathToRel", "pathProps", "__spreadProps", "__spreadValues", "createPath", "starExamples", "$btn", "$placeholder", "renderStar", "$svg", "createSVG", "hslColor", "xo", "hex", "Qt", "raysNumber", "Tt", "type", "$star", "createStar", "ex", "flowerExamples", "renderflower", "petalsNumber", "innerRadius", "$flower", "createFlower", "initMobileMenu", "$btn", "evt", "$sideMenu", "$close", "COLLAPSIBLE_STORAGE_KEY", "initMenuScroll", "$menu", "path", "$link", "getStateFromStorage", "data", "menu", "ex", "saveStateToStorage", "$titles", "$title", "id", "opened", "restoreCollapsible", "menuItem", "toggle", "saveToStorage", "_a", "$arrow", "initMenuCollapsible", "isOpened", "MODE_STORAGE_KEY", "handleDarkLightModes", "mode", "$moveToDarkBtn", "$moveToLightBtn", "moveToDark", "moveToLight", "setAttributes", "$canvas", "attributes", "attr", "value", "key", "setContextProps", "props", "ctx", "prop", "canvas", "stroke", "fill", "line", "x1", "y1", "x2", "y2", "rect", "x", "y", "w", "h", "circle", "cx", "cy", "r", "startAngleRad", "endAngleRad", "tt", "setDecimalPlaces", "num", "decimalPlaces", "coefficient", "__pow", "vSub", "vector1", "vector2", "vector", "i", "vLength", "sum", "v2Distance", "diff", "getRandom", "min", "max", "getRandomInt", "getRandomBoolean", "getRandomItemFromArray", "array", "randomIndex", "getRandomHexColor", "hslColor", "getRandomHSLColor", "hslToHex", "s", "l", "hsl", "g", "b", "hue2rgb", "p", "q", "t", "toHex", "hex", "animate", "_duration", "startTime", "animationId", "elapsed", "previousTimeStamp", "animating", "observer", "stop", "restart", "start", "pause", "resume", "step", "timeStamp", "getResult", "observerHandler", "_entries", "_observer", "getElapsedTime", "isAnimating", "getStartTime", "getPercent", "getResizeObserver", "rgbaToString", "a", "SM_BREAK_POINT", "MD_BREAK_POINT", "LG_BREAK_POINT", "getViewPortSize", "vw", "vh", "getConnectionSizePerViewport", "options", "placeholderWidth", "getParticlesNumberPerViewport", "drawConnections", "state", "_a", "particles", "connectionRgbColor", "maxConnectionSize", "particle1", "j", "particle2", "distance", "gr", "opacity", "u", "Le", "degreesToRadians", "degrees", "res", "isNumber", "linearEquation", "equation", "quadraticEquation", "c", "d", "discriminant", "t1", "t2", "v2QuadraticBezierCurve", "startControlPoint", "centerControlPoint", "endControlPoint", "temp1", "temp2", "temp3", "v2CubicBezierCurve", "center1ControlPoint", "center2ControlPoint", "temp4", "v2QuadraticBezierCurveExtrema", "a1", "b1", "res1", "a2", "b2", "res2", "v2CubicBezierCurveExtrema", "c1", "equation1", "c2", "equation2", "v2QuadraticBezierBBox", "extrema", "minX", "minY", "maxX", "maxY", "percent", "point", "v2CubicBezierBBox", "NUMBER_REGEX", "scan", "pathData", "result", "current", "col", "isEnd", "addKeywordToken", "tokenType", "addNumberToken", "addError", "msg", "matchNumber", "scanToken", "char", "matchRes", "parse", "scanResult", "tokens", "errors", "error", "token", "areArcFlagsValid", "_b", "val4", "val5", "parseCommand", "paramsCount", "nextParamsTokenType", "isRelative", "params", "nextTokens", "nextCommand", "nextParams", "parseNext", "pathDataToAbsolute", "commands", "mx", "my", "savedX", "savedY", "maximizeAbsolutePath", "prev", "parsePath", "getAngle", "bx", "by", "PI2", "formatBBox", "xmin", "xmax", "ymin", "ymax", "getArcBoundingBox", "rx", "ry", "angleRad", "largeArc", "sweep", "x1prime", "y1prime", "radicant", "cxPrime", "cyPrime", "ratio", "factor", "txMin", "txMax", "tyMin", "tyMax", "tmpY", "tmpX", "angle1", "angle2", "otherArc", "getPathBBox", "_c", "_d", "parsed", "abs", "item", "centerControlPoint1", "centerControlPoint2", "bbox", "Fn", "Zn", "angleDeg", "largeArcFlag", "sweepFlag", "endX", "endY", "Jt", "_typeof", "obj", "trimLeft", "trimRight", "tinycolor", "color", "opts", "rgb", "inputToRGB", "RsRGB", "GsRGB", "BsRGB", "R", "G", "B", "boundAlpha", "hsv", "rgbToHsv", "v", "rgbToHsl", "allow3Char", "rgbToHex", "allow4Char", "rgbaToHex", "bound01", "hexNames", "secondColor", "hex8String", "rgbaToArgbHex", "secondHex8String", "gradientType", "format", "formatSet", "formattedString", "hasAlpha", "needsAlphaFormat", "fn", "args", "_lighten", "_brighten", "_darken", "_desaturate", "_saturate", "_greyscale", "_spin", "_analogous", "_complement", "_monochromatic", "_splitcomplement", "polyad", "newColor", "convertToPercentage", "ok", "stringInputToObject", "isValidCSSUnit", "rgbToRgb", "hsvToRgb", "hslToRgb", "f", "mod", "pad2", "convertDecimalToHex", "color1", "color2", "amount", "clamp01", "hue", "number", "results", "slices", "part", "ret", "modification", "rgb1", "rgb2", "rgba", "wcag2", "readability", "wcag2Parms", "out", "validateWCAG2Parms", "baseColor", "colorList", "bestColor", "bestScore", "includeFallbackColors", "level", "size", "names", "flip", "o", "flipped", "n", "isOnePointZero", "processPercent", "isPercentage", "val", "parseIntFromHex", "convertHexToDecimal", "matchers", "CSS_INTEGER", "CSS_NUMBER", "CSS_UNIT", "PERMISSIVE_MATCH3", "PERMISSIVE_MATCH4", "named", "match", "parms", "createParticles", "svgPathData", "svgSize", "scaleSize", "minSize", "maxSize", "minSpeed", "maxSpeed", "maxScale", "minScale", "rnd", "V", "particleSize", "re", "po", "tColorRGB", "mn", "moveParticle", "particle", "copy", "__spreadValues", "speed", "scaleStep", "opacityStep", "drawParticle", "fillStyle", "path", "halfWidth", "halfHeight", "DEFAULTS", "mergeSettings", "defaults", "settings", "isObject", "type", "isObject_default", "freeGlobal", "freeGlobal_default", "freeSelf", "root", "root_default", "now", "now_default", "reWhitespace", "trimmedEndIndex", "string", "index", "trimmedEndIndex_default", "reTrimStart", "baseTrim", "baseTrim_default", "Symbol", "Symbol_default", "objectProto", "hasOwnProperty", "nativeObjectToString", "symToStringTag", "getRawTag", "isOwn", "tag", "unmasked", "e", "getRawTag_default", "objectToString", "objectToString_default", "nullTag", "undefinedTag", "baseGetTag", "baseGetTag_default", "isObjectLike", "isObjectLike_default", "symbolTag", "isSymbol", "isSymbol_default", "NAN", "reIsBadHex", "reIsBinary", "reIsOctal", "freeParseInt", "toNumber", "other", "isBinary", "toNumber_default", "FUNC_ERROR_TEXT", "nativeMax", "nativeMin", "debounce", "func", "wait", "lastArgs", "lastThis", "maxWait", "timerId", "lastCallTime", "lastInvokeTime", "leading", "maxing", "trailing", "invokeFunc", "time", "thisArg", "leadingEdge", "timerExpired", "remainingWait", "timeSinceLastCall", "timeSinceLastInvoke", "timeWaiting", "shouldInvoke", "trailingEdge", "cancel", "flush", "debounced", "isInvoking", "debounce_default", "redraw", "rectProps", "init", "canvasProps", "tConnectionsRGB", "_debounce", "newParticlesNumber", "qo", "core_default", "initAnimation", "$placeholder", "$a", "init", "initMobileMenu", "initMenuScroll", "initMenuCollapsible", "handleDarkLightModes", "starExamples", "flowerExamples"]
}
